Disassembly Listing for pmsm_foc_rolo_sam_c21_mclv2
Generated From:
C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/mclv2_sam_c21_pim.X/dist/mclv2_sam_c21_pim/production/mclv2_sam_c21_pim.X.production.elf
Jan 21, 2019 3:01:10 PM

---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/q14_rolo_mcLib.c  --------
1:             /*******************************************************************************
2:              Reduced Order Luenberger Observer Motor Control Library 
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 q14_rolo_mcLib.c
9:             
10:              Summary:
11:                Reduced Order Luenberger Observer related functions and variables
12:             *  implemented in Q14 fixed point arithmetic.
13:            
14:              Description:
15:                This file implements reduced order luenberger observer related functions
16:             
17:             *******************************************************************************/
18:            
19:            // DOM-IGNORE-BEGIN
20:            /*******************************************************************************
21:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
22:            *
23:            * Subject to your compliance with these terms, you may use Microchip software
24:            * and any derivatives exclusively with Microchip products. It is your
25:            * responsibility to comply with third party license terms applicable to your
26:            * use of third party software (including open source software) that may
27:            * accompany Microchip software.
28:            *
29:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:            * PARTICULAR PURPOSE.
33:            *
34:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:             *******************************************************************************/
42:            // DOM-IGNORE-END
43:            
44:            /*******************************************************************************
45:            Headers inclusions
46:            *******************************************************************************/
47:            
48:            #include "q14_generic_mcLib.h"
49:            #include "q14_rolo_mcLib.h"
50:            //#include "userparams.h"
51:            
52:            
53:            
54:            
55:            /*******************************************************************************
56:            Private global variables
57:            *******************************************************************************/
58:            
59:            /* Base parameters set only once, not used within control loop */
60:            static float32_t
61:             f32_sam_fre, /* sampling frequency [Hz] */
62:             f32_bas_spe, /* base speed [rad/sec] */
63:             f32_k_volam, /* internal conversion constant */ 
64:             f32_sta_res, /* stator resistance [Ohm] */
65:             f32_syn_ind, /* synchronous inductance [Hen] */
66:             f32_k_gain,  /* constant in observer coefficient calculation */
67:             f32_c1_coe;  /* constant in observer coefficient calculation */
68:            
69:            
70:            #ifdef  CROSS_COUPLING_ENABLED
71:            static float32_t  f32_k_speed; /* internal conversion constant */
72:            /* debug variables */
73:            static uint32_t
74:             debug_cnt1,
75:             debug_cnt2;
76:            #endif
77:            /******************************************************************************
78:            Safety variables
79:            ******************************************************************************/
80:            static vec2_t
81:             obs_z,   /* observer estimated status vector */
82:             obs_e;   /* observer estimated bemf vector */
83:            
84:            static vecp_t
85:             bemf;   /* observer estimated bemf vector (polar coordinates) */
86:            
87:            static coef_t
88:             l11,   /* constant observer coefficient */
89:             m11,   /* constant observer coefficient */
90:             n11,   /* constant observer coefficient */
91:             k11;   /* constant observer coefficient */
92:            
93:            #ifdef  CROSS_COUPLING_ENABLED
94:            coef_t
95:             hhh,   /* intermediate result in observer variable coefficient calculation */
96:             lll,   /* intermediate result in observer variable coefficient calculation */
97:             xxx,   /* intermediate result in observer variable coefficient calculation */
98:             m21,   /* observer variable coefficient */
99:             n21,   /* observer variable coefficient */
100:            k21;   /* observer variable coefficient */
101:           #endif  // ifdef CROSS_COUPLING_ENABLED
102:           
103:           /* unused observer coefficients
104:            l12 = 0;
105:            l21 = 0;
106:            l22 = l11;
107:            m12 = -m21;
108:            m22 = m11;
109:            n12 = -n21;
110:            n22 = n11;
111:            k12 = -k21;
112:            k22 = k11;
113:           */
114:           
115:           
116:           
117:           static int32_t
118:            sp_fir_acc,  /* speed fir filter accumulator */
119:            sp_iir1_mem, /* speed iir filter memory (first iir) */
120:            sp_iir2_mem, /* speed iir filter memory (second iir) */
121:            sp_iir3_mem; /* speed iir filter memory (third iir) */
122:           
123:           static uint16_t
124:            dph_min,     /* minimum delta phase */
125:                    
126:           #ifdef PH_CLAMP
127:            max_dspeed,  /* maximum speed variation in one sampling period */
128:           #endif // ifdef PH_CLAMP
129:            flx_arg,  /* estimated permanent magnets flux position */
130:            flx_arg_mem, /* estimated permanent magnets flux position memory */
131:            dph_abs_fil; /* filtered one-step phase difference */
132:           
133:           uint16_t dph_global;
134:           static int16_t
135:            k_spe12,  /* internal conversion constant */
136:            speed_min,  /* minimum speed [internal units] */
137:            speed_est,  /* estimated speed [internal units] */
138:            speed_sgn,  /* speed sign */
139:            speed_abs,  /* speed absolute value */
140:            sp_fir_ind,  /* index in fir speed filter memories vector */
141:            sp_fir_vec[8]; /* speed fir filter memories vector */
142:           
143:           int32_t lzx, mix, nvx, kix;
144:           int32_t lzy ,miy, nvy, kiy;
145:           /*******************************************************************************
146:           Functions (private and public)
147:           *******************************************************************************/
148:           
149:           /******************************************************************************
150:           Function:  estimation_set_base_values
151:           Description: base values setting for the observer library
152:           Input:   sampling frequency [Hz]
153:               base speed [rad/sec]
154:               base voltage [V]
155:               base current [A]
156:           Output:   nothing
157:           Modifies:  observer internal constants
158:           ******************************************************************************/
159:           void estimation_set_base_values(float32_t samfreq, float32_t basespe,
160:               float32_t basevol, float32_t basecur)
161:           {
5370  B083B5F0     PUSH {R4, R5, R6, R7, LR}
5372  1C05B083     SUB SP, #12
5374  91011C05     ADDS R5, R0, #0
5376  49129101     STR R1, [SP, #4]
162:            float32_t f32a;
163:           
164:            /* base values setting */
165:            f32_sam_fre = samfreq;
5378  60084912     LDR R1, $d
537A  4F126008     STR R0, [R1]
166:            f32_bas_spe = basespe;
167:           
168:            /* internal useful conversion constants calculation */
169:            f32_k_volam = 1.0f / (basevol * basecur);
537C  1C194F12     LDR R7, [PC, #72]
537E  1C101C19     ADDS R1, R3, #0
5380  47B81C10     ADDS R0, R2, #0
5382  1C0147B8     BLX R7
5384  4C111C01     ADDS R1, R0, #0
5386  20FE4C11     LDR R4, [PC, #68]
5388  58020FE     MOVS R0, #254
538A  47A00580     LSLS R0, R0, #22
538C  4B1047A0     BLX R4
538E  60184B10     LDR R3, [PC, #64]
5390  99016018     STR R0, [R3]
170:            #ifdef  CROSS_COUPLING_ENABLED
171:            f32_k_speed = (BASE_VALUE_FL) / basespe;
172:            #endif
173:           
174:            /* minimum speed in internal units */
175:            f32a = (OBS_MINSPEED_R_S * (BASE_VALUE_FL)) / basespe;
5392  480F9901     LDR R1, [SP, #4]
5394  47A0480F     LDR R0, [PC, #60]
5396  4E0F47A0     BLX R4
176:            speed_min = (int16_t)f32a;
5398  47B04E0F     LDR R6, [PC, #60]
539A  4B0F47B0     BLX R6
539C  80184B0F     LDR R3, [PC, #60]
539E  1C298018     STRH R0, [R3]
177:            /* minimum phase difference */
178:            f32a = OBS_MINFREQ_HZ * 65536.0 / f32_sam_fre;
53A0  480F1C29     ADDS R1, R5, #0
53A2  47A0480F     LDR R0, [PC, #60]
53A4  4B0F47A0     BLX R4
179:            dph_min = (uint16_t)f32a;
53A6  47984B0F     LDR R3, [PC, #60]
53A8  4B0F4798     BLX R3
53AA  80184B0F     LDR R3, [PC, #60]
53AC  1C298018     STRH R0, [R3]
180:           
181:            /* conversion constants between speed in internal units and speed as
182:               filtered phase difference */
183:            f32a = ((32768.0f / FLOAT_PI)) * (f32_bas_spe / f32_sam_fre);
53AE  98011C29     ADDS R1, R5, #0
53B0  47A09801     LDR R0, [SP, #4]
53B2  490D47A0     BLX R4
53B4  47B8490D     LDR R1, [PC, #52]
53B6  47B047B8     BLX R7
184:            k_spe12 = (int16_t)f32a;
53B8  4B0D47B0     BLX R6
53BA  80184B0D     LDR R3, [PC, #52]
53BC  B0038018     STRH R0, [R3]
185:           }
53BE  BDF0B003     ADD SP, #12
53C0  46C0BDF0     POP {R4, R5, R6, R7, PC}
53C2  28D046C0     MOV R8, R8
53C4  200028D0     CMP R0, #208
53C6  37512000     MOVS R0, #0
53C8  3751     ADDS R7, #81
53CA  34C10000     MOVS R0, R0
53CC  34C1     ADDS R4, #193
53CE  28CC0000     MOVS R0, R0
53D0  200028CC     CMP R0, #204
53D2  CBE42000     MOVS R0, #0
53D4  4896CBE4     LDMIA R3!, {R2, R5, R6, R7}
53D6  5DD14896     LDR R0, [PC, #600]
53D8  5DD1     LDRB R1, [R2, R7]
53DA  29380000     MOVS R0, R0
53DC  20002938     CMP R1, #56
53DE  2000     MOVS R0, #0
53E0  48400000     MOVS R0, R0
53E2  60CD4840     LDR R0, [PC, #256]
53E4  60CD     STR R5, [R1, #12]
53E6  292A0000     MOVS R0, R0
53E8  2000292A     CMP R1, #42
53EA  F9832000     MOVS R0, #0
53EC  4622F983     LDRSB.W R4, [R3, #1570]
53EE  29304622     MOV R2, R4
53F0  20002930     CMP R1, #48
53F2  B5F02000     MOVS R0, #0
186:           
187:           /******************************************************************************
188:           Function:  estimation_set_parameters
189:           Description: Luenberger observer coefficients calculation
190:           Input:   stator resistance [Ohm]
191:               synchronous inductance [Hen]
192:           Output:   nothing
193:           Modifies:  observer coefficients
194:           ******************************************************************************/
195:           void estimation_set_parameters(float32_t rsta, float32_t lsyn)
196:           {
31DC  46D6B5F0     PUSH {R4, R5, R6, R7, LR}
31DE  464F46D6     MOV LR, R10
31E0  B580464F     MOV R7, R9
31E2  B083B580     PUSH {R7, LR}
31E4  1C05B083     SUB SP, #12
31E6  1C081C05     ADDS R5, R0, #0
31E8  4C9B1C08     ADDS R0, R1, #0
197:            float32_t  f32a;
198:           
199:            /* preliminary floating point calculations */
200:            f32_sta_res = rsta;
201:            f32_syn_ind = lsyn;
202:            f32_k_gain = OBS_H_GAIN * f32_syn_ind * f32_sam_fre; /* always positive */
31EA  499B4C9B     LDR R4, [PC, #620]
31EC  47A0499B     LDR R1, [PC, #620]
31EE  4B9B47A0     BLX R4
31F0  68194B9B     LDR R3, [PC, #620]
31F2  47A06819     LDR R1, [R3]
31F4  4B9B47A0     BLX R4
31F6  60184B9B     LDR R3, [PC, #620]
31F8  1C296018     STR R0, [R3]
203:            f32_c1_coe = f32_k_gain - f32_sta_res;     /* can be negative */
31FA  4B9A1C29     ADDS R1, R5, #0
31FC  47984B9A     LDR R3, [PC, #616]
31FE  90014798     BLX R3
3200  4E9A9001     STR R0, [SP, #4]
204:           
205:            /*lint -save -e9027*/
206:            /* constant coefficients calc (l11) */
207:            f32a = OBS_C0_GAIN;
208:            l11.shr = 0;
209:            while((16383.0f > f32a) && ((uint16_t)OBS_MAXSHIFTS > l11.shr))
320A  E0004F9A     LDR R7, [PC, #616]
320C  2CE000     B.N 0x3210
320E  1C31002C     MOVS R4, R5
321C  47B84996     LDR R1, [PC, #600]
321E  280047B8     BLX R7
3220  D0042800     CMP R0, #0
3222  2D21D004     BEQ.N 0x322E
3224  D1F22D21     CMP R5, #33
3226  4B94D1F2     BNE.N .LVL90
3228  805C4B94     LDR R3, [PC, #592]
322A  E001805C     STRH R4, [R3, #2]
322C  4B93E001     B.N 0x3232
322E  805C4B93     LDR R3, [PC, #588]
3230  1C30805C     STRH R4, [R3, #2]
210:            {
211:             f32a *= 2.0f;
3202  24024E9A     LDR R6, [PC, #616]
3206  469A4B9A     LDR R3, [PC, #616]
3208  4F9A469A     MOV R10, R3
3210  1C301C31     ADDS R1, R6, #0
3212  47D01C30     ADDS R0, R6, #0
3214  1C0647D0     BLX R10
3216  1C651C06     ADDS R6, R0, #0
3218  B2AD1C65     ADDS R5, R4, #1
321A  4996B2AD     UXTH R5, R5
212:             l11.shr++;
3204  4B9A2402     MOVS R4, #2
213:            }
214:            l11.val = (int16_t)f32a;        /* always positive */
3232  4B921C30     ADDS R0, R6, #0
3234  47984B92     LDR R3, [PC, #584]
3236  B2004798     BLX R3
3238  4B90B200     SXTH R0, R0
323A  80184B90     LDR R3, [PC, #576]
323C  7C38018     STRH R0, [R3]
215:            while((0 == (l11.val & 0x0001)) && (0U < l11.shr))
323E  D41307C3     LSLS R3, R0, #31
3240  4B8ED413     BMI.N 0x326A
3242  885B4B8E     LDR R3, [PC, #568]
3244  2B00885B     LDRH R3, [R3, #2]
3246  D00F2B00     CMP R3, #0
3248  2201D00F     BEQ.N 0x326A
324A  10402201     MOVS R2, #1
3252  D1064202     TST R2, R0
3254  2B00D106     BNE.N 0x3264
3256  D1F82B00     CMP R3, #0
3258  4B88D1F8     BNE.N 0x324C
325A  80184B88     LDR R3, [PC, #544]
325C  22008018     STRH R0, [R3]
325E  805A2200     MOVS R2, #0
3260  E002805A     STRH R2, [R3, #2]
3262  4A85E002     B.N 0x326A
3264  80104A85     LDR R2, [PC, #532]
3266  80538010     STRH R0, [R2]
3268  4D7B8053     STRH R3, [R2, #2]
216:            {
217:             l11.val >>= 1;
324C  3B011040     ASRS R0, R0, #1
218:             l11.shr--;
324E  B29B3B01     SUBS R3, #1
3250  4202B29B     UXTH R3, R3
219:            }
220:           
221:            /* constant coefficients calc (m11) */
222:            f32a = f32_c1_coe * f32_k_volam * OBS_H_GAIN;
326A  4B854D7B     LDR R5, [PC, #492]
326C  68194B85     LDR R3, [PC, #532]
326E  98016819     LDR R1, [R3]
3270  47A89801     LDR R0, [SP, #4]
3272  497947A8     BLX R5
3274  47A84979     LDR R1, [PC, #484]
3276  1C0447A8     BLX R5
3278  22001C04     ADDS R4, R0, #0
223:            m11.shr = 0;
327A  4B822200     MOVS R2, #0
327C  805A4B82     LDR R3, [PC, #520]
327E  2100805A     STRH R2, [R3, #2]
224:            if(f32a >= 0.0f)
3280  4B822100     MOVS R1, #0
3282  47984B82     LDR R3, [PC, #520]
3284  28004798     BLX R3
3286  D0092800     CMP R0, #0
3288  497BD009     BEQ.N 0x329E
225:            {
226:             while((16383.0f > f32a) && ((uint16_t)OBS_MAXSHIFTS > m11.shr))
328A  1C20497B     LDR R1, [PC, #492]
328C  4B791C20     ADDS R0, R4, #0
328E  47984B79     LDR R3, [PC, #484]
3290  26014798     BLX R3
3292  28002601     MOVS R6, #1
3294  D01E2800     CMP R0, #0
3296  4D75D01E     BEQ.N 0x32D6
329A  E00A4F76     LDR R7, [PC, #472]
329C  497CE00A     B.N 0x32B4
32BC  47B8496E     LDR R1, [PC, #440]
32BE  280047B8     BLX R7
32C0  D0062800     CMP R0, #0
32C2  1C73D006     BEQ.N 0x32D2
32C4  B29B1C73     ADDS R3, R6, #1
32C6  2B21B29B     UXTH R3, R3
32C8  D1F22B21     CMP R3, #33
32CA  4B6ED1F2     BNE.N 0x32B2
32CC  805E4B6E     LDR R3, [PC, #440]
32CE  E001805E     STRH R6, [R3, #2]
32D0  4B6DE001     B.N 0x32D6
32D2  805E4B6D     LDR R3, [PC, #436]
32D4  1C20805E     STRH R6, [R3, #2]
227:             {
228:              f32a *= 2.0f;
3298  4F764D75     LDR R5, [PC, #468]
32B4  1C201C21     ADDS R1, R4, #0
32B6  47A81C20     ADDS R0, R4, #0
32B8  1C0447A8     BLX R5
32BA  496E1C04     ADDS R4, R0, #0
229:              m11.shr++;
230:             }
231:            }
232:            else
233:            {
234:             while((-16383.0f < f32a) && ((uint16_t)OBS_MAXSHIFTS > m11.shr))
329E  1C20497C     LDR R1, [PC, #496]
32A0  4B7C1C20     ADDS R0, R4, #0
32A2  47984B7C     LDR R3, [PC, #496]
32A4  26014798     BLX R3
32A6  28002601     MOVS R6, #1
32A8  D0142800     CMP R0, #0
32AA  4D70D014     BEQ.N 0x32D6
32AE  E02B4F79     LDR R7, [PC, #484]
32B0  1EE02B     B.N 0x330A
32B2  1C21001E     MOVS R6, R3
3312  47B8495F     LDR R1, [PC, #380]
3314  280047B8     BLX R7
3316  D0062800     CMP R0, #0
3318  1C73D006     BEQ.N 0x3328
331A  B29B1C73     ADDS R3, R6, #1
331C  2B21B29B     UXTH R3, R3
331E  D1F22B21     CMP R3, #33
3320  4B59D1F2     BNE.N 0x3308
3322  805E4B59     LDR R3, [PC, #356]
3324  E7D6805E     STRH R6, [R3, #2]
3326  4B57E7D6     B.N 0x32D6
3328  805E4B57     LDR R3, [PC, #348]
332A  E7D3805E     STRH R6, [R3, #2]
332C  4A56E7D3     B.N 0x32D6
332E  80104A56     LDR R2, [PC, #344]
3330  80538010     STRH R0, [R2]
3332  4D588053     STRH R3, [R2, #2]
235:             {
236:              f32a *= 2.0f;
32AC  4F794D70     LDR R5, [PC, #448]
330A  1C201C21     ADDS R1, R4, #0
330C  47A81C20     ADDS R0, R4, #0
330E  1C0447A8     BLX R5
3310  495F1C04     ADDS R4, R0, #0
237:              m11.shr++;
238:             }
239:            }
240:            m11.val = (int16_t)f32a;        /* can be negative */
32D6  4B691C20     ADDS R0, R4, #0
32D8  47984B69     LDR R3, [PC, #420]
32DA  B2004798     BLX R3
32DC  4B6AB200     SXTH R0, R0
32DE  80184B6A     LDR R3, [PC, #424]
32E0  7C38018     STRH R0, [R3]
241:            while((0 == (m11.val & 0x0001)) && (0U < m11.shr))
32E2  D42607C3     LSLS R3, R0, #31
32E4  4B68D426     BMI.N .LVL109
32E6  885B4B68     LDR R3, [PC, #416]
32E8  2B00885B     LDRH R3, [R3, #2]
32EA  D0222B00     CMP R3, #0
32EC  2201D022     BEQ.N .LVL109
32EE  10402201     MOVS R2, #1
32F6  D1194202     TST R2, R0
32F8  2B00D119     BNE.N 0x332E
32FA  D1F82B00     CMP R3, #0
32FC  4B62D1F8     BNE.N 0x32F0
32FE  80184B62     LDR R3, [PC, #392]
3300  22008018     STRH R0, [R3]
3302  805A2200     MOVS R2, #0
3304  E015805A     STRH R2, [R3, #2]
3306  1EE015     B.N .LVL109
3308  1C21001E     MOVS R6, R3
242:            {
243:             m11.val >>= 1;
32F0  3B011040     ASRS R0, R0, #1
244:             m11.shr--;
32F2  B29B3B01     SUBS R3, #1
32F4  4202B29B     UXTH R3, R3
245:            }
246:           
247:            /* constant coefficients calc (n11) */
248:            f32a = OBS_H_GAIN;
249:            n11.shr = 0;
250:            while((16383.0f > f32a) && ((uint16_t)OBS_MAXSHIFTS > n11.shr))
333C  E0004E4D     LDR R6, [PC, #308]
333E  27E000     B.N 0x3342
3340  1C290027     MOVS R7, R4
334E  47B0494A     LDR R1, [PC, #296]
3350  280047B0     BLX R6
3352  D0042800     CMP R0, #0
3354  2C21D004     BEQ.N 0x3360
3356  D1F22C21     CMP R4, #33
3358  4B50D1F2     BNE.N .LVL110
335A  805F4B50     LDR R3, [PC, #320]
335C  E001805F     STRH R7, [R3, #2]
335E  4B4EE001     B.N 0x3364
3360  805F4B4E     LDR R3, [PC, #312]
3362  1C28805F     STRH R7, [R3, #2]
251:            {
252:             f32a *= 2.0f;
3334  27024D58     LDR R5, [PC, #352]
3338  46994B4D     LDR R3, [PC, #308]
333A  4E4D4699     MOV R9, R3
3342  1C281C29     ADDS R1, R5, #0
3344  47C81C28     ADDS R0, R5, #0
3346  1C0547C8     BLX R9
3348  1C7C1C05     ADDS R5, R0, #0
334A  B2A41C7C     ADDS R4, R7, #1
334C  494AB2A4     UXTH R4, R4
253:             n11.shr++;
3336  4B4D2702     MOVS R7, #2
254:            }
255:            n11.val = (int16_t)f32a;        /* always positive */
3364  4B461C28     ADDS R0, R5, #0
3366  47984B46     LDR R3, [PC, #280]
3368  B2004798     BLX R3
336A  4B4BB200     SXTH R0, R0
336C  80184B4B     LDR R3, [PC, #300]
336E  7C38018     STRH R0, [R3]
256:            while((0 == (n11.val & 0x0001)) && (0U < n11.shr))
3370  D41307C3     LSLS R3, R0, #31
3372  4B49D413     BMI.N 0x339C
3374  885B4B49     LDR R3, [PC, #292]
3376  2B00885B     LDRH R3, [R3, #2]
3378  D00F2B00     CMP R3, #0
337A  2201D00F     BEQ.N 0x339C
337C  10402201     MOVS R2, #1
3384  D1064202     TST R2, R0
3386  2B00D106     BNE.N 0x3396
3388  D1F82B00     CMP R3, #0
338A  4B43D1F8     BNE.N 0x337E
338C  80184B43     LDR R3, [PC, #268]
338E  22008018     STRH R0, [R3]
3390  805A2200     MOVS R2, #0
3392  E002805A     STRH R2, [R3, #2]
3394  4A41E002     B.N 0x339C
3396  80104A41     LDR R2, [PC, #260]
3398  80538010     STRH R0, [R2]
339A  4B398053     STRH R3, [R2, #2]
257:            {
258:             n11.val >>= 1;
337E  3B011040     ASRS R0, R0, #1
259:             n11.shr--;
3380  B29B3B01     SUBS R3, #1
3382  4202B29B     UXTH R3, R3
260:            }
261:           
262:            /* constant coefficients calc (k11) */
263:            f32a = f32_k_gain * f32_k_volam;
339C  68194B39     LDR R3, [PC, #228]
339E  4B306819     LDR R1, [R3]
33A0  68184B30     LDR R3, [PC, #192]
33A2  4B2C6818     LDR R0, [R3]
33A4  47984B2C     LDR R3, $d
33A6  1C044798     BLX R3
33A8  22001C04     ADDS R4, R0, #0
264:            k11.shr = 0;
33AA  4B3C2200     MOVS R2, #0
33AC  805A4B3C     LDR R3, [PC, #240]
33AE  4931805A     STRH R2, [R3, #2]
265:            while((16383.0f > f32a) && ((uint16_t)OBS_MAXSHIFTS > k11.shr))
33B0  4B304931     LDR R1, [PC, #196]
33B2  47984B30     LDR R3, [PC, #192]
33B4  26014798     BLX R3
33B6  28002601     MOVS R6, #1
33B8  D0142800     CMP R0, #0
33BA  4D2CD014     BEQ.N 0x33E6
33BE  E0004F2D     LDR R7, [PC, #180]
33C0  1EE000     B.N 0x33C4
33C2  1C21001E     MOVS R6, R3
33CC  47B8492A     LDR R1, [PC, #168]
33CE  280047B8     BLX R7
33D0  D0062800     CMP R0, #0
33D2  1C73D006     BEQ.N 0x33E2
33D4  B29B1C73     ADDS R3, R6, #1
33D6  2B21B29B     UXTH R3, R3
33D8  D1F22B21     CMP R3, #33
33DA  4B30D1F2     BNE.N 0x33C2
33DC  805E4B30     LDR R3, [PC, #192]
33DE  E001805E     STRH R6, [R3, #2]
33E0  4B2FE001     B.N 0x33E6
33E2  805E4B2F     LDR R3, [PC, #188]
33E4  1C20805E     STRH R6, [R3, #2]
266:            {
267:             f32a *= 2.0f;
33BC  4F2D4D2C     LDR R5, [PC, #176]
33C4  1C201C21     ADDS R1, R4, #0
33C6  47A81C20     ADDS R0, R4, #0
33C8  1C0447A8     BLX R5
33CA  492A1C04     ADDS R4, R0, #0
268:             k11.shr++;
269:            }
270:            k11.val = (int16_t)f32a;        /* always positive */
33E6  4B251C20     ADDS R0, R4, #0
33E8  47984B25     LDR R3, [PC, #148]
33EA  B2004798     BLX R3
33EC  4B2CB200     SXTH R0, R0
33EE  80184B2C     LDR R3, [PC, #176]
33F0  7C38018     STRH R0, [R3]
271:            while((0 == (k11.val & 0x0001)) && (0U < k11.shr))
33F2  D41307C3     LSLS R3, R0, #31
33F4  4B2AD413     BMI.N 0x341E
33F6  885B4B2A     LDR R3, [PC, #168]
33F8  2B00885B     LDRH R3, [R3, #2]
33FA  D00F2B00     CMP R3, #0
33FC  2201D00F     BEQ.N 0x341E
33FE  10402201     MOVS R2, #1
3406  D1064202     TST R2, R0
3408  2B00D106     BNE.N 0x3418
340A  D1F82B00     CMP R3, #0
340C  4B24D1F8     BNE.N 0x3400
340E  80184B24     LDR R3, [PC, #144]
3410  22008018     STRH R0, [R3]
3412  805A2200     MOVS R2, #0
3414  E002805A     STRH R2, [R3, #2]
3416  4A21E002     B.N 0x341E
3418  80104A21     LDR R2, [PC, #132]
341A  80538010     STRH R0, [R2]
341C  4B218053     STRH R3, [R2, #2]
272:            {
273:             k11.val >>= 1;
3400  3B011040     ASRS R0, R0, #1
274:             k11.shr--;
3402  B29B3B01     SUBS R3, #1
3404  4202B29B     UXTH R3, R3
275:            }
276:           
277:            #ifdef  CROSS_COUPLING_ENABLED
278:           
279:            /* intermediate constant (useful in variable coefficients calc) (hhh) */
280:            f32a = f32_c1_coe * f32_k_volam;
281:            hhh.shr = 0;
282:            if(f32a >= 0.0f)
283:            {
284:             while((16383.0f > f32a) && ((uint16_t)OBS_MAXSHIFTS > hhh.shr))
285:             {
286:              f32a *= 2.0f;
287:              hhh.shr++;
288:             }
289:            }
290:            else
291:            {
292:             while((-16383.0f < f32a) && ((uint16_t)OBS_MAXSHIFTS > hhh.shr))
293:             {
294:              f32a *= 2.0f;
295:              hhh.shr++;
296:             }
297:            }
298:            hhh.val = (int16_t)f32a;        /* can be negative */
299:            while((0 == (hhh.val & 0x0001)) && (0 < hhh.shr))
300:            {
301:             hhh.val >>= 1;
302:             hhh.shr--;
303:            }
304:           
305:            /* intermediate constant (useful in variable coefficients calc) (lll) */
306:            f32a = f32_syn_ind * f32_k_volam / f32_k_speed;
307:            lll.shr = 0;
308:            while((16383.0f > f32a) && ((uint16_t)OBS_MAXSHIFTS > lll.shr))
309:            {
310:             f32a *= 2.0f;
311:             lll.shr++;
312:            }
313:            lll.val = (int16_t)f32a; /* always positive */
314:            while((0 == (lll.val & 0x0001)) && (0 < lll.shr))
315:            {
316:             lll.val >>= 1;
317:             lll.shr--;
318:            }
319:           
320:            /* intermediate constant (useful in variable coefficients calc) (xxx) */
321:            f32a = (1.0f / (f32_sam_fre * f32_k_speed));
322:            xxx.shr = 0;
323:            while((16383.0f > f32a) && ((uint16_t)OBS_MAXSHIFTS > xxx.shr))
324:            {
325:             f32a *= 2.0f;
326:             xxx.shr++;
327:            }
328:            xxx.val = (int16_t)f32a; /* always positive */
329:            while((0 == (xxx.val & 0x0001)) && (0 < xxx.shr))
330:            {
331:             xxx.val >>= 1;
332:             xxx.shr--;
333:            }
334:           
335:            /* variable coefficients init (NOT NEEDED)
336:            obs_coef_calc(speed_min); */
337:           
338:            #endif  // ifdef CROSS_COUPLING_ENABLED
339:           
340:            /* observer status init */
341:            obs_z.x = 0;
341E  24004B21     LDR R3, [PC, #132]
3420  801C2400     MOVS R4, #0
3422  805C801C     STRH R4, [R3]
342:            obs_z.y = 0;
3424  4B20805C     STRH R4, [R3, #2]
343:           
344:            /* speed estimation init */
345:            #ifdef PH_CLAMP
346:            max_dspeed = MAX_DSPEED;
347:            #endif 
348:            speed_filter_init(speed_min);
3426  20004B20     LDR R3, [PC, #128]
3428  5E182000     MOVS R0, #0
342A  4B1F5E18     LDRSH R0, [R3, R0]
342C  47984B1F     LDR R3, [PC, #124]
342E  4B1F4798     BLX R3
349:           
350:            /* other internal variables init */
351:            flx_arg_mem = 0;
3430  801C4B1F     LDR R3, [PC, #124]
3432  4B1F801C     STRH R4, [R3]
352:            flx_arg = 0;
3434  801C4B1F     LDR R3, [PC, #124]
3436  4B1F801C     STRH R4, [R3]
353:            obs_e.x = 0;
3438  801C4B1F     LDR R3, [PC, #124]
343A  805C801C     STRH R4, [R3]
354:            obs_e.y = 0;
343C  4B1F805C     STRH R4, [R3, #2]
355:            bemf.r = 0;
343E  801C4B1F     LDR R3, [PC, #124]
3440  805C801C     STRH R4, [R3]
356:            bemf.t.ang = 0;
3442  809C805C     STRH R4, [R3, #2]
357:            bemf.t.sin = 0;
3444  2280809C     STRH R4, [R3, #4]
358:            bemf.t.cos = (int16_t)BASE_VALUE_INT;
3446  1D22280     MOVS R2, #128
3448  80DA01D2     LSLS R2, R2, #7
344A  B00380DA     STRH R2, [R3, #6]
359:            #ifdef  CROSS_COUPLING_ENABLED
360:            debug_cnt1 = 0;
361:            debug_cnt2 = 0;
362:            #endif
363:            /*lint -restore*/
364:           }
344C  BC0CB003     ADD SP, #12
344E  4691BC0C     POP {R2, R3}
3450  469A4691     MOV R9, R2
3452  BDF0469A     MOV R10, R3
3454  46C0BDF0     POP {R4, R5, R6, R7, PC}
3456  375146C0     MOV R8, R8
3458  3751     ADDS R7, #81
345A  CCCD0000     MOVS R0, R0
345C  3E4CCCCD     LDMIA R4!, {R0, R2, R3, R6, R7}
345E  28D03E4C     SUBS R6, #76
3460  200028D0     CMP R0, #208
3462  28C82000     MOVS R0, #0
3464  200028C8     CMP R0, #200
3466  256D2000     MOVS R0, #0
3468  256D     MOVS R5, #109
346A  CCCD0000     MOVS R0, R0
346C  3FCCCCCD     LDMIA R4!, {R0, R2, R3, R6, R7}
346E  28A53FCC     SUBS R7, #204
3470  28A5     CMP R0, #165
3472  57110000     MOVS R0, R0
3474  5711     LDRSB R1, [R2, R4]
3476  FC000000     MOVS R0, R0
3478  467FFC00     
347A  28D8467F     MOV R7, PC
347C  200028D8     CMP R0, #216
347E  5DD12000     MOVS R0, #0
3480  5DD1     LDRB R1, [R2, R7]
3482  28CC0000     MOVS R0, R0
3484  200028CC     CMP R0, #204
3486  28DC2000     MOVS R0, #0
3488  200028DC     CMP R0, #220
348A  574D2000     MOVS R0, #0
348C  574D     LDRSB R5, [R1, R5]
348E  FC000000     MOVS R0, R0
3490  C67FFC00     
3492  5739C67F     STMIA R6!, {R0, R1, R2, R3, R4, R5, R6}
3494  5739     LDRSB R1, [R7, R4]
3496  CCCD0000     MOVS R0, R0
3498  3ECCCCCD     LDMIA R4!, {R0, R2, R3, R6, R7}
349A  28E03ECC     SUBS R6, #204
349C  200028E0     CMP R0, #224
349E  28D42000     MOVS R0, #0
34A0  200028D4     CMP R0, #212
34A2  28E82000     MOVS R0, #0
34A4  200028E8     CMP R0, #232
34A6  29382000     MOVS R0, #0
34A8  20002938     CMP R1, #56
34AA  512D2000     MOVS R0, #0
34AC  512D     STR R5, [R5, R4]
34AE  292E0000     MOVS R0, R0
34B0  2000292E     CMP R1, #46
34B2  292C2000     MOVS R0, #0
34B4  2000292C     CMP R1, #44
34B6  28E42000     MOVS R0, #0
34B8  200028E4     CMP R0, #228
34BA  28502000     MOVS R0, #0
34BC  20002850     CMP R0, #80
34BE  B5F02000     MOVS R0, #0
365:           
366:           /******************************************************************************
367:           Function:  obs_coef_calc
368:           Description: Luenberger observer coefficients calculation
369:           Input:   reference speed (only to get its sign)
370:           Output:   nothing
371:           Modifies:  observer variable coefficients
372:           ******************************************************************************/
373:           void obs_coef_calc(int16_t spref)
374:           {
375:            #ifdef  CROSS_COUPLING_ENABLED
376:            int32_t s32a;
377:            int16_t spabs;
378:            #endif /* ifdef CROSS_COUPLING_ENABLED */
379:           
380:            /* sign management */
381:            if(0 > spref)
6358  DB032800     CMP R0, #0
635A  2201DB03     BLT.N 0x6364
382:            {
383:             speed_sgn = -1;
6364  42522201     MOVS R2, #1
384:            }
385:            else
386:            {
387:             speed_sgn = 1;
635C  4B042201     MOVS R2, #1
635E  801A4B04     LDR R3, [PC, #16]
6360  4770801A     STRH R2, [R3]
388:            }
389:           
390:            #ifdef  CROSS_COUPLING_ENABLED
391:           
392:            /* speed clamp */
393:               /*lint -save -e9027 */
394:               /* 10.1 violation */
395:            if(speed_min > speed_abs)
396:            {
397:             spabs = speed_min;
398:            }
399:            else
400:            {
401:             spabs = speed_abs;
402:            }
403:           
404:            /* variable coefficient (n21) (xxx.val is positive) */
405:            s32a = ((int32_t)(xxx.val)) * ((int32_t)spabs);
406:            n21.shr = xxx.shr;
407:            while((32767 < s32a) || (OBS_MAXSHIFTS < n21.shr))
408:            {
409:             s32a >>= 1;
410:             n21.shr--;   // if negative algo. will fail
411:            }
412:            n21.val = (int16_t)s32a;
413:            while((0 == (n21.val & 0x0001)) && (0 < n21.shr))
414:            {
415:             n21.val >>= 1;
416:             n21.shr--;
417:            }
418:           
419:            /* variable coefficient (m21) (hhh.val can be negative) */
420:            s32a = ((int32_t)(hhh.val)) * ((int32_t)(n21.val));
421:            m21.shr = n21.shr + hhh.shr;
422:            while(((32767 < s32a) || (-32767 > s32a)) || (OBS_MAXSHIFTS < m21.shr))
423:            {
424:             s32a >>= 1;
425:             m21.shr--;   // if negative algo. will fail
426:            }
427:            m21.val = (int16_t)s32a;
428:            while((0 == (m21.val & 0x0001)) && (0 < m21.shr))
429:            {
430:             m21.val >>= 1;
431:             m21.shr--;
432:            }
433:           
434:            /* variable coefficient (k21) (lll.val is positive) */
435:            s32a = ((int32_t)(lll.val)) * ((int32_t)spabs);
436:            k21.shr = lll.shr;
437:            while((32767 < s32a) || (OBS_MAXSHIFTS < k21.shr))
438:            {
439:             s32a >>= 1;
440:             k21.shr--;   /* if negative algo. will fail */
441:            }
442:            k21.val = (int16_t)s32a;
443:            while((0 == (k21.val & 0x0001)) && (0 < k21.shr))
444:            {
445:             k21.val >>= 1;
446:             k21.shr--;
447:            }
448:           
449:            /* coefficients sign management */
450:            if(0 > speed_sgn)
451:            {
452:             n21.val = -n21.val;
453:             m21.val = -m21.val;
454:             k21.val = -k21.val;
455:            }
456:            /*lint -restore */
457:           
458:            #endif  /* ifdef CROSS_COUPLING_ENABLED */
459:           
460:           }
6362  22014770     BX LR
6364  42522201     MOVS R2, #1
6366  4B014252     RSBS R2, R2, #0
6368  801A4B01     LDR R3, $d
636A  E7F9801A     STRH R2, [R3]
636C  46C0E7F9     B.N 0x6362
636E  293A46C0     MOV R8, R8
6370  2000293A     CMP R1, #58
6372  4A052000     MOVS R0, #0
461:           
462:           /*******************************************************************************
463:           Function:  shfdw1
464:           Description: arithmetic shift down, which goes to zero also with negative
465:               numbers
466:           Input:   number to be shifted (a), number of shifts (s)
467:           Output:   a >> s
468:           Note:   symmetric behaviour, unlike the assembly instruction
469:           *******************************************************************************/
470:           int32_t shfdw1(int32_t a, uint16_t s)
471:           {
472:            /* shift operation on signed numbers is required.
473:               optimization is higher in this case.
474:               compiler ensures it places with an arithmetic shift */
475:           
476:            /*lint -save -e9027 */
477:            int32_t r;
478:           
479:            if(0 > a)
0004  596D     LDR R5, [R5, R5]
480:            {
481:             r = -((-a) >> s);
000C  653F     STR R7, [R7, #80]
482:            }
483:            else
484:            {
485:             r = a >> s;
0000  20007FF8     LDRB R0, [R7, #31]
486:            }
487:            /*lint -restore */
488:            return (r);
489:           }
0008  653D     STR R5, [R7, #80]
490:           
491:           /*******************************************************************************
492:           Function:  shfdw2
493:           Description: arithmetic shift down, which goes to zero also with negative
494:               numbers, but keeps output >=1 (<=-1) if the input is >1 (<-1)
495:           Input:   number to be shifted (a), number of shifts (s)
496:           Output:   a >> s
497:           Note:   useful to reset the filters memories
498:           *******************************************************************************/
499:           int32_t shfdw2(int32_t a, uint16_t s)
500:           {
501:            int32_t r;
502:           
503:            if((-2 < a) && (2 > a))
0000  20007FF8     LDRB R0, [R7, #31]
0004  596D     LDR R5, [R5, R5]
504:            {
505:              r = 0;
0002  596D2000     MOVS R0, #0
506:            }
507:            else
508:            {
509:              /*lint -save -e9027 */
510:              r = a >> s;
0008  653D     STR R5, [R7, #80]
511:              /*lint -restore */
512:              if(0 == r)
000C  653F     STR R7, [R7, #80]
513:              {
514:               r = 1;
000E  0000     MOVS R0, R0
515:              }
516:            }
517:            return (r);
518:           }
0010  0000     MOVS R0, R0
519:           
520:           /*******************************************************************************
521:           Function:  mulshr
522:           Description: multiplication and shift down of a number by a coef_t
523:           Input:   number to be multiplied and shifted (a), coefficient address (c)
524:           Output:   result of multiply and shift operation
525:           *******************************************************************************/
526:           static inline int32_t mulshr(int16_t a, const coef_t *c)
527:           {
528:            int32_t r;
529:           
530:            r = ((int32_t)a) * ((int32_t)(c->val));
470C  20004A2F     LDR R2, $d
470E  5E132000     MOVS R0, #0
4710  4F2F5E13     LDRSH R3, [R2, R0]
4714  5F382400     MOVS R4, #0
4716  93015F38     LDRSH R0, [R7, R4]
4718  43589301     STR R3, [SP, #4]
471A  88564358     MULS R0, R3
4724  22004D2C     LDR R5, [PC, #176]
4742  22004827     LDR R0, [PC, #156]
475A  5EFA2302     MOVS R3, #2
476A  5E8B2202     MOVS R2, #2
477E  26024662     MOV R2, R12
4792  20004D18     LDR R5, [PC, #96]
47A6  5F892602     MOVS R6, #2
47A8  434A5F89     LDRSH R1, [R1, R6]
47AA  412A434A     MULS R2, R1
531:           
532:            /*lint -save -e9027 */
533:            r >>= (c->shr);
471C  41308856     LDRH R6, [R2, #2]
471E  4A2C4130     ASRS R0, R6
4734  46A8886D     LDRH R5, [R5, #2]
4750  41048840     LDRH R0, [R0, #2]
4762  1E4133     ASRS R3, R6
4774  41134642     MOV R2, R8
4786  48194102     ASRS R2, R0
479E  4128886D     LDRH R5, [R5, #2]
47AC  4913412A     ASRS R2, R5
534:            /*lint -restore*/
535:           
536:            return (r);
537:           }
538:           
539:           /******************************************************************************
540:           Function:  lunberger_observer
541:           Description: bemf reduced order observer implementation
542:           Input:   voltage and current vectors in the static reference frame
543:           Output:   nothing
544:           Modifies:  observer status and estimated bemf vectors
545:           ******************************************************************************/
546:           void lunberger_observer(const vec2_t *v, const vec2_t *i)
547:           {
46FC  46DEB5F0     PUSH {R4, R5, R6, R7, LR}
46FE  465746DE     MOV LR, R11
4700  464E4657     MOV R7, R10
4702  4645464E     MOV R6, R9
4704  B5E04645     MOV R5, R8
4706  B083B5E0     PUSH {R5, R6, R7, LR}
4708  4684B083     SUB SP, #12
470A  4A2F4684     MOV R12, R0
548:            int32_t s32x, s32y;
549:            #ifdef AMP_CLAMP
550:            int32_t luzx, luzy;
551:            #endif 
552:           
553:            s32x =  lzx = mulshr(obs_z.x, &l11);
4712  24004F2F     LDR R7, [PC, #188]
4720  60104A2C     LDR R2, [PC, #176]
4722  4D2C6010     STR R0, [R2]
554:            s32x += mix = mulshr((i->x), &m11);
473A  602C4D28     LDR R5, [PC, #160]
473C  46A1602C     STR R4, [R5]
473E  448146A1     MOV R9, R4
4740  48274481     ADD R9, R0
555:            #ifdef  CROSS_COUPLING_ENABLED
556:            s32x -= mulshr((i->y), &m21); /* m12 = -m21 */
557:            #endif  // ifdef CROSS_COUPLING_ENABLED
558:            s32x += nvx = mulshr((v->x), &n11);
4754  60144A23     LDR R2, [PC, #140]
4756  444C6014     STR R4, [R2]
4758  2302444C     ADD R4, R9
559:            #ifdef  CROSS_COUPLING_ENABLED
560:            s32x -= mulshr((v->y), &n21); /* n12 = -n21 */
561:            #endif  // ifdef CROSS_COUPLING_ENABLED
562:           
563:            s32y = lzy = mulshr(obs_z.y, &l11); /* l22 = l11 */
4766  601E4B20     LDR R3, [PC, #128]
4768  2202601E     STR R6, [R3]
564:            #ifdef  CROSS_COUPLING_ENABLED
565:            s32y += mulshr((i->x), &m21);
566:            #endif  // ifdef CROSS_COUPLING_ENABLED
567:            s32y += miy = mulshr((i->y), &m11); /* m22 = m11 */
4778  60134A1C     LDR R2, [PC, #112]
477A  199B6013     STR R3, [R2]
477C  4662199B     ADDS R3, R3, R6
568:            #ifdef  CROSS_COUPLING_ENABLED
569:            s32y += mulshr((v->x), &n21);
570:            #endif  // ifdef CROSS_COUPLING_ENABLED
571:            s32y += nvy = mulshr((v->y), &n11); /* n22 = n11 */
4788  60024819     LDR R0, [PC, #100]
478A  189B6002     STR R2, [R0]
478C  803C189B     ADDS R3, R3, R2
572:           
573:            #ifdef AMP_CLAMP
574:            /* during startup transitory from zero speed, observer status could diverge;
575:               this clamping keeps the vector amplitude clamped, without changing its argument */
576:            luzx = s32x;
577:            luzy = s32y;
578:            while((-32767 > luzx) || (32767 < luzx) || (-32767 > luzy) || (32767 < luzy))
579:            {
580:             luzx = shfdw1(luzx, 1);
581:             luzy = shfdw1(luzy, 1);
582:             debug_cnt1++;
583:            }
584:            obs_z.x = (int16_t)luzx;
585:            obs_z.y = (int16_t)luzy;
586:            #else /* ifdef AMP_CLAMP */
587:            obs_z.x = (int16_t)s32x;
478E  807B803C     STRH R4, [R7]
588:            obs_z.y = (int16_t)s32y;
4790  4D18807B     STRH R3, [R7, #2]
589:            #endif /* ifdef AMP_CLAMP */
590:           
591:            s32x -= kix = mulshr((i->x), &k11);
47A2  60304E15     LDR R6, [PC, #84]
47A4  26026030     STR R0, [R6]
47B4  800C1A24     SUBS R4, R4, R0
592:            #ifdef  CROSS_COUPLING_ENABLED
593:            s32x += mulshr((i->y), &k21); /* k12 = -k21 */
594:            #endif  // ifdef CROSS_COUPLING_ENABLED
595:           
596:            #ifdef  CROSS_COUPLING_ENABLED
597:            s32y -= mulshr((i->x), &k21);
598:            #endif  // ifdef CROSS_COUPLING_ENABLED
599:            s32y -= kiy = mulshr((i->y), &k11); /* k22 = k11 */
47AE  600A4913     LDR R1, [PC, #76]
47B0  4913600A     STR R2, [R1]
47B8  804B1A9B     SUBS R3, R3, R2
600:           
601:            #ifdef AMP_CLAMP
602:            while((-32767 > s32x) || (32767 < s32x) || (-32767 > s32y) || (32767 < s32y))
603:            {
604:             s32x = shfdw1(s32x, 1);
605:             s32y = shfdw1(s32y, 1);
606:             debug_cnt2++;
607:            }
608:            #endif // ifdef AMP_CLAMP
609:           
610:            obs_e.x = (int16_t)s32x;
47B2  1A244913     LDR R1, [PC, #76]
47B6  1A9B800C     STRH R4, [R1]
611:            obs_e.y = (int16_t)s32y;
47BA  B003804B     STRH R3, [R1, #2]
612:           
613:           }
47BC  BC3CB003     ADD SP, #12
47BE  4690BC3C     POP {R2, R3, R4, R5}
47C0  46994690     MOV R8, R2
47C2  46A24699     MOV R9, R3
47C4  46AB46A2     MOV R10, R4
47C6  BDF046AB     MOV R11, R5
47C8  46C0BDF0     POP {R4, R5, R6, R7, PC}
47CA  28D846C0     MOV R8, R8
47CC  200028D8     CMP R0, #216
47CE  28E82000     MOVS R0, #0
47D0  200028E8     CMP R0, #232
47D2  1602000     MOVS R0, #0
47D4  20000160     LSLS R0, R4, #5
47D6  28DC2000     MOVS R0, #0
47D8  200028DC     CMP R0, #220
47DA  1802000     MOVS R0, #0
47DC  20000180     LSLS R0, R0, #6
47DE  28E02000     MOVS R0, #0
47E0  200028E0     CMP R0, #224
47E2  1742000     MOVS R0, #0
47E4  20000174     LSLS R4, R6, #5
47E6  16C2000     MOVS R0, #0
47E8  2000016C     LSLS R4, R5, #5
47EA  1682000     MOVS R0, #0
47EC  20000168     LSLS R0, R5, #5
47EE  17C2000     MOVS R0, #0
47F0  2000017C     LSLS R4, R7, #5
47F2  28D42000     MOVS R0, #0
47F4  200028D4     CMP R0, #212
47F6  1782000     MOVS R0, #0
47F8  20000178     LSLS R0, R7, #5
47FA  1642000     MOVS R0, #0
47FC  20000164     LSLS R4, R4, #5
47FE  28E42000     MOVS R0, #0
4800  200028E4     CMP R0, #228
4802  B5F02000     MOVS R0, #0
614:           
615:           /*******************************************************************************
616:           Function:  phase_estimation
617:           Description: estimation of rotor position using bemf vector
618:           Input:   nothing (uses global variable bemf vector)
619:           Output:   nothing (modifies global variable flx_arg)
620:           *******************************************************************************/
621:           void phase_estimation(void)
622:           {
57D4  4915B510     PUSH {R4, LR}
623:            uint16_t u16a;
624:            #ifdef PH_CLAMP
625:            uint16_t u16b;
626:            uint16_t u16c;
627:            #endif /* ifdef PH_CLAMP */
628:           
629:            #ifdef PH_CLAMP
630:            /* phase variation limits calculation */
631:            u16a = dph_abs_fil >> 1;
632:            if(max_dspeed < u16a)
633:            {
634:             u16b = dph_abs_fil - max_dspeed;
635:             u16c = dph_abs_fil + max_dspeed;
636:            }
637:            else
638:            {
639:             u16b = dph_abs_fil - u16a;
640:             u16c = dph_abs_fil + u16a;
641:            }
642:            #endif /* ifdef PH_CLAMP */
643:           
644:            library_xy_rt(&obs_e, &bemf);  /* extract angular position */
57D6  48154915     LDR R1, [PC, #84]
57D8  4B164815     LDR R0, [PC, #84]
57DA  47984B16     LDR R3, [PC, #88]
57DC  4B164798     BLX R3
645:            if(0 > speed_sgn)
57DE  22004B16     LDR R3, [PC, #88]
57E0  5E9B2200     MOVS R2, #0
57E2  2B005E9B     LDRSH R3, [R3, R2]
57E4  DB102B00     CMP R3, #0
57E6  4B10DB10     BLT.N .LVL65
646:            {
647:             u16a = bemf.t.ang + PIHALVES; /* overflow is OK here */
580A  885B4B08     LDR R3, [PC, #32]
580C  2280885B     LDRH R3, [R3, #2]
580E  1D22280     MOVS R2, #128
5810  469401D2     LSLS R2, R2, #7
5812  44634694     MOV R12, R2
5814  B29B4463     ADD R3, R12
5816  4A09B29B     UXTH R3, R3
648:             #ifndef PH_CLAMP
649:             if((flx_arg - u16a) > (uint16_t)PI)
5818  88124A09     LDR R2, [PC, #36]
581A  1AD08812     LDRH R2, [R2]
581C  21801AD0     SUBS R0, R2, R3
581E  2092180     MOVS R1, #128
5820  42880209     LSLS R1, R1, #8
5822  DDEE4288     CMP R0, R1
5824  13DDEE     BLE.N 0x5804
650:             {
651:              u16a = flx_arg;             /* cannot increase */
5826  E7EC0013     MOVS R3, R2
652:             }
653:             #else   /* ifndef PH_CLAMP */
654:             u16b = flx_arg - u16b;   /* overflow is OK here */
655:             u16c = flx_arg - u16c;   /* overflow is OK here */
656:             if(((uint16_t)(u16b - u16a)) > PI)
657:             {
658:              u16a = u16b;
659:             }
660:             else if((u16a - u16c) > (uint16_t)PI)
661:             {
662:              u16a = u16c;
663:             }
664:             #endif
665:            }
666:            else
667:            {
668:             u16a = bemf.t.ang - PIHALVES; /* overflow is OK here */
57E8  885B4B10     LDR R3, $d
57EA  4A13885B     LDRH R3, [R3, #2]
57EC  46944A13     LDR R2, [PC, #76]
57EE  44634694     MOV R12, R2
57F0  B29B4463     ADD R3, R12
57F2  4A12B29B     UXTH R3, R3
669:             #ifndef PH_CLAMP
670:             if((u16a - flx_arg) > (uint16_t)PI)
57F4  88124A12     LDR R2, [PC, #72]
57F6  1A988812     LDRH R2, [R2]
57F8  21801A98     SUBS R0, R3, R2
57FA  2092180     MOVS R1, #128
57FC  42880209     LSLS R1, R1, #8
57FE  DD004288     CMP R0, R1
5800  13DD00     BLE.N 0x5804
671:             {
672:              u16a = flx_arg;             /* cannot decrease */
5802  4A0E0013     MOVS R3, R2
673:             }
674:             #else   /* ifndef PH_CLAMP */
675:             u16b = flx_arg + u16b;   /* overflow is OK here */
676:             u16c = flx_arg + u16c;   /* overflow is OK here */
677:             if((u16a - u16b) > (uint16_t)PI)
678:             {
679:              u16a = u16b;
680:             }
681:             else if((u16c - u16a) > (uint16_t)PI)
682:             {
683:              u16a = u16c;
684:             }
685:             #endif /* ifdef PH_CLAMP */
686:            }
687:            flx_arg = u16a;
5804  80134A0E     LDR R2, [PC, #56]
5806  BD108013     STRH R3, [R2]
688:           }
5808  4B08BD10     POP {R4, PC}
580A  885B4B08     LDR R3, [PC, #32]
580C  2280885B     LDRH R3, [R3, #2]
580E  1D22280     MOVS R2, #128
5810  469401D2     LSLS R2, R2, #7
5812  44634694     MOV R12, R2
5814  B29B4463     ADD R3, R12
5816  4A09B29B     UXTH R3, R3
5818  88124A09     LDR R2, [PC, #36]
581A  1AD08812     LDRH R2, [R2]
581C  21801AD0     SUBS R0, R2, R3
581E  2092180     MOVS R1, #128
5820  42880209     LSLS R1, R1, #8
5822  DDEE4288     CMP R0, R1
5824  13DDEE     BLE.N 0x5804
5826  E7EC0013     MOVS R3, R2
5828  46C0E7EC     B.N 0x5804
582A  285046C0     MOV R8, R8
582C  20002850     CMP R0, #80
582E  28E42000     MOVS R0, #0
5830  200028E4     CMP R0, #228
5832  58452000     MOVS R0, #0
5834  5845     LDR R5, [R0, R1]
5836  293A0000     MOVS R0, R0
5838  2000293A     CMP R1, #58
583A  C0002000     MOVS R0, #0
583C  FFFFC000     STMIA R0!, {}
583E  292CFFFF     CDP2 P9, #15, CR2, CR15, CR12, {1}
5840  2000292C     CMP R1, #44
5842  B5702000     MOVS R0, #0
689:           
690:           /*******************************************************************************
691:           Function:  phase_estimation_init
692:           Description: init routine for use of phase estimation
693:           Input:   nothing (uses global variable bemf vector)
694:           Output:   nothing (modifies global variable flx_arg)
695:           *******************************************************************************/
696:           void phase_estimation_init(void)
697:           {
5A28  490DB510     PUSH {R4, LR}
698:            library_xy_rt(&obs_e, &bemf);
5A2A  480D490D     LDR R1, [PC, #52]
5A2C  4B0E480D     LDR R0, [PC, #52]
5A2E  47984B0E     LDR R3, [PC, #56]
5A30  4B0E4798     BLX R3
699:            if(0 > speed_sgn)
5A32  22004B0E     LDR R3, [PC, #56]
5A34  5E9B2200     MOVS R2, #0
5A36  2B005E9B     LDRSH R3, [R3, R2]
5A38  DB072B00     CMP R3, #0
5A3A  4B08DB07     BLT.N 0x5A4C
700:            {
701:             flx_arg = bemf.t.ang + PIHALVES; /* overflow is OK here */
5A4C  885B4B04     LDR R3, $d
702:            }
703:            else
704:            {
705:             flx_arg = bemf.t.ang - PIHALVES; /* overflow is OK here */
5A3C  885B4B08     LDR R3, $d
5A3E  4A0B885B     LDRH R3, [R3, #2]
5A40  46944A0B     LDR R2, [PC, #44]
5A42  44634694     MOV R12, R2
5A44  4A0B4463     ADD R3, R12
5A46  80134A0B     LDR R2, [PC, #44]
5A48  BD108013     STRH R3, [R2]
706:            }
707:           }
5A4A  4B04BD10     POP {R4, PC}
5A4C  885B4B04     LDR R3, $d
5A4E  2280885B     LDRH R3, [R3, #2]
5A50  1D22280     MOVS R2, #128
5A52  469401D2     LSLS R2, R2, #7
5A54  44634694     MOV R12, R2
5A56  4A064463     ADD R3, R12
5A58  80134A06     LDR R2, [PC, #24]
5A5A  E7F58013     STRH R3, [R2]
5A5C  46C0E7F5     B.N 0x5A4A
5A5E  285046C0     MOV R8, R8
5A60  20002850     CMP R0, #80
5A62  28E42000     MOVS R0, #0
5A64  200028E4     CMP R0, #228
5A66  58452000     MOVS R0, #0
5A68  5845     LDR R5, [R0, R1]
5A6A  293A0000     MOVS R0, R0
5A6C  2000293A     CMP R1, #58
5A6E  C0002000     MOVS R0, #0
5A70  FFFFC000     STMIA R0!, {}
5A72  292CFFFF     CDP2 P9, #15, CR2, CR15, CR12, {1}
5A74  2000292C     CMP R1, #44
5A76  22012000     MOVS R0, #0
708:           
709:           /*******************************************************************************
710:           Function:  speed_filter
711:           Description: speed estimation, using a fourth order low-pass filter
712:           Input:   nothing (uses delta position in one step)
713:           Output:   nothing (modifies global variable speed_est)
714:           *******************************************************************************/
715:           void speed_filter(void)
716:           {
4804  46C6B5F0     PUSH {R4, R5, R6, R7, LR}
4806  B50046C6     MOV LR, R8
4808  4B2BB500     PUSH {LR}
717:            int16_t dph;
718:           
719:            /* sign management and delta ang clamp */
720:            if(0 > speed_sgn)
480A  24004B2B     LDR R3, [PC, #172]
480C  5F1C2400     MOVS R4, #0
480E  2C005F1C     LDRSH R4, [R3, R4]
4810  DB422C00     CMP R4, #0
4812  4B29DB42     BLT.N 0x479A
721:            {
722:             dph = (int16_t)flx_arg_mem - (int16_t)flx_arg;
489A  881B4B09     LDR R3, [PC, #36]
489C  4A07881B     LDRH R3, [R3]
489E  88124A07     LDR R2, [PC, #28]
48A0  1A9B8812     LDRH R2, [R2]
48A2  B21B1A9B     SUBS R3, R3, R2
48A4  E7BBB21B     SXTH R3, R3
48A6  4B11E7BB     B.N .LVL69
723:            }
724:            else
725:            {
726:            dph = (int16_t)flx_arg - (int16_t)flx_arg_mem;
4814  881B4B29     LDR R3, [PC, #164]
4816  4A29881B     LDRH R3, [R3]
4818  88124A29     LDR R2, [PC, #164]
481A  1A9B8812     LDRH R2, [R2]
481C  B21B1A9B     SUBS R3, R3, R2
481E  4A26B21B     SXTH R3, R3
727:            }
728:            flx_arg_mem = flx_arg;
4820  88114A26     LDR R2, [PC, #152]
4822  4A268811     LDRH R1, [R2]
4824  80114A26     LDR R2, [PC, #152]
4826  2B008011     STRH R1, [R2]
729:            if(1 > dph)
4828  DD3D2B00     CMP R3, #0
482A  4A25DD3D     BLE.N 0x48A8
730:            {
731:             //dph = 1;
732:             dph = dph_min;
48A8  22004B11     LDR R3, [PC, #68]
48AA  5E9B2200     MOVS R2, #0
48AC  E7BD5E9B     LDRSH R3, [R3, R2]
48AE  4240E7BD     B.N 0x482C
733:            }
734:             dph_global = dph;
482C  80134A25     LDR R2, [PC, #148]
482E  4E258013     STRH R3, [R2]
735:            /* first filter (FIR) */
736:            /* since we use as output the accumulator undivided, the amplification is
737:             4=2^2 if we calculate the speed over 4 samples; if the speed is
738:             calculated over a different number of samples, the amplification has
739:             to be adapted in consequence, since at the end we want a total amp of
740:             2^14 */
741:            sp_fir_acc += dph;
4836  46944A25     LDR R2, [PC, #148]
4838  68124694     MOV R12, R2
483A  46906812     LDR R2, [R2]
483C  44984690     MOV R8, R2
483E  4F234498     ADD R8, R3
742:            sp_fir_acc -= sp_fir_vec[sp_fir_ind];
4830  22004E25     LDR R6, [PC, #148]
4832  5EB52200     MOVS R2, #0
4834  4A255EB5     LDRSH R5, [R6, R2]
4840  6A4F23     LDR R7, [PC, #140]
4842  5FD0006A     LSLS R2, R5, #1
4844  46415FD0     LDRSH R0, [R2, R7]
4846  1A084641     MOV R1, R8
4848  46611A08     SUBS R0, R1, R0
484A  60084661     MOV R1, R12
484C  53D36008     STR R0, [R1]
743:            sp_fir_vec[sp_fir_ind] = dph;  /* max speed: pi[rad/s]/Ts[s] */
484E  350153D3     STRH R3, [R2, R7]
744:               sp_fir_ind++;
4850  23033501     ADDS R5, #1
745:            /* sp_fir_ind &= 0x07; speed calculated over 8 samples */
746:            /*lint -save -e9027 */
747:            sp_fir_ind &= 0x03; /* speed calculated over 4 samples */
4852  401D2303     MOVS R3, #3
4854  8035401D     ANDS R5, R3
4856  4B1E8035     STRH R5, [R6]
748:           
749:            /* now we will apply three IIR in cascade configuration;
750:             the IIR time constant is ((2^4)-1)*Ts, so the cut-off frequency is Fs/(30pi)
751:             (around 85Hz if Fs=8kHz) */
752:           
753:            /* second filter (IIR) */
754:            /* since we use as output the filter memory, the amplification is 2^4=16 */
755:            /*sp_iir1_mem -= shfdw2(sp_iir1_mem, 4);*/ /* sp_iir1_mem -= sp_iir1_mem >> 4; */
756:           
757:               sp_iir1_mem -= sp_iir1_mem >> 4;
4858  68194B1E     LDR R3, [PC, #120]
485A  110A6819     LDR R1, [R3]
485C  1A8A110A     ASRS R2, R1, #4
485E  18121A8A     SUBS R2, R1, R2
758:            /* sp_iir1_mem += shfdw1(sp_fir_acc, 1); speed calculated over 8 samples */
759:            sp_iir1_mem += sp_fir_acc; /* speed calculated over 4 samples */
4860  601A1812     ADDS R2, R2, R0
4862  4D1C601A     STR R2, [R3]
760:           
761:            /* third filter (IIR) */
762:            /* since we use as output the filter memory, the amplification is 2^4=16 */
763:            /*sp_iir2_mem -= shfdw2(sp_iir2_mem, 4);*/ /* sp_iir2_mem -= sp_iir2_mem >> 4; */
764:            sp_iir2_mem -= sp_iir2_mem >> 4;
4864  682B4D1C     LDR R5, [PC, #112]
4866  1118682B     LDR R3, [R5]
4868  1A181118     ASRS R0, R3, #4
486A  18821A18     SUBS R0, R3, R0
765:            sp_iir2_mem += sp_iir1_mem;
486C  602A1882     ADDS R2, R0, R2
486E  491A602A     STR R2, [R5]
766:           
767:            /* fourth filter (IIR) */
768:            /* since we use as output the filter memory, the amplification is 2^4=16 */
769:            /*sp_iir3_mem -= shfdw2(sp_iir3_mem, 4);*/ /* sp_iir3_mem -= sp_iir3_mem >> 4; */
770:            sp_iir3_mem -= sp_iir3_mem >> 4;
4870  680B491A     LDR R1, [PC, #104]
4872  1118680B     LDR R3, [R1]
4874  1A181118     ASRS R0, R3, #4
4876  18801A18     SUBS R0, R3, R0
771:            sp_iir3_mem += sp_iir2_mem;
4878  60081880     ADDS R0, R0, R2
487A  4B186008     STR R0, [R1]
772:           
773:            /* the total amplification is 2^(2+3*4=14); now come back to the internal units */
774:            speed_abs = (int16_t)(sp_iir3_mem / k_spe12);
487C  21004B18     LDR R3, [PC, #96]
487E  5E592100     MOVS R1, #0
4880  4B185E59     LDRSH R1, [R3, R1]
4882  47984B18     LDR R3, [PC, #96]
4884  B2034798     BLX R3
4886  4A17B203     SXTH R3, R0
4888  80134A17     LDR R2, [PC, #92]
488A  2C008013     STRH R3, [R2]
775:            #ifdef PH_CLAMP
776:            dph_abs_fil = (int16_t)(sp_iir3_mem >> 14);
777:            #endif 
778:            if(0 > speed_sgn)
488C  DB0F2C00     CMP R4, #0
488E  4A16DB0F     BLT.N .LVL75
779:            {
780:             speed_est = -speed_abs;
48B0  4B0E4240     RSBS R0, R0, #0
781:            }
782:            else
783:            {
784:             speed_est = speed_abs;
4890  80134A16     LDR R2, [PC, #88]
4892  BC048013     STRH R3, [R2]
785:            }
786:            /*lint -restore */
787:           }
4894  4690BC04     POP {R2}
4896  BDF04690     MOV R8, R2
4898  4B09BDF0     POP {R4, R5, R6, R7, PC}
489A  881B4B09     LDR R3, [PC, #36]
489C  4A07881B     LDRH R3, [R3]
489E  88124A07     LDR R2, [PC, #28]
48A0  1A9B8812     LDRH R2, [R2]
48A2  B21B1A9B     SUBS R3, R3, R2
48A4  E7BBB21B     SXTH R3, R3
48A6  4B11E7BB     B.N .LVL69
48A8  22004B11     LDR R3, [PC, #68]
48AA  5E9B2200     MOVS R2, #0
48AC  E7BD5E9B     LDRSH R3, [R3, R2]
48AE  4240E7BD     B.N 0x482C
48B0  4B0E4240     RSBS R0, R0, #0
48B2  80184B0E     LDR R3, [PC, #56]
48B4  E7ED8018     STRH R0, [R3]
48B6  293AE7ED     B.N 0x4894
48B8  2000293A     CMP R1, #58
48BA  292C2000     MOVS R0, #0
48BC  2000292C     CMP R1, #44
48BE  292E2000     MOVS R0, #0
48C0  2000292E     CMP R1, #46
48C2  1702000     MOVS R0, #0
48C4  20000170     LSLS R0, R6, #5
48C6  29322000     MOVS R0, #0
48C8  20002932     CMP R1, #50
48CA  28EC2000     MOVS R0, #0
48CC  200028EC     CMP R0, #236
48CE  28402000     MOVS R0, #0
48D0  20002840     CMP R0, #64
48D2  28F02000     MOVS R0, #0
48D4  200028F0     CMP R0, #240
48D6  28F42000     MOVS R0, #0
48D8  200028F4     CMP R0, #244
48DA  28F82000     MOVS R0, #0
48DC  200028F8     CMP R0, #248
48DE  29302000     MOVS R0, #0
48E0  20002930     CMP R1, #48
48E2  41D12000     MOVS R0, #0
48E4  41D1     RORS R1, R2
48E6  29340000     MOVS R0, R0
48E8  20002934     CMP R1, #52
48EA  29362000     MOVS R0, #0
48EC  20002936     CMP R1, #54
48EE  292A2000     MOVS R0, #0
48F0  2000292A     CMP R1, #42
48F2  B5702000     MOVS R0, #0
788:           
789:           /******************************************************************************
790:           Function:  speed_filter_init
791:           Description: initial setting of speed filter memories
792:           Input:   speed [internal_speed_unit]
793:           Output:   nothing
794:           Modifies:  internal speed estimation filter memories
795:           ******************************************************************************/
796:           void speed_filter_init(int16_t speed)
797:           {
798:            int16_t temp;
799:           
800:            speed_est = speed;
512C  80184B19     LDR R3, $d
512E  28008018     STRH R0, [R3]
801:            if(0 > speed_est)
5130  DB272800     CMP R0, #0
5132  4B18DB27     BLT.N .LVL81
802:            {
803:             speed_abs = -speed_est;
5184  4B044240     RSBS R0, R0, #0
5186  80184B04     LDR R3, [PC, #16]
5188  22018018     STRH R0, [R3]
804:             speed_sgn = -1;
518A  42522201     MOVS R2, #1
805:            }
806:            else
807:            {
808:             speed_abs = speed_est;
5134  80184B18     LDR R3, [PC, #96]
5136  22018018     STRH R0, [R3]
809:             speed_sgn = 1;
5138  4B182201     MOVS R2, #1
513A  801A4B18     LDR R3, [PC, #96]
513C  4B16801A     STRH R2, [R3]
810:            }
811:            sp_iir3_mem = ((int32_t)speed_abs) * ((int32_t)k_spe12);
513E  22004B16     LDR R3, [PC, #88]
5140  5E9B2200     MOVS R2, #0
5142  4A165E9B     LDRSH R3, [R3, R2]
5144  21004A16     LDR R2, [PC, #88]
5146  5E522100     MOVS R1, #0
5148  435A5E52     LDRSH R2, [R2, R1]
514A  4B15435A     MULS R2, R3
514C  601A4B15     LDR R3, [PC, #84]
514E  1111601A     STR R2, [R3]
812:            /*lint -save -e9027 */
813:            sp_iir2_mem = sp_iir3_mem >> 4;
5150  4B151111     ASRS R1, R2, #4
5152  60194B15     LDR R3, [PC, #84]
5154  12116019     STR R1, [R3]
814:            sp_iir1_mem = sp_iir2_mem >> 4;
5156  4B141211     ASRS R1, R2, #8
5158  60194B14     LDR R3, [PC, #80]
515A  13116019     STR R1, [R3]
815:            sp_fir_acc = sp_iir1_mem >> 4;
515C  4B141311     ASRS R1, R2, #12
515E  60194B14     LDR R3, [PC, #80]
5160  13926019     STR R1, [R3]
816:           
817:            temp = (int16_t)(sp_fir_acc >> 2);  /*speed calculated over 4 samples */
5162  B2121392     ASRS R2, R2, #14
5164  4B13B212     SXTH R2, R2
5166  194B13     LDR R3, [PC, #76]
5168  31100019     MOVS R1, R3
516A  801A3110     ADDS R1, #16
818:            /* temp = (int16_t)(sp_fir_acc >> 3); speed calculated over 8 samples */
819:            dph_abs_fil = (uint16_t)(temp);
820:           
821:            /*lint -restore*/
822:            for(sp_fir_ind = 0; sp_fir_ind < 8; sp_fir_ind++)
5170  D1FB428B     CMP R3, R1
5172  2200D1FB     BNE.N 0x516C
823:            {
824:             sp_fir_vec[sp_fir_ind] = (int16_t)dph_abs_fil;
516C  3302801A     STRH R2, [R3]
516E  428B3302     ADDS R3, #2
825:            }
826:            sp_fir_ind = 0;
5174  4B102200     MOVS R2, #0
5176  801A4B10     LDR R3, [PC, #64]
5178  4B10801A     STRH R2, [R3]
827:            flx_arg_mem = flx_arg;
517A  881A4B10     LDR R3, [PC, #64]
517C  4B10881A     LDRH R2, [R3]
517E  801A4B10     LDR R3, [PC, #64]
5180  4770801A     STRH R2, [R3]
828:           }
5182  42404770     BX LR
5184  4B044240     RSBS R0, R0, #0
5186  80184B04     LDR R3, [PC, #16]
5188  22018018     STRH R0, [R3]
518A  42522201     MOVS R2, #1
518C  4B034252     RSBS R2, R2, #0
518E  801A4B03     LDR R3, [PC, #12]
5190  E7D4801A     STRH R2, [R3]
5192  2936E7D4     B.N .LVL77
5194  20002936     CMP R1, #54
5196  29342000     MOVS R0, #0
5198  20002934     CMP R1, #52
519A  293A2000     MOVS R0, #0
519C  2000293A     CMP R1, #58
519E  29302000     MOVS R0, #0
51A0  20002930     CMP R1, #48
51A2  28F82000     MOVS R0, #0
51A4  200028F8     CMP R0, #248
51A6  28F42000     MOVS R0, #0
51A8  200028F4     CMP R0, #244
51AA  28F02000     MOVS R0, #0
51AC  200028F0     CMP R0, #240
51AE  28EC2000     MOVS R0, #0
51B0  200028EC     CMP R0, #236
51B2  28402000     MOVS R0, #0
51B4  20002840     CMP R0, #64
51B6  29322000     MOVS R0, #0
51B8  20002932     CMP R1, #50
51BA  292C2000     MOVS R0, #0
51BC  2000292C     CMP R1, #44
51BE  292E2000     MOVS R0, #0
51C0  2000292E     CMP R1, #46
51C2  B5102000     MOVS R0, #0
829:           
830:           /******************************************************************************
831:           Function:  delay_comp
832:           Description: calculation of the phase error due to algorithm medium delay
833:           Input:   nothing (uses internal speed filter memory)
834:           Output:   phase delay (medium time delay is 1.5 sampling periods)
835:           ******************************************************************************/
836:           uint16_t delay_comp(void)
837:           {
838:            int32_t s32a;
839:            int16_t s16a;
840:                   uint16_t retval;
841:           
842:            s32a = sp_iir3_mem;  /* always positive */
6004  68184B09     LDR R3, $d
6006  10436818     LDR R0, [R3]
843:            /*lint -save -e9027 */
844:            s32a += (s32a >> 1); /* 1.5 */
6008  18C31043     ASRS R3, R0, #1
600A  4A0818C3     ADDS R3, R0, R3
845:            if((int32_t)BASE_VALUE_INT <= s32a)
600C  20004A08     LDR R2, [PC, #32]
6010  DD064293     CMP R3, R2
6012  4A07DD06     BLE.N .LVL129
846:            {
847:             if(0 > speed_sgn)
6014  21004A07     LDR R2, [PC, #28]
6016  5E522100     MOVS R1, #0
6018  2A005E52     LDRSH R2, [R2, R1]
601A  DB022A00     CMP R2, #0
601C  139BDB02     BLT.N .LVL130
848:             {
849:                s16a = (int16_t)(-(s32a >> SH_BASE_VALUE));
6024  4258139B     ASRS R3, R3, #14
850:                    retval = ((uint16_t)s16a);
851:             }
852:             else
853:             {
854:                    s16a = (int16_t)((s32a >> SH_BASE_VALUE));
601E  B298139B     ASRS R3, R3, #14
855:                              retval = ((uint16_t)s16a);
6020  4770B298     UXTH R0, R3
856:             }
857:            }
858:            else
859:            {
860:                     retval = (0U);
600E  42932000     MOVS R0, #0
861:            }
862:            /*lint -restore */
863:            return (retval);
864:           }
6022  139B4770     BX LR
6024  4258139B     ASRS R3, R3, #14
6026  B2804258     RSBS R3, R0, #0
6028  E7FAB280     UXTH R0, R0
602A  28F8E7FA     B.N .LVL129
602C  200028F8     CMP R0, #248
602E  3FFF2000     MOVS R0, #0
6030  3FFF     SUBS R7, #255
6032  293A0000     MOVS R0, R0
6034  2000293A     CMP R1, #58
6036  B5702000     MOVS R0, #0
865:           
866:           /******************************************************************************
867:           Function:  position_and_speed_estimation
868:           Description: performs the position and speed estimation
869:           Input:   reference speed [internal_speed_unit] rs
870:               applied voltage vector (in stationary reference frame)
871:               measured current vector (in stationary reference frame)
872:           Output:   nothing (updates internal variables)
873:           ******************************************************************************/
874:           void position_and_speed_estimation(int16_t rs, const vec2_t *v, const vec2_t *i)
875:           {
61AC  CB570     PUSH {R4, R5, R6, LR}
61AE  15000C     MOVS R4, R1
61B0  4B050015     MOVS R5, R2
876:            obs_coef_calc(rs);
61B2  47984B05     LDR R3, [PC, #20]
61B4  294798     BLX R3
877:            lunberger_observer(v, i);
61B6  200029     MOVS R1, R5
61B8  4B040020     MOVS R0, R4
61BA  47984B04     LDR R3, [PC, #16]
61BC  4B044798     BLX R3
878:            phase_estimation();
61BE  47984B04     LDR R3, [PC, #16]
61C0  4B044798     BLX R3
879:            speed_filter();
61C2  47984B04     LDR R3, [PC, #16]
61C4  BD704798     BLX R3
880:           }
61C6  6359BD70     POP {R4, R5, R6, PC}
61C8  6359     STR R1, [R3, #52]
61CA  46FD0000     MOVS R0, R0
61CC  46FD     MOV SP, PC
61CE  57D50000     MOVS R0, R0
61D0  57D5     LDRSB R5, [R2, R7]
61D2  48050000     MOVS R0, R0
61D4  4805     LDR R0, [PC, #20]
61D6  B5100000     MOVS R0, R0
881:           
882:           /******************************************************************************
883:           Function:  bemfposition_and_speed_estimation
884:           Description: performs the position and speed estimation
885:           Input:   reference speed [internal_speed_unit] rs
886:               applied voltage vector (in stationary reference frame)
887:               measured current vector (in stationary reference frame)
888:           Output:   nothing (updates internal variables)
889:           ******************************************************************************/
890:           void bemfposition_and_speed_estimation(int16_t rs, const vec2_t *v, const vec2_t *i)
891:           {
0000  20007FF8     LDRB R0, [R7, #31]
892:            obs_coef_calc(rs);
0006  653D0000     MOVS R0, R0
893:            lunberger_observer(v, i);
000A  653F0000     MOVS R0, R0
894:            phase_estimation();
0012  0000     MOVS R0, R0
895:            speed_filter();
0016  0000     MOVS R0, R0
896:           }
001A  0000     MOVS R0, R0
897:           
898:           /******************************************************************************
899:           Function:  estimation_alignment
900:           Description: aligns the observer
901:           Input:   reference speed [internal_speed_unit] rs
902:               applied voltage vector (in stationary reference frame)
903:               measured current vector (in stationary reference frame)
904:           Output:   nothing (updates internal variables)
905:           ******************************************************************************/
906:           void estimation_alignment(int16_t rs, const vec2_t *v, const vec2_t *i)
907:           {
606C  4B570     PUSH {R4, R5, R6, LR}
606E  D0004     MOVS R4, R0
6070  16000D     MOVS R5, R1
6072  4B050016     MOVS R6, R2
908:            obs_coef_calc(rs);
6074  47984B05     LDR R3, $d
6076  314798     BLX R3
909:            lunberger_observer(v, i);
6078  280031     MOVS R1, R6
607A  4B040028     MOVS R0, R5
607C  47984B04     LDR R3, [PC, #16]
607E  4B044798     BLX R3
910:            phase_estimation_init();
6080  47984B04     LDR R3, [PC, #16]
6082  204798     BLX R3
911:            speed_filter_init(rs);
6084  4B040020     MOVS R0, R4
6086  47984B04     LDR R3, [PC, #16]
6088  BD704798     BLX R3
912:           }
608A  6359BD70     POP {R4, R5, R6, PC}
608C  6359     STR R1, [R3, #52]
608E  46FD0000     MOVS R0, R0
6090  46FD     MOV SP, PC
6092  5A290000     MOVS R0, R0
6094  5A29     LDRH R1, [R5, R0]
6096  512D0000     MOVS R0, R0
6098  512D     STR R5, [R5, R4]
609A  21D80000     MOVS R0, R0
913:           
914:           /******************************************************************************
915:           Function:  get_angular_position
916:           Description: returns the estimated position [internal_angle_unit]
917:           Input:   nothing
918:           Output:   compensated estimated position
919:           ******************************************************************************/
920:           uint16_t get_angular_position(void)
921:           {
6408  4B03B510     PUSH {R4, LR}
922:            return(flx_arg + delay_comp());
640A  47984B03     LDR R3, [PC, #12]
640C  4B034798     BLX R3
640E  881B4B03     LDR R3, [PC, #12]
6410  18C0881B     LDRH R3, [R3]
6412  B28018C0     ADDS R0, R0, R3
6414  BD10B280     UXTH R0, R0
923:           }
6416  6005BD10     POP {R4, PC}
6418  6005     STR R5, [R0]
641A  292C0000     MOVS R0, R0
641C  2000292C     CMP R1, #44
641E  1D242000     MOVS R0, #0
924:           
925:           /******************************************************************************
926:           Function:  get_angular_speed
927:           Description: returns the estimated speed [internal_speed_unit]
928:           Input:   nothing
929:           Output:   estimated speed
930:           ******************************************************************************/
931:           int16_t get_angular_speed(void)
932:           {
933:            return(speed_est);
651C  20004B01     LDR R3, $d
651E  5E182000     MOVS R0, #0
6520  47705E18     LDRSH R0, [R3, R0]
934:           }
6522  29364770     BX LR
6524  20002936     CMP R1, #54
6526  84012000     MOVS R0, #0
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/q14_generic_mcLib.c  -----
1:             /*******************************************************************************
2:              Generic Motor Control Library 
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 q14_generic_mcLib.c
9:             
10:              Summary:
11:                Generic Motor Control Library implemented in Q14 fixed point arithmetic.
12:            
13:              Description:
14:                This file implements generic vector motor control related functions
15:             *  like Trigonometric, Transformations, PI Control
16:             *******************************************************************************/
17:            
18:            // DOM-IGNORE-BEGIN
19:            /*******************************************************************************
20:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
21:            *
22:            * Subject to your compliance with these terms, you may use Microchip software
23:            * and any derivatives exclusively with Microchip products. It is your
24:            * responsibility to comply with third party license terms applicable to your
25:            * use of third party software (including open source software) that may
26:            * accompany Microchip software.
27:            *
28:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:            * PARTICULAR PURPOSE.
32:            *
33:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:             *******************************************************************************/
41:            // DOM-IGNORE-END
42:            
43:            #include <math.h>
44:            #include <stdint.h>
45:            #include "q14_generic_mcLib.h"
46:            
47:            
48:            /*******************************************************************************
49:            Macro definitions
50:            *******************************************************************************/
51:            
52:            /* trigonometric tables */
53:            #define SH_TRITAB_DIM	( 8U )
54:            #define TRITAB_DIM		( (uint16_t)1U << (uint16_t)SH_TRITAB_DIM )
55:            #define SH_SINTAB		( 14U - SH_TRITAB_DIM )	// PIHALVES=(2^16)/4=2^14
56:            #define SH_SACTAB		( SH_BASE_VALUE - SH_TRITAB_DIM )
57:            #define SH_ACTTAB		( SH_BASE_VALUE - SH_TRITAB_DIM )
58:            #define	SEL1Q			( 0x3FFFU )	/* select first_quarter_value */
59:            #define	ISCOS			( 0x4000U )	/* table(first_quarter_value) gives cos */
60:            #define	ISNEG			( 0x8000U )	/* sin is neg */
61:            
62:            
63:            /******************************************************************************
64:            Private global variables
65:            ******************************************************************************/
66:            
67:            /* table y = BASE_VALUE * sin((pi/2) * x / TRITAB_DIM)
68:             0 <= x <= TRITAB_DIM, 0 <= y <= BASE_VALUE (first quarter) */
69:            static const int16_t sin_table[TRITAB_DIM + 1U] = {
70:            	    0,   101,   201,   302,   402,   503,   603,   704,	//   0, ..,   7
71:            	  804,   904,  1005,  1105,  1205,  1306,  1406,  1506,	//   8, ..,  15
72:            	 1606,  1706,  1806,  1906,  2006,  2105,  2205,  2305,	//  16, ..,  23
73:            	 2404,  2503,  2603,  2702,  2801,  2900,  2999,  3098,	//  24, ..,  31
74:            	 3196,  3295,  3393,  3492,  3590,  3688,  3786,  3883,	//  32, ..,  39
75:            	 3981,  4078,  4176,  4273,  4370,  4467,  4563,  4660,	//  40, ..,  47
76:            	 4756,  4852,  4948,  5044,  5139,  5235,  5330,  5425,	//  48, ..,  55
77:            	 5520,  5614,  5708,  5803,  5897,  5990,  6084,  6177,	//  56, ..,  63
78:            	 6270,  6363,  6455,  6547,  6639,  6731,  6823,  6914,	//  64, ..,  71
79:            	 7005,  7096,  7186,  7276,  7366,  7456,  7545,  7635,	//  72, ..,  79
80:            	 7723,  7812,  7900,  7988,  8076,  8163,  8250,  8337,	//  80, ..,  87
81:            	 8423,  8509,  8595,  8680,  8765,  8850,  8935,  9019,	//  88, ..,  95
82:            	 9102,  9186,  9269,  9352,  9434,  9516,  9598,  9679,	//  96, .., 103
83:            	 9760,  9841,  9921, 10001, 10080, 10159, 10238, 10316,	// 104, .., 111
84:            	10394, 10471, 10549, 10625, 10702, 10778, 10853, 10928,	// 112, .., 119
85:            	11003, 11077, 11151, 11224, 11297, 11370, 11442, 11514,	// 120, .., 127
86:            	11585, 11656, 11727, 11797, 11866, 11935, 12004, 12072,	// 128, .., 135
87:            	12140, 12207, 12274, 12340, 12406, 12472, 12537, 12601,	// 136, .., 143
88:            	12665, 12729, 12792, 12854, 12916, 12978, 13039, 13100,	// 144, .., 151
89:            	13160, 13219, 13279, 13337, 13395, 13453, 13510, 13567,	// 152, .., 159
90:            	13623, 13678, 13733, 13788, 13842, 13896, 13949, 14001,	// 160, .., 167
91:            	14053, 14104, 14155, 14206, 14256, 14305, 14354, 14402,	// 168, .., 175
92:            	14449, 14497, 14543, 14589, 14635, 14680, 14724, 14768,	// 176, .., 183
93:            	14811, 14854, 14896, 14937, 14978, 15019, 15059, 15098,	// 184, .., 191
94:            	15137, 15175, 15213, 15250, 15286, 15322, 15357, 15392,	// 192, .., 199
95:            	15426, 15460, 15493, 15525, 15557, 15588, 15619, 15649,	// 200, .., 207
96:            	15679, 15707, 15736, 15763, 15791, 15817, 15843, 15868,	// 208, .., 215
97:            	15893, 15917, 15941, 15964, 15986, 16008, 16029, 16049,	// 216, .., 223
98:            	16069, 16088, 16107, 16125, 16143, 16160, 16176, 16192,	// 224, .., 231
99:            	16207, 16221, 16235, 16248, 16261, 16273, 16284, 16295,	// 232, .., 239
100:           	16305, 16315, 16324, 16332, 16340, 16347, 16353, 16359,	// 240, .., 247
101:           	16364, 16369, 16373, 16376, 16379, 16381, 16383, 16384,	// 248, .., 255
102:           	16384};													// 256
103:           
104:           /* table y = BASE_VALUE * sin(acos(x / TRITAB_DIM))
105:            0 <= x <= TRITAB_DIM, 0 <= y <= BASE_VALUE (first quarter) */
106:           static const uint16_t library_tbsac[TRITAB_DIM + 1U] = {
107:           	16384, 16384, 16383, 16383, 16382, 16381, 16379, 16378, //   0, ..,   7
108:           	16376, 16374, 16371, 16369, 16366, 16363, 16359, 16356, //   8, ..,  15
109:           	16352, 16348, 16343, 16339, 16334, 16329, 16323, 16318, //  16, ..,  23
110:           	16312, 16306, 16299, 16293, 16286, 16279, 16271, 16263, //  24, ..,  31
111:           	16255, 16247, 16239, 16230, 16221, 16212, 16202, 16193, //  32, ..,  39
112:           	16183, 16173, 16162, 16151, 16140, 16129, 16117, 16106, //  40, ..,  47
113:           	16093, 16081, 16068, 16056, 16042, 16029, 16015, 16001, //  48, ..,  55
114:           	15987, 15973, 15958, 15943, 15928, 15912, 15896, 15880, //  56, ..,  63
115:           	15864, 15847, 15830, 15813, 15795, 15778, 15760, 15741, //  64, ..,  71
116:           	15723, 15704, 15685, 15665, 15645, 15625, 15605, 15584, //  72, ..,  79
117:           	15563, 15542, 15521, 15499, 15477, 15455, 15432, 15409, //  80, ..,  87
118:           	15386, 15362, 15338, 15314, 15289, 15265, 15240, 15214, //  88, ..,  95
119:           	15188, 15162, 15136, 15109, 15082, 15055, 15027, 14999, //  96, .., 103
120:           	14971, 14942, 14914, 14884, 14855, 14825, 14794, 14764, // 104, .., 111
121:           	14733, 14701, 14670, 14638, 14605, 14573, 14540, 14506, // 112, .., 119
122:           	14472, 14438, 14404, 14369, 14334, 14298, 14262, 14226, // 120, .., 127
123:           	14189, 14152, 14114, 14076, 14038, 13999, 13960, 13921, // 128, .., 135
124:           	13881, 13840, 13800, 13759, 13717, 13675, 13632, 13590, // 136, .., 143
125:           	13546, 13502, 13458, 13414, 13368, 13323, 13277, 13230, // 144, .., 151
126:           	13183, 13136, 13088, 13040, 12991, 12941, 12891, 12841, // 152, .., 159
127:           	12790, 12738, 12686, 12634, 12581, 12527, 12473, 12418, // 160, .., 167
128:           	12362, 12306, 12250, 12193, 12135, 12077, 12018, 11958, // 168, .., 175
129:           	11898, 11837, 11775, 11713, 11650, 11586, 11522, 11457, // 176, .., 183
130:           	11391, 11325, 11257, 11189, 11121, 11051, 10980, 10909, // 184, .., 191
131:           	10837, 10764, 10690, 10615, 10540, 10463, 10385, 10307, // 192, .., 199
132:           	10227, 10147, 10065,  9982,  9898,  9813,  9727,  9640, // 200, .., 207
133:           	 9551,  9461,  9370,  9278,  9184,  9089,  8992,  8894, // 208, .., 215
134:           	 8794,  8692,  8589,  8485,  8378,  8269,  8159,  8046, // 216, .., 223
135:           	 7932,  7815,  7696,  7574,  7450,  7324,  7194,  7062, // 224, .., 231
136:           	 6926,  6787,  6645,  6499,  6349,  6194,  6035,  5871, // 232, .., 239
137:           	 5701,  5526,  5344,  5155,  4957,  4751,  4535,  4306, // 240, .., 247
138:           	 4064,  3805,  3526,  3222,  2885,  2501,  2044,  1447, // 248, .., 255
139:           	    0};							// 256
140:           
141:           /* table y = ((PI / FLOAT_PI) * atan(x / TRITAB_DIM))
142:            0 <= x <= TRITAB_DIM, 0 <= y <= PIFOURTHS (first half quarter) */
143:           static const int16_t library_tbact[TRITAB_DIM + 1U] = {
144:           	    0,    41,    81,   122,   163,   204,   244,   285, //   0, ..,   7
145:           	  326,   367,   407,   448,   489,   529,   570,   610, //   8, ..,  15
146:           	  651,   692,   732,   773,   813,   854,   894,   935, //  16, ..,  23
147:           	  975,  1015,  1056,  1096,  1136,  1177,  1217,  1257, //  24, ..,  31
148:           	 1297,  1337,  1377,  1417,  1457,  1497,  1537,  1577, //  32, ..,  39
149:           	 1617,  1656,  1696,  1736,  1775,  1815,  1854,  1894, //  40, ..,  47
150:           	 1933,  1973,  2012,  2051,  2090,  2129,  2168,  2207, //  48, ..,  55
151:           	 2246,  2285,  2324,  2363,  2401,  2440,  2478,  2517, //  56, ..,  63
152:           	 2555,  2594,  2632,  2670,  2708,  2746,  2784,  2822, //  64, ..,  71
153:           	 2860,  2897,  2935,  2973,  3010,  3047,  3085,  3122, //  72, ..,  79
154:           	 3159,  3196,  3233,  3270,  3307,  3344,  3380,  3417, //  80, ..,  87
155:           	 3453,  3490,  3526,  3562,  3599,  3635,  3670,  3706, //  88, ..,  95
156:           	 3742,  3778,  3813,  3849,  3884,  3920,  3955,  3990, //  96, .., 103
157:           	 4025,  4060,  4095,  4129,  4164,  4199,  4233,  4267, // 104, .., 111
158:           	 4302,  4336,  4370,  4404,  4438,  4471,  4505,  4539, // 112, .., 119
159:           	 4572,  4605,  4639,  4672,  4705,  4738,  4771,  4803, // 120, .., 127
160:           	 4836,  4869,  4901,  4933,  4966,  4998,  5030,  5062, // 128, .., 135
161:           	 5094,  5125,  5157,  5188,  5220,  5251,  5282,  5313, // 136, .., 143
162:           	 5344,  5375,  5406,  5437,  5467,  5498,  5528,  5559, // 144, .., 151
163:           	 5589,  5619,  5649,  5679,  5708,  5738,  5768,  5797, // 152, .., 159
164:           	 5826,  5856,  5885,  5914,  5943,  5972,  6000,  6029, // 160, .., 167
165:           	 6058,  6086,  6114,  6142,  6171,  6199,  6227,  6254, // 168, .., 175
166:           	 6282,  6310,  6337,  6365,  6392,  6419,  6446,  6473, // 176, .., 183
167:           	 6500,  6527,  6554,  6580,  6607,  6633,  6660,  6686, // 184, .., 191
168:           	 6712,  6738,  6764,  6790,  6815,  6841,  6867,  6892, // 192, .., 199
169:           	 6917,  6943,  6968,  6993,  7018,  7043,  7068,  7092, // 200, .., 207
170:           	 7117,  7141,  7166,  7190,  7214,  7238,  7262,  7286, // 208, .., 215
171:           	 7310,  7334,  7358,  7381,  7405,  7428,  7451,  7475, // 216, .., 223
172:           	 7498,  7521,  7544,  7566,  7589,  7612,  7635,  7657, // 224, .., 231
173:           	 7679,  7702,  7724,  7746,  7768,  7790,  7812,  7834, // 232, .., 239
174:           	 7856,  7877,  7899,  7920,  7942,  7963,  7984,  8005, // 240, .., 247
175:           	 8026,  8047,  8068,  8089,  8110,  8131,  8151,  8172, // 248, .., 255
176:           	 8192};							// 256
177:           
178:           
179:           
180:           /******************************************************************************
181:           Public functions
182:           ******************************************************************************/
183:           
184:           /******************************************************************************
185:           Function:		library_sin
186:           Description:	y = BASE_VALUE * sin(ang)
187:           Input:			ang = (PI / FLOAT_PI) * angle[rad], 0 <= ang < TWOPI
188:           Output:			normalized sin value y, |y| <= BASE_VALUE
189:           Revision:		1.0
190:           ******************************************************************************/
191:            int16_t library_sin(uint16_t ang)
192:           {
6180  4830002     MOVS R2, R0
193:           	uint16_t	a;
194:           	int16_t		y;
195:           
196:           	a = ang & SEL1Q; /* select angle in the first quarter (<= PIHALVES) */
6182  C9B0483     LSLS R3, R0, #18
6184  4410C9B     LSRS R3, R3, #18
197:           	if((ISCOS & ang) != 0U)
6186  D5030441     LSLS R1, R0, #17
6188  2180D503     BPL.N .LVL3
198:           	{
199:           	  a = PIHALVES - a;
618A  1C92180     MOVS R1, #128
618C  1ACB01C9     LSLS R1, R1, #7
618E  B29B1ACB     SUBS R3, R1, R3
6190  99BB29B     UXTH R3, R3
200:           	}
201:           	y = sin_table[a >> SH_SINTAB];
6192  5B099B     LSRS R3, R3, #6
6194  4904005B     LSLS R3, R3, #1
6196  5E584904     LDR R1, [PC, #16]
6198  B2125E58     LDRSH R0, [R3, R1]
202:           	return (((ISNEG & ang) != 0U)? -y: y);
619A  2A00B212     SXTH R2, R2
619C  DB002A00     CMP R2, #0
619E  4770DB00     BLT.N .LVL7
61A2  B2004240     RSBS R0, R0, #0
203:           }
61A0  42404770     BX LR
61A2  B2004240     RSBS R0, R0, #0
61A4  E7FBB200     SXTH R0, R0
61A6  3FCCE7FB     B.N .LVL6
61A8  3FCC     SUBS R7, #204
61AA  B5700000     MOVS R0, R0
204:           
205:           /******************************************************************************
206:           Function:		library_cos
207:           Description:	y = BASE_VALUE * cos(ang)
208:           Input:			ang = (PI / FLOAT_PI) * angle[rad], 0 <= ang < TWOPI
209:           Output:			normalized cos value y, |y| <= BASE_VALUE
210:           Revision:		1.0
211:           ******************************************************************************/
212:            int16_t library_cos(uint16_t ang)
213:           {
214:           	uint16_t	a;
215:           	int16_t		y;
216:                   uint16_t  ang_temp;
217:           
218:           	/* overflow is OK here due to angle periodicity */
219:           	ang_temp = ang + PIHALVES;
5FD0  1DB2380     MOVS R3, #128
5FD2  469C01DB     LSLS R3, R3, #7
5FD4  4460469C     MOV R12, R3
5FD6  B2834460     ADD R0, R12
5FD8  49AB283     UXTH R3, R0
220:                   a = ang_temp  & SEL1Q;  /* select angle in the first quarter (<= PIHALVES) */
5FDA  C92049A     LSLS R2, R3, #18
5FDC  4590C92     LSRS R2, R2, #18
221:           	if((ISCOS & ang_temp) != 0U)
5FDE  D5020459     LSLS R1, R3, #17
5FE0  4661D502     BPL.N .LVL15
222:           	{
223:           		a = PIHALVES - a;
5FE2  1A8A4661     MOV R1, R12
5FE4  B2921A8A     SUBS R2, R1, R2
5FE6  992B292     UXTH R2, R2
224:           	}
225:           	y = sin_table[a >> SH_SINTAB];
5FE8  520992     LSRS R2, R2, #6
5FEA  49040052     LSLS R2, R2, #1
5FEC  5E504904     LDR R1, $d
5FEE  B21B5E50     LDRSH R0, [R2, R1]
226:           	return (((ISNEG & ang_temp) != 0U )? -y: y);
5FF0  2B00B21B     SXTH R3, R3
5FF2  DB002B00     CMP R3, #0
5FF4  4770DB00     BLT.N .LVL19
5FF8  B2004240     RSBS R0, R0, #0
227:           }
5FF6  42404770     BX LR
5FF8  B2004240     RSBS R0, R0, #0
5FFA  E7FBB200     SXTH R0, R0
5FFC  46C0E7FB     B.N .LVL18
5FFE  3FCC46C0     MOV R8, R8
6000  3FCC     SUBS R7, #204
6002  4B090000     MOVS R0, R0
228:           
229:           /******************************************************************************
230:           Function:		library_sincos
231:           Description:	sin and cos calculation
232:           Input:			t, angle structure address
233:           Output:			nothing
234:           Modifies:		angle structure fields t->sin and t->cos, using field t->ang
235:           Revision:		1.0
236:           ******************************************************************************/
237:           void library_sincos(ang_sincos_t *t)
238:           {
62E0  4B570     PUSH {R4, R5, R6, LR}
62E2  88050004     MOVS R4, R0
239:           	(t->sin) = library_sin(t->ang);
62E4  288805     LDRH R5, [R0]
62E6  4B030028     MOVS R0, R5
62E8  47984B03     LDR R3, $d
62EA  80604798     BLX R3
62EC  288060     STRH R0, [R4, #2]
240:           	(t->cos) = library_cos(t->ang);
62EE  4B020028     MOVS R0, R5
62F0  47984B02     LDR R3, [PC, #8]
62F2  80A04798     BLX R3
62F4  BD7080A0     STRH R0, [R4, #4]
241:           }
62F6  6181BD70     POP {R4, R5, R6, PC}
62F8  6181     STR R1, [R0, #24]
62FA  5FD10000     MOVS R0, R0
62FC  5FD1     LDRSH R1, [R2, R7]
62FE  B5100000     MOVS R0, R0
242:           
243:           /******************************************************************************
244:           Function:		library_sinarcos
245:           Description:	y = BASE_VALUE * sin(arcos(x / BASE_VALUE))
246:           Input:			normalized cos(angle) value x, 0 <= x <= BASE_VALUE
247:           Output:			normalized sin(angle) value y, 0 <= y <= BASE_VALUE
248:           Revision:		1.0
249:           ******************************************************************************/
250:            int16_t library_sinarcos(int16_t x)
251:           {
5EBC  3B510     PUSH {R4, LR}
5EBE  B2810003     MOVS R3, R0
252:           	int16_t		y;
253:                   int16_t         x_temp;
254:           	x_temp = x;
255:                   if((-(int16_t)BASE_VALUE_INT >= x) || ((int16_t)BASE_VALUE_INT <= x))
5EC0  4A09B281     UXTH R1, R0
5EC2  188A4A09     LDR R2, [PC, #36]
5EC4  4C09188A     ADDS R2, R1, R2
5EC6  B2924C09     LDR R4, [PC, #36]
5EC8  2000B292     UXTH R2, R2
5ECC  D80642A2     CMP R2, R4
5ECE  2B00D806     BHI.N .LVL32
256:           	{
257:           		y = 0;
5ECA  42A22000     MOVS R0, #0
258:           	}
259:           	else
260:           	{
261:           		if(0 > x)
5ED0  DB052B00     CMP R3, #0
5ED2  B29BDB05     BLT.N .LVL33
262:           		{
263:           			x_temp = -x;
5EE0  B21B424B     RSBS R1, R3, #0
264:           		}
265:           		y = (int16_t)library_tbsac[((uint16_t)x_temp) >> (uint16_t)SH_SACTAB];
5ED4  99BB29B     UXTH R3, R3
5ED6  5B099B     LSRS R3, R3, #6
5ED8  4A05005B     LSLS R3, R3, #1
5EDA  5E984A05     LDR R2, [PC, #20]
5EDC  BD105E98     LDRSH R0, [R3, R2]
266:           	}
267:           	return (y);
268:           }
5EDE  424BBD10     POP {R4, PC}
5EE0  B21B424B     RSBS R1, R3, #0
5EE2  E7F6B21B     SXTH R3, R3
5EE4  46C0E7F6     B.N .LVL30
5EE6  3FFF46C0     MOV R8, R8
5EE8  3FFF     SUBS R7, #255
5EEA  7FFE0000     MOVS R0, R0
5EEC  7FFE     LDRB R6, [R7, #31]
5EEE  3DC80000     MOVS R0, R0
5EF0  3DC8     SUBS R5, #200
5EF2  B5700000     MOVS R0, R0
269:           
270:           /******************************************************************************
271:           Function:		library_atan2
272:           Description:	ang = (PI / FLOAT_PI) * arctan(y / x)
273:           Input:			amplified value x = A * cos(angle),
274:           				amplified value y = A * sin(angle),
275:           					0 < A < 2^15
276:           Output:			internal representation of angle: ang = (PI / FLOAT_PI) * angle
277:           Revision:		1.0
278:           ******************************************************************************/
279:            uint16_t library_atan2(int16_t x, int16_t y)
280:           {
4AC0  2900B570     PUSH {R4, R5, R6, LR}
281:           	uint32_t u32a;
282:            	uint16_t u16a, off, sgn, a, b;
283:           
284:           	if(0 == y)
4AC2  D1022900     CMP R1, #0
4AC4  FC0D102     BNE.N .LVL38
285:           	{
286:           		if(0 > x)
287:           		{
288:           			u16a = PI;
289:           		}
290:           		else
291:           		{
292:           			u16a = 0;
4AC6  3C00FC0     LSRS R0, R0, #31
4AC8  BD7003C0     LSLS R0, R0, #15
293:           		}
294:           	}
295:           	else if(0 == x)
4ACC  D1042800     CMP R0, #0
4ACE  2900D104     BNE.N .LVL40
296:           	{
297:           		if(0 > y)
4AD0  DB4F2900     CMP R1, #0
4AD2  2080DB4F     BLT.N 0x4A74
298:           		{
299:           			u16a = THREEPIHALVES;
4B74  20020C0     MOVS R0, #192
4B76  E7A70200     LSLS R0, R0, #8
300:           		}
301:           		else
302:           		{
303:           			u16a = PIHALVES;
4AD4  1C02080     MOVS R0, #128
4AD6  E7F701C0     LSLS R0, R0, #7
4AD8  2900E7F7     B.N .LVL37
304:           		}
305:           	}
306:           	else
307:           	{
308:           		if(0 > y)
4ADA  DB0C2900     CMP R1, #0
4ADC  B289DB0C     BLT.N .LVL48
309:           		{
310:           			if(-32768 == y)
4AF8  42994B24     LDR R3, $d
4AFA  D0184299     CMP R1, R3
4AFC  4249D018     BEQ.N .LVL63
311:           			{
312:           				b = 32767;
4B30  E7E64919     LDR R1, [PC, #100]
4B32  4B15E7E6     B.N .LVL50
313:           			}
314:           			else
315:           			{
316:           				b = (uint16_t)-y;
4AFE  B2894249     RSBS R1, R1, #0
4B00  2800B289     UXTH R1, R1
317:           			}
318:           			if(0 > x)	// x < 0, y < 0
4B02  DB162800     CMP R0, #0
4B04  B283DB16     BLT.N .LVL65
319:           			{
320:           				if(-32768 == x)
4B34  42984B15     LDR R3, $d
4B36  D0234298     CMP R0, R3
4B38  4243D023     BEQ.N .LVL81
321:           				{
322:           					a = 32767;
4B82  24804B05     LDR R3, [PC, #20]
323:           				}
324:           				else
325:           				{
326:           					a = (uint16_t)-x;
4B3A  B29B4243     RSBS R0, R3, #0
4B3C  2480B29B     UXTH R3, R3
327:           				}
328:           				off = PI;
4B3E  2242480     MOVS R4, #128
4B40  E7D10224     LSLS R4, R4, #8
4B42  4B11E7D1     B.N .LVL43
4B84  2242480     MOVS R4, #128
329:           				sgn = 0;
330:           			}
331:           			else		// x > 0, y < 0
332:           			{
333:           				a = (uint16_t)x;
4B06  2400B283     UXTH R3, R0
334:           				off = 0;
4B08  428B2400     MOVS R4, #0
335:           				sgn = 1;
336:           			}
337:           		}
338:           		else
339:           		{
340:           			b = (uint16_t)y;
4ADE  2800B289     UXTH R1, R1
341:           			if(0 > x)	// x < 0, y > 0
4AE0  DB2F2800     CMP R0, #0
4AE2  B283DB2F     BLT.N .LVL67
342:           			{
343:           				if(-32768 == x)
4B44  42984B11     LDR R3, $d
4B46  D0174298     CMP R0, R3
4B48  4243D017     BEQ.N .LVL80
344:           				{
345:           					a = 32767;
4B7A  24804B07     LDR R3, [PC, #28]
346:           				}
347:           				else
348:           				{
349:           					a = (uint16_t)-x;
4B4A  B29B4243     RSBS R0, R3, #0
4B4C  2480B29B     UXTH R3, R3
350:           				}
351:           				off = PI;
4B4E  2242480     MOVS R4, #128
4B50  E7DA0224     LSLS R4, R4, #8
4B52  398E7DA     B.N .LVL52
4B7C  2242480     MOVS R4, #128
4B7E  E7C30224     LSLS R4, R4, #8
4B80  4B05E7C3     B.N .LVL52
352:           				sgn = 1;
353:           			}
354:           			else		// x > 0, y > 0
355:           			{
356:           				a = (uint16_t)x;
4AE4  2400B283     UXTH R3, R0
357:           				off = 0;
4AE6  25002400     MOVS R4, #0
358:           				sgn = 0;
359:           			}
360:           		}
361:           		if(b == a)
4AE8  428B2500     MOVS R5, #0
4AEA  D110428B     CMP R3, R1
4AEC  2080D110     BNE.N .LVL53
4B0A  D02F428B     CMP R3, R1
4B0C  2501D02F     BEQ.N .LVL75
4B0E  428B2501     MOVS R5, #1
362:           		{
363:           			u16a = PIFOURTHS;
4AEE  1802080     MOVS R0, #128
4AF0  19000180     LSLS R0, R0, #6
4B6E  1802080     MOVS R0, #128
4B70  E7DA0180     LSLS R0, R0, #6
4B72  20C0E7DA     B.N 0x4B2A
364:           		}
365:           		else if(b < a)
4B10  D91F428B     CMP R3, R1
4B12  388D91F     BLS.N .LVL69
366:           		{
367:           			u32a = (uint32_t)b * (uint32_t)BASE_VALUE_INT;
4B14  190388     LSLS R0, R1, #14
368:           			u16a = (uint16_t)(u32a / a);
4B16  4B1D0019     MOVS R1, R3
4B18  47984B1D     LDR R3, [PC, #116]
4B1A  B2804798     BLX R3
369:           			u16a = (uint16_t)library_tbact[u16a >> (uint16_t)SH_ACTTAB];
4B1C  980B280     UXTH R0, R0
4B1E  400980     LSRS R0, R0, #6
4B20  4B1C0040     LSLS R0, R0, #1
4B22  5A184B1C     LDR R3, [PC, #112]
4B24  2D005A18     LDRH R0, [R3, R0]
370:           		}
371:           		else
372:           		{
373:           			u32a = (uint32_t)a * (uint32_t)BASE_VALUE_INT;
4B54  4B0E0398     LSLS R0, R3, #14
374:           			u16a = (uint16_t)(u32a / b);
4B56  47984B0E     LDR R3, [PC, #56]
4B58  B2804798     BLX R3
375:           			u16a = (uint16_t)library_tbact[u16a >> (uint16_t)SH_ACTTAB];
4B5A  980B280     UXTH R0, R0
4B5C  400980     LSRS R0, R0, #6
4B5E  4B0C0040     LSLS R0, R0, #1
4B60  5A1B4B0C     LDR R3, [PC, #48]
4B62  20805A1B     LDRH R3, [R3, R0]
376:           			u16a = PIHALVES - u16a;	
4B64  1C02080     MOVS R0, #128
4B66  1AC001C0     LSLS R0, R0, #7
4B68  B2801AC0     SUBS R0, R0, R3
4B6A  E7DBB280     UXTH R0, R0
4B6C  2080E7DB     B.N .LVL59
377:                                   /* overflow is OK here! */
378:           		}
379:           		if(0U != sgn)
4B26  D0E32D00     CMP R5, #0
4B28  1A20D0E3     BEQ.N .LVL45
380:           		{
381:           			u16a = off - u16a;		// overflow is OK here!
4B2A  B2801A20     SUBS R0, R4, R0
4B2C  E7CCB280     UXTH R0, R0
4B2E  4919E7CC     B.N .LVL37
382:           		}
383:           		else
384:           		{
385:           			u16a = off + u16a;		// overflow is OK here!
4AF2  B2801900     ADDS R0, R0, R4
4AF4  E7E8B280     UXTH R0, R0
4AF6  4B24E7E8     B.N .LVL37
386:           		}
387:           	}
388:           	return(u16a);
4B78  4B07E7A7     B.N .LVL37
389:           
390:           }	/* end of function library_atan2(...) */
4ACA  2800BD70     POP {R4, R5, R6, PC}
4ACC  D1042800     CMP R0, #0
4ACE  2900D104     BNE.N .LVL40
4AD0  DB4F2900     CMP R1, #0
4AD2  2080DB4F     BLT.N 0x4A74
4AD4  1C02080     MOVS R0, #128
4AD6  E7F701C0     LSLS R0, R0, #7
4AD8  2900E7F7     B.N .LVL37
4ADA  DB0C2900     CMP R1, #0
4ADC  B289DB0C     BLT.N .LVL48
4ADE  2800B289     UXTH R1, R1
4AE0  DB2F2800     CMP R0, #0
4AE2  B283DB2F     BLT.N .LVL67
4AE4  2400B283     UXTH R3, R0
4AE6  25002400     MOVS R4, #0
4AE8  428B2500     MOVS R5, #0
4AEA  D110428B     CMP R3, R1
4AEC  2080D110     BNE.N .LVL53
4AEE  1802080     MOVS R0, #128
4AF0  19000180     LSLS R0, R0, #6
4AF2  B2801900     ADDS R0, R0, R4
4AF4  E7E8B280     UXTH R0, R0
4AF6  4B24E7E8     B.N .LVL37
4AF8  42994B24     LDR R3, $d
4AFA  D0184299     CMP R1, R3
4AFC  4249D018     BEQ.N .LVL63
4AFE  B2894249     RSBS R1, R1, #0
4B00  2800B289     UXTH R1, R1
4B02  DB162800     CMP R0, #0
4B04  B283DB16     BLT.N .LVL65
4B06  2400B283     UXTH R3, R0
4B08  428B2400     MOVS R4, #0
4B0A  D02F428B     CMP R3, R1
4B0C  2501D02F     BEQ.N .LVL75
4B0E  428B2501     MOVS R5, #1
4B10  D91F428B     CMP R3, R1
4B12  388D91F     BLS.N .LVL69
4B14  190388     LSLS R0, R1, #14
4B16  4B1D0019     MOVS R1, R3
4B18  47984B1D     LDR R3, [PC, #116]
4B1A  B2804798     BLX R3
4B1C  980B280     UXTH R0, R0
4B1E  400980     LSRS R0, R0, #6
4B20  4B1C0040     LSLS R0, R0, #1
4B22  5A184B1C     LDR R3, [PC, #112]
4B24  2D005A18     LDRH R0, [R3, R0]
4B26  D0E32D00     CMP R5, #0
4B28  1A20D0E3     BEQ.N .LVL45
4B2A  B2801A20     SUBS R0, R4, R0
4B2C  E7CCB280     UXTH R0, R0
4B2E  4919E7CC     B.N .LVL37
4B30  E7E64919     LDR R1, [PC, #100]
4B32  4B15E7E6     B.N .LVL50
4B34  42984B15     LDR R3, $d
4B36  D0234298     CMP R0, R3
4B38  4243D023     BEQ.N .LVL81
4B3A  B29B4243     RSBS R0, R3, #0
4B3C  2480B29B     UXTH R3, R3
4B3E  2242480     MOVS R4, #128
4B40  E7D10224     LSLS R4, R4, #8
4B42  4B11E7D1     B.N .LVL43
4B44  42984B11     LDR R3, $d
4B46  D0174298     CMP R0, R3
4B48  4243D017     BEQ.N .LVL80
4B4A  B29B4243     RSBS R0, R3, #0
4B4C  2480B29B     UXTH R3, R3
4B4E  2242480     MOVS R4, #128
4B50  E7DA0224     LSLS R4, R4, #8
4B52  398E7DA     B.N .LVL52
4B54  4B0E0398     LSLS R0, R3, #14
4B56  47984B0E     LDR R3, [PC, #56]
4B58  B2804798     BLX R3
4B5A  980B280     UXTH R0, R0
4B5C  400980     LSRS R0, R0, #6
4B5E  4B0C0040     LSLS R0, R0, #1
4B60  5A1B4B0C     LDR R3, [PC, #48]
4B62  20805A1B     LDRH R3, [R3, R0]
4B64  1C02080     MOVS R0, #128
4B66  1AC001C0     LSLS R0, R0, #7
4B68  B2801AC0     SUBS R0, R0, R3
4B6A  E7DBB280     UXTH R0, R0
4B6C  2080E7DB     B.N .LVL59
4B6E  1802080     MOVS R0, #128
4B70  E7DA0180     LSLS R0, R0, #6
4B72  20C0E7DA     B.N 0x4B2A
4B74  20020C0     MOVS R0, #192
4B76  E7A70200     LSLS R0, R0, #8
4B78  4B07E7A7     B.N .LVL37
4B7A  24804B07     LDR R3, [PC, #28]
4B7C  2242480     MOVS R4, #128
4B7E  E7C30224     LSLS R4, R4, #8
4B80  4B05E7C3     B.N .LVL52
4B82  24804B05     LDR R3, [PC, #20]
4B84  2242480     MOVS R4, #128
4B86  E7AE0224     LSLS R4, R4, #8
4B88  46C0E7AE     B.N .LVL43
4B8A  800046C0     MOV R8, R8
4B8C  FFFF8000     STRH R0, [R0]
4B8E  44D9FFFF     MRC2 P4, #7, R4, CR15, CR9, {6}
4B90  44D9     ADD R9, R11
4B92  3BC40000     MOVS R0, R0
4B94  3BC4     SUBS R3, #196
4B96  7FFF0000     MOVS R0, R0
4B98  7FFF     LDRB R7, [R7, #31]
4B9A  47700000     MOVS R0, R0
391:           
392:           /******************************************************************************
393:           Function:		library_scat
394:           Description:	calculation of the second cathetus of a right angled triangle
395:           				(pythagoras theorem)
396:           Input:			hypotenuse hypo
397:           				first cathetus fcat
398:           Output:			second cathetus
399:           Notes:			if the first cathetus is negative, its absolute value is
400:           				considered;
401:           				if the first cathetus absolute value is greater or equal than
402:           				the hypotenuse, the result will be zero (as a consequence, if
403:           				the hypotenuse is zero or negative, the result will be zero)
404:           ******************************************************************************/
405:            int16_t library_scat(int16_t hypo, int16_t fcat)
406:           {
5CCC  4B510     PUSH {R4, LR}
5CCE  29000004     MOVS R4, R0
407:           	int32_t s32a;
408:           	int16_t	s16a;
409:                   int16_t fcat_temp;
410:                   fcat_temp = fcat;
411:           	if(0 > fcat_temp)
5CD0  DB0C2900     CMP R1, #0
5CD2  42A1DB0C     BLT.N .LVL93
412:           	{
413:           		if(-32768 == fcat_temp)
5CEE  42994B07     LDR R3, [PC, #28]
5CF0  D0024299     CMP R1, R3
5CF2  4249D002     BEQ.N .LVL96
414:           		{
415:           			fcat_temp = 32767;
416:           		}
417:           		else
418:           		{
419:           			fcat_temp = -fcat_temp;
5CF4  B2094249     RSBS R1, R1, #0
420:           		}
421:           	}
422:           	if(fcat_temp < hypo)
5CD4  DA1242A1     CMP R1, R4
5CD6  388DA12     BGE.N .LVL98
423:           	{
424:           		s32a = ((int32_t)fcat_temp) * (int32_t)BASE_VALUE_INT;
5CD8  210388     LSLS R0, R1, #14
425:           		s16a = (int16_t)(s32a / hypo);
5CDA  4B090021     MOVS R1, R4
5CDC  47984B09     LDR R3, $d
5CDE  B2004798     BLX R3
5CE0  4B09B200     SXTH R0, R0
426:           		s16a = library_sinarcos(s16a);
5CE2  47984B09     LDR R3, [PC, #36]
5CE4  43604798     BLX R3
427:           		s32a = ((int32_t)s16a) * ((int32_t)hypo);
5CE6  13804360     MULS R0, R4
428:           		/*lint -save -e9027*/
429:                           s16a = (int16_t)(s32a >> SH_BASE_VALUE);
5CE8  B2001380     ASRS R0, R0, #14
430:                           /*lint -restore*/
431:           	}
432:           	else
433:           	{
434:           		s16a = 0;
435:           	}
436:           	return(s16a);
5CEA  BD10B200     SXTH R0, R0
437:           }
5CEC  4B07BD10     POP {R4, PC}
5CEE  42994B07     LDR R3, [PC, #28]
5CF0  D0024299     CMP R1, R3
5CF2  4249D002     BEQ.N .LVL96
5CF4  B2094249     RSBS R1, R1, #0
5CF6  E7ECB209     SXTH R1, R1
5CF8  2000E7EC     B.N .LVL84
5CFA  E7F52000     MOVS R0, #0
5CFC  2000E7F5     B.N .LVL92
5CFE  E7F32000     MOVS R0, #0
5D00  46C0E7F3     B.N .LVL92
5D02  41D146C0     MOV R8, R8
5D04  41D1     RORS R1, R2
5D06  5EBD0000     MOVS R0, R0
5D08  5EBD     LDRSH R5, [R7, R2]
5D0A  80000000     MOVS R0, R0
5D0C  FFFF8000     STRH R0, [R0]
5D0E  F3BFFFFF     MRC2 P3, #7, PC, CR15, CR15, {5}
438:           
439:           /******************************************************************************
440:           Function:		library_uvw_ab
441:           Description:	unitary gain transformation (u, v, w)->(alpha, beta):
442:           					alpha=(2u-v-w)/3, beta=(v-w)/sqrt(3)
443:           Input:			uvw, input vector structure address
444:           				ab, output vector structure address
445:           Output:			nothing
446:           Modifies:		x (a), y (b) components of ab vector
447:           Note:			no limitation (homopolar component kept into account)
448:           Revision:		1.0
449:           ******************************************************************************/
450:            void library_uvw_ab(const vec3_t *uvw, vec2_t *ab)
451:           {
5C3C  2300B530     PUSH {R4, R5, LR}
452:           	int32_t	s32a;
453:           
454:           	/* alpha, direct component in the static reference frame */
455:           	s32a = ((int32_t)(uvw->u)) * TWOTHIRDS;
5C3E  5EC42300     MOVS R3, #0
5C40  4A0C5EC4     LDRSH R4, [R0, R3]
5C42  43544A0C     LDR R2, [PC, #48]
5C44  23024354     MULS R4, R2
456:           	s32a -= (((int32_t)(uvw->v)) * ONETHIRD);
5C46  5EC22302     MOVS R3, #2
5C48  4B0B5EC2     LDRSH R2, [R0, R3]
5C4A  435A4B0B     LDR R3, [PC, #44]
5C4C  1912435A     MULS R2, R3
5C4E  25041912     ADDS R2, R2, R4
457:           	s32a -= (((int32_t)(uvw->w)) * ONETHIRD);
5C50  5F442504     MOVS R5, #4
5C52  43635F44     LDRSH R4, [R0, R5]
5C54  189B4363     MULS R3, R4
5C56  139B189B     ADDS R3, R3, R2
458:           	/*lint -save -e9027*/
459:                   (ab->x) = (int16_t)(s32a >> SH_BASE_VALUE);
5C58  800B139B     ASRS R3, R3, #14
5C5A  2302800B     STRH R3, [R1]
460:           
461:           	/* beta, quadrature component in the static reference frame */
462:           	s32a = (((int32_t)(uvw->v)) * ONEBYSQRT3);
5C5C  5EC22302     MOVS R3, #2
5C5E  4B065EC2     LDRSH R2, [R0, R3]
5C60  435A4B06     LDR R3, [PC, #24]
5C62  2304435A     MULS R2, R3
463:           	s32a -= (((int32_t)(uvw->w)) * ONEBYSQRT3);
5C64  5EC02304     MOVS R3, #4
5C66  4B055EC0     LDRSH R0, [R0, R3]
5C68  43434B05     LDR R3, [PC, #20]
5C6A  189B4343     MULS R3, R0
5C6C  139B189B     ADDS R3, R3, R2
464:           	(ab->y) = (int16_t)(s32a >> SH_BASE_VALUE);
5C6E  804B139B     ASRS R3, R3, #14
5C70  BD30804B     STRH R3, [R1, #2]
465:                   /*lint -restore */
466:           }
5C72  2AABBD30     POP {R4, R5, PC}
5C74  2AAB     CMP R2, #171
5C76  EAAB0000     MOVS R0, R0
5C7A  24F3FFFF     MRC2 P4, #7, R2, CR15, CR3, {7}
5C7C  24F3     MOVS R4, #243
5C7E  DB0D0000     MOVS R0, R0
5C80  FFFFDB0D     BLT.N .LVL4
5C82  B570FFFF     MRC2 P5, #7, R11, CR15, CR0, {3}
467:           
468:           /******************************************************************************
469:           Function:		library_ab_uvw
470:           Description:	unitary gain transformation (alpha, beta)->(u, v, w):
471:           					u=alpha, v=((sqrt(3)*beta-alpha)/2, w=-u-v
472:           Input:			ab, input vector structure address
473:           				uvw, output vector structure address
474:           Modifies:		u, v, w components of uvw vector
475:           Revision:		1.0
476:           ******************************************************************************/
477:            #ifdef RAM_EXECUTE
478:           void __ramfunc__ library_ab_uvw(const vec2_t *ab, vec3_t *uvw)
479:           #else
480:           void library_ab_uvw(const vec2_t *ab, vec3_t *uvw)
481:           #endif
482:           {
622C  2300B510     PUSH {R4, LR}
483:           	int32_t s32a;
484:           
485:           	/* u */
486:           	(uvw->u) = (ab->x);
622E  5EC22300     MOVS R3, #0
6230  800A5EC2     LDRSH R2, [R0, R3]
6232  2302800A     STRH R2, [R1]
487:           
488:           	/* v */
489:           	s32a = ((int32_t)(ab->y)) * SQRT3;
6234  5EC42302     MOVS R3, #2
6236  4B055EC4     LDRSH R4, [R0, R3]
6238  43634B05     LDR R3, $d
623A  139B4363     MULS R3, R4
490:           	/*lint -save -e9027*/
491:                   s32a >>= SH_BASE_VALUE;
623C  2400139B     ASRS R3, R3, #14
492:           	s32a -= (ab->x);
623E  5F002400     MOVS R4, #0
6240  1A1B5F00     LDRSH R0, [R0, R4]
6242  105B1A1B     SUBS R3, R3, R0
493:           	
494:                   (uvw->v) = (int16_t)(s32a >> 1);
6244  804B105B     ASRS R3, R3, #1
6246  18D3804B     STRH R3, [R1, #2]
495:                   /*lint -restore */
496:           
497:           	/* w */
498:           	(uvw->w) = -(uvw->u) - (uvw->v);
6248  425B18D3     ADDS R3, R2, R3
624A  808B425B     RSBS R3, R3, #0
624C  BD10808B     STRH R3, [R1, #4]
499:           }
624E  6EDABD10     POP {R4, PC}
6250  6EDA     LDR R2, [R3, #108]
6252  B5000000     MOVS R0, R0
500:           
501:           /******************************************************************************
502:           Function:		library_ab_dq
503:           Description:	unitary gain transformation (alpha, beta)->(d, q):
504:           					d=alpha*cos(internal_angle)+beta*sin(internal_angle)
505:           					q=alpha*cos(internal_angle)-beta*sin(internal_angle)
506:           Input:			t, angle structure address, where t->ang is the angular
507:           					position of (d, q) reference system
508:           				ab, input vector structure address
509:           				dq, output vector structure address
510:           Output:			nothing
511:           Modifies:		x (d), y (q) components of dq vector
512:           Revision:		1.0
513:           ******************************************************************************/
514:            void library_ab_dq(const ang_sincos_t *t, const vec2_t *ab, vec2_t *dq)
515:           {
5EF4  2300B570     PUSH {R4, R5, R6, LR}
516:           	int32_t s32a;
517:                    /*lint -save -e9027*/
518:           	/* d, direct component in the rotating reference frame */
519:           	s32a = ((int32_t)(ab->x)) * ((int32_t)(t->cos));
5EF6  5ECC2300     MOVS R3, #0
5EF8  25045ECC     LDRSH R4, [R1, R3]
5EFA  5F432504     MOVS R5, #4
5EFC  435C5F43     LDRSH R3, [R0, R5]
5EFE  2302435C     MULS R4, R3
520:           	s32a += (((int32_t)(ab->y)) * ((int32_t)(t->sin)));
5F00  5ECD2302     MOVS R3, #2
5F02  26025ECD     LDRSH R5, [R1, R3]
5F04  5F832602     MOVS R6, #2
5F06  436B5F83     LDRSH R3, [R0, R6]
5F08  191B436B     MULS R3, R5
5F0A  139B191B     ADDS R3, R3, R4
521:           	(dq->x) = (int16_t)(s32a >> SH_BASE_VALUE);
5F0C  8013139B     ASRS R3, R3, #14
5F0E  23028013     STRH R3, [R2]
522:           
523:           	/* q, quadrature current component in the rotating reference frame */
524:           	s32a = ((int32_t)(ab->y)) * ((int32_t)(t->cos));
5F10  5ECC2302     MOVS R3, #2
5F12  25045ECC     LDRSH R4, [R1, R3]
5F14  5F432504     MOVS R5, #4
5F16  435C5F43     LDRSH R3, [R0, R5]
5F18  2300435C     MULS R4, R3
525:           	s32a -= (((int32_t)(ab->x)) * ((int32_t)(t->sin)));
5F1A  5EC92300     MOVS R3, #0
5F1C  23025EC9     LDRSH R1, [R1, R3]
5F1E  5EC32302     MOVS R3, #2
5F20  434B5EC3     LDRSH R3, [R0, R3]
5F22  1AE3434B     MULS R3, R1
5F24  139B1AE3     SUBS R3, R4, R3
526:           	(dq->y) = (int16_t)(s32a >> SH_BASE_VALUE);
5F26  8053139B     ASRS R3, R3, #14
5F28  BD708053     STRH R3, [R2, #2]
527:                   /*lint -restore */
528:           }
5F2A  B570BD70     POP {R4, R5, R6, PC}
529:           
530:           /******************************************************************************
531:           Function:		library_dq_ab
532:           Description:	unitary gain transformation (d, q)->(alpha, beta):
533:           					alpha=d*cos(internal_angle)-q*sin(internal_angle)
534:           					beta=d*sin(internal_angle)+q*cos(internal_angle)
535:           Input:			t, angle structure address, where t->ang is the angular
536:           					position of (d, q) reference system
537:           				dq, input vector structure address
538:           				ab, output vector structure address
539:           Output:			nothing
540:           Modifies:		x (a), y (b) components of ab vector
541:           Revision:		1.0
542:           ******************************************************************************/
543:            void library_dq_ab(const ang_sincos_t *t, const vec2_t *dq, vec2_t *ab)
544:           {
5F2C  2300B570     PUSH {R4, R5, R6, LR}
545:           	int32_t s32a;
546:                     /*lint -save -e9027*/
547:           	/* alpha, direct component in the static reference frame */
548:           	s32a = ((int32_t)(dq->x)) * ((int32_t)(t->cos));
5F2E  5ECC2300     MOVS R3, #0
5F30  25045ECC     LDRSH R4, [R1, R3]
5F32  5F432504     MOVS R5, #4
5F34  435C5F43     LDRSH R3, [R0, R5]
5F36  2302435C     MULS R4, R3
549:           	s32a -= (((int32_t)(dq->y)) * ((int32_t)(t->sin)));
5F38  5ECD2302     MOVS R3, #2
5F3A  26025ECD     LDRSH R5, [R1, R3]
5F3C  5F832602     MOVS R6, #2
5F3E  436B5F83     LDRSH R3, [R0, R6]
5F40  1AE3436B     MULS R3, R5
5F42  139B1AE3     SUBS R3, R4, R3
550:           	(ab->x) = (int16_t)(s32a >> SH_BASE_VALUE);
5F44  8013139B     ASRS R3, R3, #14
5F46  23008013     STRH R3, [R2]
551:           
552:           	/* beta, quadrature component in the static reference frame */
553:           	s32a = ((int32_t)(dq->x)) * ((int32_t)(t->sin));
5F48  5ECC2300     MOVS R3, #0
5F4A  25025ECC     LDRSH R4, [R1, R3]
5F4C  5F432502     MOVS R5, #2
5F4E  435C5F43     LDRSH R3, [R0, R5]
5F50  2302435C     MULS R4, R3
554:           	s32a += (((int32_t)(dq->y)) * ((int32_t)(t->cos)));
5F52  5EC92302     MOVS R3, #2
5F54  23045EC9     LDRSH R1, [R1, R3]
5F56  5EC32304     MOVS R3, #4
5F58  434B5EC3     LDRSH R3, [R0, R3]
5F5A  191B434B     MULS R3, R1
5F5C  139B191B     ADDS R3, R3, R4
555:           	(ab->y) = (int16_t)(s32a >> SH_BASE_VALUE);
5F5E  8053139B     ASRS R3, R3, #14
5F60  BD708053     STRH R3, [R2, #2]
556:                   /*lint -restore */
557:           }
5F62  B510BD70     POP {R4, R5, R6, PC}
558:           
559:           /******************************************************************************
560:           Function:		library_xy_rt
561:           Description:	transformation (x, y)->(ro, theta) [cartesian to polar coordinates]
562:           Input:			xy, input vector structure address
563:           				rt, output vector structure address
564:           Output:			nothing
565:           Modifies:		r (amplitude), t (argument) components of rt vector
566:           Revision:		1.0
567:           ******************************************************************************/
568:            void library_xy_rt(const vec2_t *xy, vecp_t *rt)
569:           {
5844  5B570     PUSH {R4, R5, R6, LR}
5846  C0005     MOVS R5, R0
5848  2302000C     MOVS R4, R1
570:           	int32_t	s32a;
571:                   int16_t temp;
572:           
573:           	((rt->t).ang) = library_atan2(xy->x, xy->y);
584A  5EC12302     MOVS R3, #2
584C  23005EC1     LDRSH R1, [R0, R3]
584E  5EC02300     MOVS R3, #0
5850  4B115EC0     LDRSH R0, [R0, R3]
5852  47984B11     LDR R3, [PC, #68]
5854  80604798     BLX R3
5856  1CA08060     STRH R0, [R4, #2]
574:           	library_sincos(&(rt->t));
5858  4B101CA0     ADDS R0, R4, #2
585A  47984B10     LDR R3, [PC, #64]
585C  88634798     BLX R3
575:           	if(	((PIFOURTHS < (rt->t).ang)	&& (THREEPIFOURTHS > (rt->t).ang)) ||
585E  45B8863     LDRH R3, [R4, #2]
5860  C5B045B     LSLS R3, R3, #17
5862  4A0E0C5B     LSRS R3, R3, #17
5864  46944A0E     LDR R2, [PC, #56]
5866  44634694     MOV R12, R2
5868  4A0E4463     ADD R3, R12
586A  B29B4A0E     LDR R2, [PC, #56]
586C  4293B29B     UXTH R3, R3
586E  D9084293     CMP R3, R2
5870  2300D908     BLS.N .LVL136
576:           		((FIVEPIFOURTHS < (rt->t).ang)	&& (SEVENPIFOURTHS > (rt->t).ang)) )
577:           	{	/* |sin(ang)|>|cos(ang)| */
578:           		s32a = ((int32_t)(xy->y)) * (int32_t)BASE_VALUE_INT;
5884  5EE82302     MOVS R3, #2
5886  3805EE8     LDRSH R0, [R5, R3]
5888  23040380     LSLS R0, R0, #14
579:           		temp =  (int16_t)(s32a / ((rt->t).sin)) ;
588A  5EE12304     MOVS R3, #4
588C  4B065EE1     LDRSH R1, [R4, R3]
588E  47984B06     LDR R3, [PC, #24]
5890  80204798     BLX R3
580:                           (rt->r) = (uint16_t) temp;
5892  BD708020     STRH R0, [R4]
581:           	}
582:           	else
583:           	{	/* |sin(ang)|<=|cos(ang)|*/
584:           		s32a = ((int32_t)(xy->x)) * (int32_t)BASE_VALUE_INT;
5872  5EE82300     MOVS R3, #0
5874  3805EE8     LDRSH R0, [R5, R3]
5876  23060380     LSLS R0, R0, #14
585:           		temp =  (int16_t)(s32a / ((rt->t).cos)) ;
5878  5EE12306     MOVS R3, #6
587A  4B0A5EE1     LDRSH R1, [R4, R3]
587C  47984B0A     LDR R3, [PC, #40]
587E  80204798     BLX R3
586:                           (rt->r) = (uint16_t)temp;
5880  E0078020     STRH R0, [R4]
5882  2302E007     B.N .LVL139, .LVL140
587:           	}
588:           }
5894  46C0BD70     POP {R4, R5, R6, PC}
5896  4AC146C0     MOV R8, R8
5898  4AC1     LDR R2, [PC, #772]
589A  62E10000     MOVS R0, R0
589C  62E1     STR R1, [R4, #44]
589E  DFFF0000     MOVS R0, R0
58A0  FFFFDFFF     SVC 255
58A2  3FFEFFFF     MRC2 P15, #7, R3, CR15, CR14, {7}
58A4  3FFE     SUBS R7, #254
58A6  41D10000     MOVS R0, R0
58A8  41D1     RORS R1, R2
58AA  B5100000     MOVS R0, R0
589:           
590:           /******************************************************************************
591:           Function:		library_rt_xy
592:           Description:	transformation (ro, theta)->(x, y) [polar to cartesian coordinates]
593:           Input:			rt, input vector structure address
594:           				xy, output vector structure address
595:           Output:			nothing
596:           Modifies:		x, y components of xy vector
597:           Revision:		1.0
598:           ******************************************************************************/
599:            void library_rt_xy(const vecp_t *rt, vec2_t *xy)
600:           {
0000  20007FF8     LDRB R0, [R7, #31]
601:           	int32_t	s32a;
602:                   /*lint -save -e9027*/
603:           	if(32767U >= (rt->r))
0002  596D2000     MOVS R0, #0
604:           	{
605:           		s32a = ((int32_t)(rt->r)) * ((int32_t)((rt->t).cos));
000A  653F0000     MOVS R0, R0
606:           		(xy->x) = (int16_t)(s32a >> SH_BASE_VALUE);
0010  0000     MOVS R0, R0
607:           		s32a = ((int32_t)(rt->r)) * ((int32_t)((rt->t).sin));
0014  0000     MOVS R0, R0
608:           		(xy->y) = (int16_t)(s32a >> SH_BASE_VALUE);
001C  0000     MOVS R0, R0
609:           	}
610:           	else
611:           	{
612:           		(xy->x) = 0;
0022  0000     MOVS R0, R0
613:           		(xy->y) = 0;
0026  0000     MOVS R0, R0
614:           	}
615:                   /*lint -restore*/
616:           }
0020  0000     MOVS R0, R0
0028  0000     MOVS R0, R0
617:           
618:           /******************************************************************************
619:           Function:		library_pi_control
620:           Description:	PI control with anti-windup
621:           Input:			error erl
622:           				pointer to the pi control structure pi
623:           Output:			control output
624:           Modifies:		integral memory im of the control
625:           ******************************************************************************/
626:            int16_t library_pi_control(int32_t erl, pi_cntrl_t *pi)
627:           {
48F4  2800B570     PUSH {R4, R5, R6, LR}
628:           	int32_t s32i, s32p, s32t;
629:           	int16_t	s16e, s16t;
630:           
631:           	/*lint -save -e9027*/
632:                   if(0 < erl)
48F6  DD282800     CMP R0, #0
48F8  4B36DD28     BLE.N .LVL169
633:           	{
634:           		/* preliminary error clamp */
635:           		if(32767 < erl)
636:           		{
637:           			s16e = 32767;
638:           		}
639:           		else
640:           		{
641:           			s16e = (int16_t)erl;
642:           		}
643:           
644:           		/* integral term */
645:           		s32i = (int32_t)s16e * (int32_t)(pi->ki);
48FA  42984B36     LDR R3, [PC, #216]
48FC  DD004298     CMP R0, R3
48FE  18DD00     BLE.N .LVL152
4900  B2000018     MOVS R0, R3
4902  2204B200     SXTH R0, R0
4904  5E8B2204     MOVS R2, #4
4906  43435E8B     LDRSH R3, [R1, R2]
4908  88CA4343     MULS R3, R0
646:           		s32i >>= (pi->shi);
490A  411388CA     LDRH R2, [R1, #6]
490C  68CA4113     ASRS R3, R2
647:           		s32i += (pi->imem);
490E  469468CA     LDR R2, [R1, #12]
4910  44634694     MOV R12, R2
4912  24004463     ADD R3, R12
648:           
649:           		/* proportional term */
650:           		s32p = (int32_t)s16e * (int32_t)(pi->kp);
4914  5F0A2400     MOVS R4, #0
4916  43505F0A     LDRSH R2, [R1, R4]
4918  884D4350     MULS R0, R2
651:           
652:           		/* total control */
653:           		s32t = s32i + s32p;
491C  412C181C     ADDS R4, R3, R0
654:           		s16t = (int16_t)(s32t >> (pi->shp));
491A  181C884D     LDRH R5, [R1, #2]
491E  B224412C     ASRS R4, R5
4920  2608B224     SXTH R4, R4
4948  E7FA0022     MOVS R2, R4
494A  2800E7FA     B.N .LVL167
655:           
656:           		/* result clamp and integral memory update */
657:           		if(s16t > (pi->hlim))
4922  5F8A2608     MOVS R6, #8
4924  42945F8A     LDRSH R2, [R1, R6]
4926  DC074294     CMP R4, R2
4928  200ADC07     BGT.N .LVL163
658:           		{
659:           			s16t = (pi->hlim);
660:           			s32t = s16t;
661:           			s32t <<= (pi->shp);
493A  40AB0013     MOVS R3, R2
493C  1A1840AB     LSLS R3, R5
662:           			(pi->imem) = s32t - s32p;
493E  60C81A18     SUBS R0, R3, R0
4940  1060C8     STR R0, [R1, #12]
663:           		}
664:           		else if(s16t < (pi->llim))	/* case possible only if limit is changed */
492A  5E0A200A     MOVS R0, #10
492C  42945E0A     LDRSH R2, [R1, R0]
492E  DA094294     CMP R4, R2
4930  13DA09     BGE.N .LVL168
665:           		{
666:           			s16t = (pi->llim);
667:           			s32t = s16t;
668:           			(pi->imem) = s32t << (pi->shp);
4932  40AB0013     MOVS R3, R2
4934  60CB40AB     LSLS R3, R5
4936  E00360CB     STR R3, [R1, #12]
4938  13E003     B.N .LVL167
669:           		}
670:           		else
671:           		{
672:           			(pi->imem) = s32i;
4946  2260CB     STR R3, [R1, #12]
673:           		}
674:           	}
675:           	else if(0 > erl)
494C  DB102800     CMP R0, #0
494E  8848DB10     BLT.N .LVL173
676:           	{
677:           		/* preliminary error clamp */
678:           		if(-32767 > erl)
4972  42984B19     LDR R3, [PC, #100]
4974  DB024298     CMP R0, R3
4976  4240DB02     BLT.N .LVL176
679:           		{
680:           			s16e = 32767;
681:           		}
682:           		else
683:           		{
684:           			s16e = (int16_t) -erl;
4978  B2804240     RSBS R0, R0, #0
497A  E000B280     UXTH R0, R0
497C  4815E000     B.N .LVL177
497E  B2004815     LDR R0, [PC, #84]
685:           		}
686:           
687:           		/* integral term */
688:           		s32i = (int32_t)s16e * (int32_t)(pi->ki);
4980  2304B200     SXTH R0, R0
4982  5ECC2304     MOVS R3, #4
4984  43445ECC     LDRSH R4, [R1, R3]
4986  88CB4344     MULS R4, R0
689:           		s32i >>= (pi->shi);
4988  411C88CB     LDRH R3, [R1, #6]
498A  68CB411C     ASRS R4, R3
690:           		s32i -= (pi->imem);
498C  1AE468CB     LDR R3, [R1, #12]
498E  22001AE4     SUBS R4, R4, R3
691:           
692:           		/* proportional term */
693:           		s32p = (int32_t)s16e * (int32_t)(pi->kp);
4990  5E8B2200     MOVS R2, #0
4992  43435E8B     LDRSH R3, [R1, R2]
4994  884D4343     MULS R3, R0
694:           
695:           		/* total control */
696:           		s32t = s32i + s32p;
4998  412818E0     ADDS R0, R4, R3
697:           		s16t = (int16_t)(-(s32t >> (pi->shp)));
4996  18E0884D     LDRH R5, [R1, #2]
499A  42404128     ASRS R0, R5
499C  B2004240     RSBS R0, R0, #0
499E  260AB200     SXTH R0, R0
49C6  E7BB0002     MOVS R2, R0
49C8  1AE7BB     B.N .LVL167
698:           
699:           		/* result clamp and integral memory update */
700:           		if(s16t < (pi->llim))
49A0  5F8A260A     MOVS R6, #10
49A2  42905F8A     LDRSH R2, [R1, R6]
49A4  DB074290     CMP R0, R2
49A6  2608DB07     BLT.N .LVL187
701:           		{
702:           			s16t = (pi->llim);
703:           			s32t = s16t;
704:           			s32t <<= (pi->shp);
49B8  40A80010     MOVS R0, R2
49BA  18C040A8     LSLS R0, R5
705:           			(pi->imem) = s32t + s32p;
49BC  60C818C0     ADDS R0, R0, R3
49BE  E7BF60C8     STR R0, [R1, #12]
49C0  4264E7BF     B.N .LVL167
706:           		}
707:           		else if(s16t > (pi->hlim))	/* case possible only if limit is changed */
49A8  5F8B2608     MOVS R6, #8
49AA  42835F8B     LDRSH R3, [R1, R6]
49AC  DA084283     CMP R3, R0
49AE  13DA08     BGE.N .LVL190
708:           		{
709:           			s16t = (pi->llim);
710:           			s32t = s16t;
711:           			(pi->imem) = s32t << (pi->shp);
49B0  40AB0013     MOVS R3, R2
49B2  60CB40AB     LSLS R3, R5
49B4  E7C460CB     STR R3, [R1, #12]
49B6  10E7C4     B.N .LVL167
712:           		}
713:           		else
714:           		{
715:           			(pi->imem) = -s32i;
49C2  60CC4264     RSBS R4, R4, #0
49C4  260CC     STR R4, [R1, #12]
716:           		}
717:           	}
718:           	else	/* error is 0 */
719:           	{
720:           		/* total control */
721:           		s16t = (int16_t)((pi->imem) >> (pi->shp));
4950  68CA8848     LDRH R0, [R1, #2]
4952  410268CA     LDR R2, [R1, #12]
4954  B2124102     ASRS R2, R0
4956  240AB212     SXTH R2, R2
722:           
723:           		/* result clamp and integral memory update */
724:           		if(s16t < (pi->llim))		/* case possible only if limit is changed */
4958  5F0B240A     MOVS R4, #10
495A  429A5F0B     LDRSH R3, [R1, R4]
495C  DB34429A     CMP R2, R3
495E  2408DB34     BLT.N .LVL192
725:           		{
726:           			s16t = (pi->llim);
49D0  E7B6001A     MOVS R2, R3
727:           			s32t = s16t;
728:           			(pi->imem) = s32t << (pi->shp);
49CA  4082001A     MOVS R2, R3
49CC  60CA4082     LSLS R2, R0
49CE  1A60CA     STR R2, [R1, #12]
729:           		}
730:           		else if(s16t > (pi->hlim))	/* case possible only if limit is changed */
4960  5F0B2408     MOVS R4, #8
4962  429A5F0B     LDRSH R3, [R1, R4]
4964  DDEC429A     CMP R2, R3
4966  1ADDEC     BLE.N .LVL167
731:           		{
732:           			s16t = (pi->hlim);
496E  E7E7001A     MOVS R2, R3
4970  4B19E7E7     B.N .LVL167
733:           			s32t = s16t;
734:           			(pi->imem) = s32t << (pi->shp);
4968  4082001A     MOVS R2, R3
496A  60CA4082     LSLS R2, R0
496C  1A60CA     STR R2, [R1, #12]
735:           		}
736:                           else
737:                           {
738:                             /* no action */
739:                           }
740:           	}
741:           	 /*lint -restore*/
742:                   return(s16t);
743:           }
4942  BD700010     MOVS R0, R2
4944  60CBBD70     POP {R4, R5, R6, PC}
4946  2260CB     STR R3, [R1, #12]
4948  E7FA0022     MOVS R2, R4
494A  2800E7FA     B.N .LVL167
494C  DB102800     CMP R0, #0
494E  8848DB10     BLT.N .LVL173
4950  68CA8848     LDRH R0, [R1, #2]
4952  410268CA     LDR R2, [R1, #12]
4954  B2124102     ASRS R2, R0
4956  240AB212     SXTH R2, R2
4958  5F0B240A     MOVS R4, #10
495A  429A5F0B     LDRSH R3, [R1, R4]
495C  DB34429A     CMP R2, R3
495E  2408DB34     BLT.N .LVL192
4960  5F0B2408     MOVS R4, #8
4962  429A5F0B     LDRSH R3, [R1, R4]
4964  DDEC429A     CMP R2, R3
4966  1ADDEC     BLE.N .LVL167
4968  4082001A     MOVS R2, R3
496A  60CA4082     LSLS R2, R0
496C  1A60CA     STR R2, [R1, #12]
496E  E7E7001A     MOVS R2, R3
4970  4B19E7E7     B.N .LVL167
4972  42984B19     LDR R3, [PC, #100]
4974  DB024298     CMP R0, R3
4976  4240DB02     BLT.N .LVL176
4978  B2804240     RSBS R0, R0, #0
497A  E000B280     UXTH R0, R0
497C  4815E000     B.N .LVL177
497E  B2004815     LDR R0, [PC, #84]
4980  2304B200     SXTH R0, R0
4982  5ECC2304     MOVS R3, #4
4984  43445ECC     LDRSH R4, [R1, R3]
4986  88CB4344     MULS R4, R0
4988  411C88CB     LDRH R3, [R1, #6]
498A  68CB411C     ASRS R4, R3
498C  1AE468CB     LDR R3, [R1, #12]
498E  22001AE4     SUBS R4, R4, R3
4990  5E8B2200     MOVS R2, #0
4992  43435E8B     LDRSH R3, [R1, R2]
4994  884D4343     MULS R3, R0
4996  18E0884D     LDRH R5, [R1, #2]
4998  412818E0     ADDS R0, R4, R3
499A  42404128     ASRS R0, R5
499C  B2004240     RSBS R0, R0, #0
499E  260AB200     SXTH R0, R0
49A0  5F8A260A     MOVS R6, #10
49A2  42905F8A     LDRSH R2, [R1, R6]
49A4  DB074290     CMP R0, R2
49A6  2608DB07     BLT.N .LVL187
49A8  5F8B2608     MOVS R6, #8
49AA  42835F8B     LDRSH R3, [R1, R6]
49AC  DA084283     CMP R3, R0
49AE  13DA08     BGE.N .LVL190
49B0  40AB0013     MOVS R3, R2
49B2  60CB40AB     LSLS R3, R5
49B4  E7C460CB     STR R3, [R1, #12]
49B6  10E7C4     B.N .LVL167
49B8  40A80010     MOVS R0, R2
49BA  18C040A8     LSLS R0, R5
49BC  60C818C0     ADDS R0, R0, R3
49BE  E7BF60C8     STR R0, [R1, #12]
49C0  4264E7BF     B.N .LVL167
49C2  60CC4264     RSBS R4, R4, #0
49C4  260CC     STR R4, [R1, #12]
49C6  E7BB0002     MOVS R2, R0
49C8  1AE7BB     B.N .LVL167
49CA  4082001A     MOVS R2, R3
49CC  60CA4082     LSLS R2, R0
49CE  1A60CA     STR R2, [R1, #12]
49D0  E7B6001A     MOVS R2, R3
49D2  7FFFE7B6     B.N .LVL167
49D4  7FFF     LDRB R7, [R7, #31]
49D6  80010000     MOVS R0, R0
49D8  FFFF8001     STRH R1, [R0]
49DA  4A1BFFFF     MRC2 P10, #7, R4, CR15, CR11, {0}
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/mc_app.c  ----------------
1:             /*******************************************************************************
2:              Motor Control Application Source file 
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 mc_app.c
9:             
10:              Summary:
11:                This file contains all the functions related to motor control application
12:            
13:              Description:
14:                This file contains implementation of the application state machine
15:             
16:             *******************************************************************************/
17:            
18:            // DOM-IGNORE-BEGIN
19:            /*******************************************************************************
20:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
21:            *
22:            * Subject to your compliance with these terms, you may use Microchip software
23:            * and any derivatives exclusively with Microchip products. It is your
24:            * responsibility to comply with third party license terms applicable to your
25:            * use of third party software (including open source software) that may
26:            * accompany Microchip software.
27:            *
28:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:            * PARTICULAR PURPOSE.
32:            *
33:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:             *******************************************************************************/
41:            // DOM-IGNORE-END
42:            
43:            
44:            /*******************************************************************************
45:            Headers inclusions
46:            *******************************************************************************/
47:            
48:            
49:            
50:            #include "q14_generic_mcLib.h"
51:            #include "q14_rolo_mcLib.h"
52:            #include "device.h"
53:            #include "mc_app.h"
54:            #include "definitions.h"
55:            #include <sys/attribs.h>
56:            
57:            /****************************************************************************/
58:            /************************MISRA Violations    ********************************/
59:            /****************************************************************************/
60:            /* 10.1:
61:            shift operations on signed numbers is used to benefit optimization.
62:            arithmetic shift is used by the compiler in those cases
63:            * 11.4, 11.6*
64:            Register access (absolute address access) - 
65:            required for ADC and TCC access.
66:            */
67:            
68:            /*******************************************************************************
69:            Variables
70:            *******************************************************************************/
71:            
72:            /***********Non safety ***********************/
73:            
74:            /* motor run variable */
75:            uint8_t  state_run;      
76:            /* speed reference, derived from GUI data */
77:            int16_t  ext_speed_ref_rpm;
78:            /* reference speed [rpm] absolute value */
79:            uint16_t rpm_ref_abs;   
80:            /* alarm code ; only internal reference*/
81:            alrm_t alarm = NO_ALRM;  
82:            /*only display variables - non safety */
83:            /* d current in mA */
84:            int16_t d_cur_a1000;    
85:            /* q current in mA */
86:            int16_t q_cur_a1000;    
87:            /* d voltage in volt tenths */
88:            int16_t d_vol_v10;      
89:            /* q voltage in volt tenths */
90:            int16_t q_vol_v10;      
91:            /* DC link voltage in volt tenths */
92:            uint16_t bus_vol_v10;   
93:            /* end of display variables */
94:            /* measured input speed */
95:            /* measured speed [rpm] absolute value */
96:            uint16_t spe_rpm_abs;   
97:            /* visualization variables and
98:            its dependent filters */
99:            /* counter in main loop (10ms) synchronization function */
100:           uint16_t     syn_cnt;  
101:           
102:           uint8_t phaseindex[3] = {0,1,2};
103:           uint8_t vis_cnt = 0;
104:           /* Debug variables */
105:           #ifdef  MACRO_DEBUG
106:           uint16_t     acc_ramp;
107:           uint16_t     dec_ramp;
108:           #endif
109:           #ifdef  CURPI_TUN
110:           uint16_t
111:               cpt_cnt;    /* counter in tuning PI procedure */
112:           #endif  
113:           
114:           /*Debug variables; One time write variables */
115:           #ifdef  MACRO_DEBUG
116:           uint16_t
117:               sampling_freq, /* sampling frequency [Hz] */
118:               k_avail_vol,   /* constant in available output voltage vector amplitude calculation */
119:               max_spe_rs,    /* maximum speed [rad/sec] */
120:               min_spe_rs,    /* minimum speed [rad/sec] */
121:               max_spe_rpm,   /* maximum speed [rpm] */
122:               min_spe_rpm,   /* minimum speed [rpm] */
123:               k_speed_l,     /* constant in speed conversion */
124:               k_intspe2rpm,  /* constant in speed conversion */
125:               stup_ticks,    /* number of interrupt during startup */
126:               dspeedl_stup,  /* one step speed variation during startup */
127:               max_cur,       /* maximum current [internal current unit] */
128:               start_cur,     /* startup current [internal current unit] */
129:               cur_ramp_al,   /* current ramp during alignment */
130:               cur_ramp_ru;   /* direct current variation ramp during normal running */
131:           
132:           
133:           uint32_t state_count = 1;
134:           uint16_t state_windmilling =0;
135:           uint16_t state_decide =0;
136:           uint16_t state_brake =0;
137:           uint16_t state_stopped =0;
138:           uint16_t state_start =0;
139:           uint16_t state_align =0;
140:           uint16_t state_closingloop =0;
141:           uint16_t state_closingloopwindmilling =0;
142:           uint16_t state_closedloop =0;
143:           int16_t min_test=MIN_SPE;
144:           uint16_t start_count = 0;
145:           uint16_t stop_count = 0;
146:           int32_t delta_duty = 0;
147:           #endif
148:           
149:           
150:           
151:           /******************************************************************************
152:           Safety variables
153:           ******************************************************************************/
154:           
155:           /* measured phase currents (A/D converter values, without offset) */
156:           int16_t cur_mea[3];     
157:           
158:           /*PI control variables */
159:           pi_cntrl_t
160:               id_pi,
161:               iq_pi,
162:               sp_pi;
163:           
164:           int16_t
165:               spe_ref_sgn,  /* speed reference sign (speed_ramp routine output) */
166:               ref_sgn,      /* speed reference sign (speed_ramp routine input, 
167:                                derived from GUI data) */
168:               sgn_mem;      /* speed reference sign memory */
169:           uint16_t
170:               spe_ref_abs ,  /* speed reference absolute value 
171:                                (speed_ramp routine output) [internal speed unit] */
172:               ref_abs,      /* speed reference absolute value 
173:                                (speed_ramp routine input, derived from GUI data) 
174:                                [internal speed unit] */
175:               ext_spe_ref_fil,  /*Filtered Speed reference in RPM*/    
176:               espabs_fil;   /* filtered estimated electrical speed absolute value 
177:                               [internal speed unit] */
178:           int16_t
179:               vbfil,      /* filtered bus voltage value [internal voltage unit] */
180:               vdfil,      /* filtered direct voltage value [internal voltage unit] */
181:               vqfil,      /* filtered quadrature voltage value [internal voltage unit] */
182:               idfil,      /* filtered direct current value [internal current unit] */
183:               iqfil;      /* filtered quadrature current value [internal current unit] */
184:           
185:           uint16_t  uall_cnt,  /* u-phase phase lost alarm counter */
186:             vall_cnt,  /* v-phase phase lost alarm counter */
187:             wall_cnt;  /* w-phase phase lost alarm counter */
188:           
189:           /* status variable in motor management state machine */
190:           
191:           run_status_t
192:               motor_status = STOPPED;  
193:           
194:           stop_source_t motor_stop_source = NO_START_CMD;
195:           /* variables used for phase lost check */
196:           static uint32_t
197:             umem,      /* u-phase absolute value filter memory */
198:             vmem,      /* v-phase absolute value filter memory */
199:             wmem;      /* w-phase absolute value filter memory */
200:           uint16_t
201:             ufil,      /* u-phase absolute value filter output [internal current unit] */
202:             vfil,      /* v-phase absolute value filter output [internal current unit] */
203:             wfil;      /* w-phase absolute value filter output [internal current unit] */
204:           
205:           /* system phase [(d, q) reference system angular 
206:                           position referred to alpha (u) axis] [internal angle unit] */
207:           static ang_sincos_t
208:               sysph;      
209:           /* vector containing the PWM timer compare values */
210:           static int32_t dutycycle[3];  
211:           
212:           static vec3_t
213:               cur3m,      /* three-phases vector of current measurement [internal current unit] */
214:               outv3;      /* three-phases vector of output voltage reference [internal voltage unit] */
215:           
216:           static vec2_t
217:               curabm,      /* two-phases (a, b) vector of current measurement [internal current unit] */
218:               curabr,      /* two-phases (a, b) vector of current reference [internal current unit] */
219:               curdqm,      /* two-phases (d, q) vector of current measurement [internal current unit] */
220:               curdqr,      /* two-phases (d, q) vector of current reference [internal voltage unit] */
221:               outvab,      /* two-phases (a, b) vector of output voltage reference [internal voltage unit] */
222:               outvdq;      /* two-phases (d, q) vector of output voltage reference [internal voltage unit] */
223:           
224:           static uint16_t
225:               newsysph,    /* next cycle system phase [(d, q) reference system 
226:                               angular position referred to alpha (u) axis] [internal angle unit] */
227:               position_offset,/* angular offset to be added to system phase [internal angle unit] */
228:               spe_ref_fil,  /* filtered speed reference absolute value [internal speed unit] */
229:               elespeed_abs;  /* estimated speed absolute value [internal speed unit] */
230:           
231:           static int16_t
232:             du,        /* u-phase duty cycle */
233:             dv,        /* v-phase duty cycle */
234:             dw;        /* w-phase duty cycle */
235:           
236:           static int16_t
237:               elespeed,    /* (estimated or imposed) electrical speed [internal speed unit] */
238:               plost_cnt,   /* counter in position lost alarm management */
239:               vbus,        /* bus voltage value [internal voltage unit] */
240:               vbmin,       /* minimum bus voltage value [internal voltage unit] */
241:               outvmax;     /* maximum available output voltage vector 
242:                               amplitude value [internal voltage unit] */
243:           
244:           static int32_t
245:               dcurref_l,    /* amplified direct current reference */
246:               vbmin_mem,    /* filter memory in vbmin lp filter */
247:               vbfil_mem,    /* filter memory in vbus lp filter */
248:               vdfil_mem,    /* filter memory in vd lp filter */
249:               vqfil_mem,    /* filter memory in vq lp filter */
250:               idfil_mem,    /* filter memory in id lp filter */
251:               iqfil_mem;    /* filter memory in iq lp filter */
252:           
253:           static uint32_t
254:               espabs_mem,  /* filter memory in electrical speed lp filter */
255:               ext_spe_ref_mem,/* filter memory for mechanical speed ref LP filter */
256:               ampsysph,    /* system phase amplified value */
257:               elespeed_l,  /* electrical speed amplified value */
258:               spe_ref_mem; /* filter memory in reference speed lp filter */
259:           
260:           uint16_t test_max_spe_rpm;
261:           uint16_t test_min_spe_rpm;
262:           int32_t  spe_adc_rpm_var;
263:           uint16_t spe_adc_rpm;
264:           
265:           /*******************************************************************************
266:           Functions
267:           *******************************************************************************/
268:           
269:           #ifdef  MACRO_DEBUG
270:           /******************************************************************************
271:           Function:    macro_debug
272:           Description:  debug function
273:           Input:      nothing
274:           Output:      nothing
275:           Note:      only used to make it possible to visualize the values of some
276:                   macro definitions with the debugger;
277:                   to be removed in final release
278:           ******************************************************************************/
279:           void macro_debug(void)
280:           {
281:               k_avail_vol = K_AVAIL_VOL;
49DC  4B1C4A1B     LDR R2, $d
49DE  801A4B1C     LDR R3, [PC, #112]
49E0  4A1C801A     STRH R2, [R3]
282:               sampling_freq = (uint16_t)SAMPLING_FREQ;
49E2  4B1C4A1C     LDR R2, [PC, #112]
49E4  801A4B1C     LDR R3, [PC, #112]
49E6  4A1C801A     STRH R2, [R3]
283:               max_spe_rs = (uint16_t)MAX_SPE_RS;
49E8  4B1D4A1C     LDR R2, [PC, #112]
49EA  801A4B1D     LDR R3, [PC, #116]
49EC  22BC801A     STRH R2, [R3]
284:               min_spe_rs = (uint16_t)MIN_SPE_RS;
49EE  4B1C22BC     MOVS R2, #188
49F0  801A4B1C     LDR R3, [PC, #112]
49F2  4B1C801A     STRH R2, [R3]
285:               max_spe_rpm = MAX_SPE_RPM;
49F4  4A1D4B1C     LDR R3, [PC, #112]
49F6  80134A1D     LDR R2, [PC, #116]
49F8  22B48013     STRH R3, [R2]
286:               min_spe_rpm = MIN_SPE_RPM;
49FA  5222B4     MOVS R2, #180
49FC  491C0052     LSLS R2, R2, #1
49FE  800A491C     LDR R1, [PC, #112]
4A00  481C800A     STRH R2, [R1]
287:               k_speed_l = K_SPEED_L;
4A02  491C481C     LDR R0, [PC, #112]
4A04  8008491C     LDR R1, [PC, #112]
4A06  491C8008     STRH R0, [R1]
288:               k_intspe2rpm = K_INTSPE2RPM;
4A08  800B491C     LDR R1, [PC, #112]
4A0A  481C800B     STRH R3, [R1]
289:               stup_ticks = STUP_TICKS;
4A0C  491D481C     LDR R0, [PC, #112]
4A0E  8008491D     LDR R1, [PC, #116]
4A10  20A18008     STRH R0, [R1]
290:               dspeedl_stup = (uint16_t)DSPEEDL_STUP;
4A12  8020A1     MOVS R0, #161
4A14  491C0080     LSLS R0, R0, #2
4A16  8008491C     LDR R1, [PC, #112]
4A18  20368008     STRH R0, [R1]
291:               acc_ramp = ACC_RAMP;
4A1A  491B2036     MOVS R0, #54
4A1C  8008491B     LDR R1, [PC, #108]
4A1E  381B8008     STRH R0, [R1]
292:               dec_ramp = DEC_RAMP;
4A20  491B381B     SUBS R0, #27
4A22  8008491B     LDR R1, [PC, #108]
4A24  481B8008     STRH R0, [R1]
293:               max_cur = MAX_CUR;
4A26  491B481B     LDR R0, [PC, #108]
4A28  8008491B     LDR R1, [PC, #108]
4A2A  481B8008     STRH R0, [R1]
294:               start_cur = START_CUR;
4A2C  491C481B     LDR R0, [PC, #108]
4A2E  8008491C     LDR R1, [PC, #112]
4A30  491C8008     STRH R0, [R1]
295:               cur_ramp_al = CUR_RAMP_AL;
4A32  481C491C     LDR R1, [PC, #112]
4A34  8001481C     LDR R0, [PC, #112]
4A36  481C8001     STRH R1, [R0]
296:               cur_ramp_ru = CUR_RAMP_RU;
4A38  8001481C     LDR R0, [PC, #112]
4A3A  481C8001     STRH R1, [R0]
297:               spe_ref_abs = (uint16_t)MIN_SPE;
4A3C  491D481C     LDR R0, [PC, #112]
4A3E  8008491D     LDR R1, [PC, #116]
4A40  491D8008     STRH R0, [R1]
298:               test_max_spe_rpm = (uint16_t)(MAX_SPE_RPM);
4A42  800B491D     LDR R1, [PC, #116]
4A44  4B1D800B     STRH R3, [R1]
299:               test_min_spe_rpm = (uint16_t)(MIN_SPE_RPM);
4A46  801A4B1D     LDR R3, [PC, #116]
4A48  4770801A     STRH R2, [R3]
300:           }
4A4A  24064770     BX LR
4A4C  2406     MOVS R4, #6
4A4E  1080000     MOVS R0, R0
4A50  20000108     LSLS R0, R1, #4
4A52  13882000     MOVS R0, #0
4A54  1388     ASRS R0, R1, #14
4A56  12A0000     MOVS R0, R0
4A58  2000012A     LSLS R2, R5, #4
4A5A  6222000     MOVS R0, #0
4A5C  0622     LSLS R2, R4, #24
4A5E  C80000     MOVS R0, R0
4A60  200000C8     LSLS R0, R1, #3
4A62  12C2000     MOVS R0, #0
4A64  2000012C     LSLS R4, R5, #4
4A66  BB82000     MOVS R0, #0
4A68  0BB8     LSRS R0, R7, #14
4A6A  1520000     MOVS R0, R0
4A6C  20000152     LSLS R2, R2, #5
4A6E  1062000     MOVS R0, #0
4A70  20000106     LSLS R6, R0, #4
4A72  CCC2000     MOVS R0, #0
4A74  0CCC     LSRS R4, R1, #19
4A76  15A0000     MOVS R0, R0
4A78  2000015A     LSLS R2, R3, #5
4A7A  1342000     MOVS R0, #0
4A7C  20000134     LSLS R4, R6, #4
4A7E  27102000     MOVS R0, #0
4A80  2710     MOVS R7, #16
4A82  11A0000     MOVS R0, R0
4A84  2000011A     LSLS R2, R3, #4
4A86  1242000     MOVS R0, #0
4A88  20000124     LSLS R4, R4, #4
4A8A  FE2000     MOVS R0, #0
4A8C  200000FE     LSLS R6, R7, #3
4A8E  13C2000     MOVS R0, #0
4A90  2000013C     LSLS R4, R7, #4
4A92  1D172000     MOVS R0, #0
4A94  1D17     ADDS R7, R2, #4
4A96  1500000     MOVS R0, R0
4A98  20000150     LSLS R0, R2, #5
4A9A  BA22000     MOVS R0, #0
4A9C  0BA2     LSRS R2, R4, #14
4A9E  1380000     MOVS R0, R0
4AA0  20000138     LSLS R0, R7, #4
4AA2  261E2000     MOVS R0, #0
4AA4  261E     MOVS R6, #30
4AA6  D00000     MOVS R0, R0
4AA8  200000D0     LSLS R0, R2, #3
4AAA  15C2000     MOVS R0, #0
4AAC  2000015C     LSLS R4, R3, #5
4AAE  7AE2000     MOVS R0, #0
4AB0  07AE     LSLS R6, R5, #30
4AB2  1220000     MOVS R0, R0
4AB4  20000122     LSLS R2, R4, #4
4AB6  1262000     MOVS R0, #0
4AB8  20000126     LSLS R6, R4, #4
4ABA  10A2000     MOVS R0, #0
4ABC  2000010A     LSLS R2, R1, #4
4ABE  B5702000     MOVS R0, #0
301:           #endif
302:           
303:           
304:           /******************************************************************************
305:           Function:    syn10ms
306:           Description:  main loop (10ms) synchronization function
307:           Input:      nothing (uses global variable syn_cnt)
308:           Output:      nothing (modifies global variable syn_cnt)
309:           Note:      to be used in a while loop; it becomes false only every 10ms,
310:                   and in this case it resets the counter;
311:                   the counter itself is managed by the main interrupt
312:           ******************************************************************************/
313:           uint8_t syn10ms(void)
314:           {
315:               uint8_t retval = 0;
6400  47702000     MOVS R0, #0
316:               if(0U < syn_cnt)
63F0  881B4B04     LDR R3, $d
63F2  2001881B     LDRH R3, [R3]
63F6  D1032B00     CMP R3, #0
63F8  2232D103     BNE.N .LVL1
317:               {
318:                   retval = 1U;
63F4  2B002001     MOVS R0, #1
319:               }
320:               else
321:               {
322:                   syn_cnt = SYN_VAL10MS;
63FA  4B012232     MOVS R2, #50
63FC  801A4B01     LDR R3, $d
63FE  2000801A     STRH R2, [R3]
323:               }
324:               return( retval );
325:           }
6402  1584770     BX LR
6404  20000158     LSLS R0, R3, #5
6406  B5102000     MOVS R0, #0
326:           
327:           /******************************************************************************
328:           Function:    syn1000ms
329:           Description:  (10000ms) synchronization function
330:           Input:      nothing (uses global variable syn1000ms_cnt)
331:           Output:      nothing (modifies global variable syn1000ms_cnt)
332:           Note:      to be used in a while loop; it becomes false only every 1000ms,
333:                   and in this case it resets the counter;
334:                   the counter itself is managed by the main interrupt
335:           ******************************************************************************/
336:           uint8_t syn1000ms(void)
337:           {
338:               uint8_t retval = 0;
0010  0000     MOVS R0, R0
339:               if(0U < syn1000ms_cnt)
0000  20007FF8     LDRB R0, [R7, #31]
0006  653D0000     MOVS R0, R0
340:               {
341:                   retval = 1U;
0004  596D     LDR R5, [R5, R5]
342:               }
343:               else
344:               {
345:                   syn1000ms_cnt = SYN_VAL1000MS;
000A  653F0000     MOVS R0, R0
346:               }
347:               return( retval );
348:           }
0012  0000     MOVS R0, R0
349:           
350:           
351:           /******************************************************************************
352:           Function:    motorcontrol_vars_init
353:           Description:  motor control variable initialization
354:           Input:      nothing (uses some global variables)
355:           Output:      nothing (modifies some global variables)
356:           Note:      to be called once before starting the interrupts;
357:                   sets some constants used by the control algo, and calls init
358:                   functions for the observer
359:           ******************************************************************************/
360:           void motorcontrol_vars_init(void)
361:           {
4D44  4B1FB570     PUSH {R4, R5, R6, LR}
362:             uint32_t u32a;
363:           
364:           #ifdef MACRO_DEBUG
365:               macro_debug();
4D46  47984B1F     LDR R3, [PC, #124]
4D48  4A1F4798     BLX R3
366:           #endif  /* ifdef MACRO_DEBUG */
367:           
368:               /* current PI gains */
369:             u32a = (uint32_t)KP_CUR;
370:             if(32767U < u32a)
371:             {
372:               u32a = 32767;
373:             }
374:             iq_pi.kp = (int16_t)u32a;
4D4A  21884A1F     LDR R2, [PC, #124]
4D4C  80112188     MOVS R1, #136
4D4E  4B1E8011     STRH R1, [R2]
375:             id_pi.kp = (int16_t)u32a;
4D50  80194B1E     LDR R3, [PC, #120]
4D52  200A8019     STRH R1, [R3]
376:             iq_pi.shp = (uint16_t)SH_PROC;
4D54  8050200A     MOVS R0, #10
4D56  80588050     STRH R0, [R2, #2]
377:             id_pi.shp = (uint16_t)SH_PROC;
4D58  39528058     STRH R0, [R3, #2]
378:             u32a = KI_CUR;
379:             if(32767U < u32a)
380:             {
381:               u32a = 32767;
382:             }
383:             iq_pi.ki = (int16_t)u32a;
4D5A  80913952     SUBS R1, #82
4D5C  80998091     STRH R1, [R2, #4]
384:             id_pi.ki = (int16_t)u32a;
4D5E  39308099     STRH R1, [R3, #4]
385:             iq_pi.shi = (uint16_t)SH_INTC;
4D60  80D13930     SUBS R1, #48
4D62  80D980D1     STRH R1, [R2, #6]
386:             id_pi.shi = (uint16_t)SH_INTC;
4D64  240080D9     STRH R1, [R3, #6]
387:             iq_pi.imem = 0;
4D66  60D42400     MOVS R4, #0
4D68  60DC60D4     STR R4, [R2, #12]
388:             id_pi.imem = 0;
4D6A  811460DC     STR R4, [R3, #12]
389:             iq_pi.hlim = 0;
4D6C  811C8114     STRH R4, [R2, #8]
390:             id_pi.hlim = 0;
4D6E  8154811C     STRH R4, [R3, #8]
391:             iq_pi.llim = 0;
4D70  815C8154     STRH R4, [R2, #10]
392:             id_pi.llim = 0;
4D72  4B16815C     STRH R4, [R3, #10]
393:           
394:               /* speed PI gains */
395:             u32a = KP_SPE;
396:             if(32767U < u32a)
397:             {
398:               u32a = 32767;
399:             }
400:             sp_pi.kp = (int16_t)u32a;
4D74  22894B16     LDR R3, [PC, #88]
4D76  D22289     MOVS R2, #137
4D78  801A00D2     LSLS R2, R2, #3
4D7A  8058801A     STRH R2, [R3]
401:             sp_pi.shp = (uint16_t)SH_PROS;
4D7C  228C8058     STRH R0, [R3, #2]
402:             u32a = KI_SPE;
403:             if(32767U < u32a)
404:             {
405:               u32a = 32767;
406:             }
407:             sp_pi.ki = (int16_t)u32a;
4D7E  809A228C     MOVS R2, #140
4D80  80D9809A     STRH R2, [R3, #4]
408:             sp_pi.shi = (uint16_t)SH_INTS;
4D82  60DC80D9     STRH R1, [R3, #6]
409:             sp_pi.imem = 0;
4D84  811C60DC     STR R4, [R3, #12]
410:             sp_pi.hlim = 0;
4D86  815C811C     STRH R4, [R3, #8]
411:             sp_pi.llim = 0;
4D88  4B12815C     STRH R4, [R3, #10]
412:           
413:             /* */
414:             state_run = 0;
4D8A  22004B12     LDR R3, [PC, #72]
4D8C  701A2200     MOVS R2, #0
4D8E  4B11701A     STRB R2, [R3]
415:             ext_speed_ref_rpm = 0;
4D90  801C4B11     LDR R3, [PC, #68]
4D92  4B11801C     STRH R4, [R3]
416:           
417:             /* observer init */
418:             estimation_set_base_values(SAMPLING_FREQ, BASE_SPEED, 
4D94  4A124B11     LDR R3, [PC, #68]
4D96  49124A12     LDR R2, [PC, #72]
4D98  48134912     LDR R1, [PC, #72]
4D9A  4D134813     LDR R0, [PC, #76]
4D9C  47A84D13     LDR R5, [PC, #76]
4D9E  491347A8     BLX R5
419:                                        BASE_VOLTAGE, BASE_CURRENT);
420:             estimation_set_parameters((float32_t)R_STA, (float32_t)L_SYN);
4DA0  48144913     LDR R1, [PC, #76]
4DA2  4B144814     LDR R0, [PC, #80]
4DA4  47984B14     LDR R3, [PC, #80]
4DA6  4B144798     BLX R3
421:           
422:             /* phase offset */
423:             position_offset = 0;
4DA8  801C4B14     LDR R3, [PC, #80]
4DAA  4B14801C     STRH R4, [R3]
424:             /* safe initialzation for variables to avoid
425:                block level static definition  MISRA 8.9 */
426:             sysph.ang = 0;
4DAC  801C4B14     LDR R3, [PC, #80]
4DAE  4B14801C     STRH R4, [R3]
427:             curdqm.x = 0;
4DB0  801C4B14     LDR R3, [PC, #80]
4DB2  4B14801C     STRH R4, [R3]
428:             newsysph = 0;
4DB4  801C4B14     LDR R3, [PC, #80]
4DB6  4B14801C     STRH R4, [R3]
429:             outvmax = 0;
4DB8  801C4B14     LDR R3, [PC, #80]
4DBA  4B14801C     STRH R4, [R3]
430:             elespeed = 0;
4DBC  801C4B14     LDR R3, [PC, #80]
4DBE  BD70801C     STRH R4, [R3]
431:           
432:           }
4DC0  46C0BD70     POP {R4, R5, R6, PC}
4DC2  49DD46C0     MOV R8, R8
4DC4  49DD     LDR R1, [PC, #884]
4DC6  EC0000     MOVS R0, R0
4DC8  200000EC     LSLS R4, R5, #3
4DCA  D82000     MOVS R0, #0
4DCC  200000D8     LSLS R0, R3, #3
4DCE  1402000     MOVS R0, #0
4DD0  20000140     LSLS R0, R0, #5
4DD2  12E2000     MOVS R0, #0
4DD4  2000012E     LSLS R6, R5, #4
4DD6  1362000     MOVS R0, #0
4DD8  20000136     LSLS R6, R6, #4
4DDA  CCCE2000     MOVS R0, #0
4DDC  408CCCCE     LDMIA R4!, {R1, R2, R3, R6, R7}
4DDE  3737408C     LSLS R4, R1
4DE0  42533737     ADDS R7, #55
4DE2  597C4253     RSBS R2, R3, #0
4DE4  44C4597C     LDR R4, [R7, R5]
4DE6  400044C4     ADD R12, R8
4DE8  459C4000     ANDS R0, R0
4DEA  5371459C     CMP R12, R3
4DEC  5371     STRH R1, [R6, R5]
4DEE  C5AC0000     MOVS R0, R0
4DF0  39A7C5AC     STMIA R5!, {R2, R3, R5, R7}
4DF2  EB8539A7     SUBS R1, #167
4DF6  31DD3E91     SUBS R6, #145
4DF8  31DD     ADDS R1, #221
4DFA  29140000     MOVS R0, R0
4DFC  20002914     CMP R1, #20
4DFE  28702000     MOVS R0, #0
4E00  20002870     CMP R0, #112
4E02  28842000     MOVS R0, #0
4E04  20002884     CMP R0, #132
4E06  29102000     MOVS R0, #0
4E08  20002910     CMP R1, #16
4E0A  29122000     MOVS R0, #0
4E0C  20002912     CMP R1, #18
4E0E  290C2000     MOVS R0, #0
4E10  2000290C     CMP R1, #12
4E12  B5102000     MOVS R0, #0
433:           
434:           /******************************************************************************
435:           Function:    motor_stop
436:           Description:  pwm output pins disable function
437:           Input:      nothing
438:           Output:      nothing (modifies some global variables)
439:           Note:      to be called to disable pwm outputs
440:           ******************************************************************************/
441:           void motor_stop(void)
442:           {
443:               /* Rules 11.4, 11.6 violated access to register */
444:               /*lint -e9078 -e923 */
445:               int32_t dc[3];
446:               dc[0] =  (int32_t)PWM_HPER_TICKS;
447:               dc[1] =  (int32_t)PWM_HPER_TICKS;
448:               dc[2] =  (int32_t)PWM_HPER_TICKS;
449:           	
450:           	TCC0_REGS->TCC_CCBUF[0] = dc[0];	
6154  22964B07     LDR R3, $d
6156  1122296     MOVS R2, #150
6158  671A0112     LSLS R2, R2, #4
615A  675A671A     STR R2, [R3, #112]
451:               TCC0_REGS->TCC_CCBUF[1] = dc[1];
615C  679A675A     STR R2, [R3, #116]
452:               TCC0_REGS->TCC_CCBUF[2] = dc[2];
615E  2277679A     STR R2, [R3, #120]
453:               TCC0_REGS->TCC_PATT = 0x0077U;
6160  871A2277     MOVS R2, #119
6162  2200871A     STRH R2, [R3, #56]
454:               /*lint +e9078 +e923 */
455:           
456:               state_run = 0;
6164  4B042200     MOVS R2, #0
6166  701A4B04     LDR R3, [PC, #16]
6168  4A04701A     STRB R2, [R3]
457:           
458:               stop_count++;
616A  88134A04     LDR R2, [PC, #16]
616C  33018813     LDRH R3, [R2]
616E  80133301     ADDS R3, #1
6170  47708013     STRH R3, [R2]
459:           
460:           
461:           }
6172  24004770     BX LR
6174  42002400     MOVS R4, #0
6176  12E4200     TST R0, R0
6178  2000012E     LSLS R6, R5, #4
617A  29242000     MOVS R0, #0
617C  20002924     CMP R1, #36
617E  22000     MOVS R0, #0
462:           
463:           /******************************************************************************
464:           Function:    motor_start
465:           Description:  pwm output pins enable function
466:           Input:      nothing
467:           Output:      nothing (modifies some global variables)
468:           Note:      to be called to enable pwm outputs
469:           ******************************************************************************/
470:           void motor_start(void)
471:           {
472:               /* Rules 11.4, 11.6 violated access to register */
473:               /*lint -e9078 -e923 */
474:               	
475:           	TCC0_REGS->TCC_PATT = 0;
6278  4B052200     MOVS R2, #0
627A  871A4B05     LDR R3, [PC, #20]
627C  3201871A     STRH R2, [R3, #56]
476:               
477:               /*lint +e9078 +e923 */
478:               state_run = 1;
627E  4B043201     ADDS R2, #1
6280  701A4B04     LDR R3, [PC, #16]
6282  4A04701A     STRB R2, [R3]
479:               start_count++;
6284  88134A04     LDR R2, [PC, #16]
6286  33018813     LDRH R3, [R2]
6288  80133301     ADDS R3, #1
628A  47708013     STRH R3, [R2]
480:           }
628C  46C04770     BX LR
628E  240046C0     MOV R8, R8
6290  42002400     MOVS R4, #0
6292  12E4200     TST R0, R0
6294  2000012E     LSLS R6, R5, #4
6296  29182000     MOVS R0, #0
6298  20002918     CMP R1, #24
629A  5702000     MOVS R0, #0
481:           
482:           /******************************************************************************
483:           Function:    phase_lost_filters
484:           Description:  low-pass filtering of the absolute values of the current readings
485:           Input:      nothing (uses as input the global variable cur3m, the current
486:                   readings)
487:           Output:      nothing (only modifies some global variables)
488:           Note:      to be called in the main interrupt; the results will be evaluated
489:                   at a slower rate.
490:           ******************************************************************************/
491:           static inline void phase_lost_filters(void)
492:           {
493:           
494:             /* lowpass filter of absolute value of u-phase current */
495:             uint16_t phase_a;
496:             uint16_t phase_b;
497:             uint16_t phase_c;
498:             if (0 >  cur3m.u)
499:             {
500:               phase_a = (uint16_t)-cur3m.u;
501:             }
502:             else
503:             {
504:               phase_a =  (uint16_t)cur3m.u;  
505:             }
506:             umem = (umem + phase_a) -ufil;
507:              
508:             ufil = (uint16_t)(umem >> (uint32_t)SH_PHL_FIL);
509:           
510:             /* lowpass filter of absolute value of v-phase current */
511:             if (0 >  cur3m.v)
512:             {
513:               phase_b = (uint16_t)-cur3m.v;
514:             }
515:             else
516:             {
517:               phase_b =  (uint16_t)cur3m.v;  
518:             }
519:           
520:             vmem = (vmem + phase_b) -vfil;
521:             vfil = (uint16_t) (vmem >> (uint32_t)SH_PHL_FIL);
522:           
523:             /* lowpass filter of absolute value of w-phase current */
524:             if (0 >  cur3m.w)
525:             {
526:               phase_c = (uint16_t)-cur3m.w;
527:             }
528:             else
529:             {
530:               phase_c =  (uint16_t)cur3m.w;  
531:             }
532:           
533:             wmem = (wmem + phase_c) -wfil;
534:             wfil = (uint16_t)(wmem >> (uint32_t)SH_PHL_FIL);
535:           
536:           }
537:           
538:           /******************************************************************************
539:           Function:    phase_lost_filters_reset
540:           Description:  reset of the filters used for the phase lost check and also
541:                   of the related alarm counters
542:           Input:      nothing (uses global variables)
543:           Output:      nothing (modifies global variables)
544:           Note:      to be called in the main interrupt, when the output frequency
545:                   is lesser than the minimum required for the routine (ex. when
546:                   aligning)
547:           ******************************************************************************/
548:           static inline void phase_lost_filters_reset(void)
549:           {
550:             umem = 0UL;
551:             ufil = 0U;
552:             uall_cnt = 0U;
553:             vmem = 0UL;
554:             vfil = 0U;
555:             vall_cnt = 0U;
556:             wmem = 0UL;
557:             wfil = 0U;
558:             wall_cnt = 0U;
559:           }
560:           
561:           /******************************************************************************
562:           Function:    speed_ramp
563:           Description:  calculation of internal speed reference (in internal units)
564:           Input:      nothing
565:           Output:      nothing
566:           Note1:      the global variable ext_speed_ref_rpm is used as ramp input
567:                           reference,
568:                   the global variable spe_ref is modified as routine output
569:           Note2:      the routine has to be called every 10ms to assure correct ramps
570:           ******************************************************************************/
571:            void speed_ramp(void)
572:           {
2BC8  4B9CB570     PUSH {R4, R5, R6, LR}
573:             
574:                uint32_t    u32a;
575:               int32_t     s32a;
576:               /* speed reference absolute value (actual ramp value) [internal speed unit] */
577:               uint16_t    ram_abs;    
578:               /* reference speed sign (actual ramp value) */
579:               int16_t     ram_sgn;    
580:           
581:               /* interface with PC GUI */
582:               if(0U == start_toggle)
2BCA  781B4B9C     LDR R3, [PC, #624]
2BCC  2B00781B     LDRB R3, [R3]
2BCE  D10C2B00     CMP R3, #0
2BD0  4A9BD10C     BNE.N 0x2BEC
583:               {
584:                   ext_speed_ref_rpm = 0;
2BD2  80134A9B     LDR R2, [PC, #620]
2BD4  4A9B8013     STRH R3, [R2]
585:                   rpm_ref_abs = 0;
2BD6  80134A9B     LDR R2, [PC, #620]
2BD8  4B9B8013     STRH R3, [R2]
586:               }
587:               else
588:               {
589:                   //This calculation scales Speed Ref scale from 0 - 4095 to 0 to Max Speed in RPM
590:                   spe_adc_rpm_var = speed_ref_pot*MAX_SPE_RPM;
2BEC  881A4B98     LDR R3, [PC, #608]
2BEE  4B98881A     LDRH R2, [R3]
2BF0  43534B98     LDR R3, [PC, #608]
2BF2  4A984353     MULS R3, R2
2BF4  60134A98     LDR R2, [PC, #608]
2BF6  131B6013     STR R3, [R2]
591:                   spe_adc_rpm = spe_adc_rpm_var>>12;  //Divide by 4095 as ADC is 12 bit. 
2BF8  B29A131B     ASRS R3, R3, #12
2BFA  4997B29A     UXTH R2, R3
2BFC  800A4997     LDR R1, [PC, #604]
2BFE  498F800A     STRH R2, [R1]
592:                   ext_speed_ref_rpm = spe_adc_rpm;
2C00  800B498F     LDR R1, [PC, #572]
2C02  2368800B     STRH R3, [R1]
593:                   rpm_ref_abs =spe_adc_rpm;
2C0C  801A4B8D     LDR R3, [PC, #564]
2C0E  4B93801A     STRH R2, [R3]
594:                    if(rpm_ref_abs < MIN_SPE_RPM)
2C04  33FF2368     MOVS R3, #104
2C06  429A33FF     ADDS R3, #255
2C08  D93E429A     CMP R2, R3
2C0A  4B8DD93E     BLS.N 0x2C8A
595:                   {
596:                       rpm_ref_abs = MIN_SPE_RPM;
2C8A  5B23B4     MOVS R3, #180
2C8C  4A6D005B     LSLS R3, R3, #1
2C8E  80134A6D     LDR R2, [PC, #436]
2C90  4A6B8013     STRH R3, [R2]
597:                       ext_speed_ref_rpm = MIN_SPE_RPM;
2C92  80134A6B     LDR R2, [PC, #428]
2C94  E7BB8013     STRH R3, [R2]
2C96  4A69E7BB     B.N 0x2C10
598:                                   
599:                   }
600:                   else
601:                   {
602:                   
603:                   }
604:                   if(0x1U == direction)
2C10  781B4B93     LDR R3, [PC, #588]
2C12  2B01781B     LDRB R3, [R3]
2C14  D03F2B01     CMP R3, #1
2C16  4B8BD03F     BEQ.N 0x2C98
605:                   {
606:                       ext_speed_ref_rpm = -ext_speed_ref_rpm;
2C98  88134A69     LDR R2, [PC, #420]
2C9A  425B8813     LDRH R3, [R2]
2C9C  8013425B     RSBS R3, R3, #0
2C9E  E7BA8013     STRH R3, [R2]
2CA0  4B78E7BA     B.N 0x2C18
607:                   }
608:               }
609:           
610:               if(NO_ALRM != alarm)
2BDA  781B4B9B     LDR R3, [PC, #620]
2BDC  2B00781B     LDRB R3, [R3]
2BDE  D15F2B00     CMP R3, #0
2BE0  2200D15F     BNE.N 0x2BA2
2C18  781B4B8B     LDR R3, [PC, #556]
2C1A  2B00781B     LDRB R3, [R3]
2C1C  D1402B00     CMP R3, #0
2C1E  4B87D140     BNE.N 0x2BA2
611:               { 
612:                 motor_stop();
2CA2  47984B78     LDR R3, [PC, #480]
2CA4  22014798     BLX R3
613:                 motor_stop_source = ALARM_STOP ;
2CA6  4B772201     MOVS R2, #1
2CA8  701A4B77     LDR R3, [PC, #476]
2CAA  2300701A     STRB R2, [R3]
614:                 spe_ref_sgn = 0;
2CAC  4A772300     MOVS R3, #0
2CAE  80134A77     LDR R2, [PC, #476]
2CB0  4A718013     STRH R3, [R2]
615:                 spe_ref_abs = 0;
2CB2  80134A71     LDR R2, [PC, #452]
2CB4  E7B38013     STRH R3, [R2]
2CB6  2368E7B3     B.N 0x2C20
616:               }
617:               #ifdef  CURPI_TUN
618:               else if(0 == start_toggle)
619:               {
620:                   motor_stop_source = CUR_PI_NO_START_CMD ;
621:                   motor_stop();
622:                   cpt_cnt = 0;
623:               }
624:               else if(CPT_CNT_VAL > cpt_cnt)
625:               {
626:                   
627:                   cpt_cnt++;
628:                   motor_start();
629:               }
630:               else
631:               {
632:                   motor_stop_source = CUR_PI_END ;
633:                   motor_stop();
634:               }
635:               return;
636:               #endif  /* ifdef CURPI_TUN */
637:           
638:               if(-((int16_t)(MIN_SPE_RPM)) >= ext_speed_ref_rpm)
2C20  20004B87     LDR R3, [PC, #540]
2C22  5E182000     MOVS R0, #0
2C24  4B8F5E18     LDRSH R0, [R3, R0]
2C26  42984B8F     LDR R3, [PC, #572]
2C28  DA454298     CMP R0, R3
2C2A  4240DA45     BGE.N 0x2BB8
639:               {
640:                   u32a = (uint32_t)((uint16_t)(-ext_speed_ref_rpm) * (uint32_t)BASE_VALUE_INT);
2C2C  B2804240     RSBS R0, R0, #0
2C2E  380B280     UXTH R0, R0
2C30  49880380     LSLS R0, R0, #14
641:                   ref_abs = (uint16_t)(u32a / ((uint16_t)K_INTSPE2RPM));
2C32  4B8C4988     LDR R1, [PC, #544]
2C34  47984B8C     LDR R3, [PC, #560]
2C36  4B8C4798     BLX R3
2C38  80184B8C     LDR R3, [PC, #560]
2C3A  22018018     STRH R0, [R3]
642:                   ref_sgn = -1;
2C3C  42522201     MOVS R2, #1
2C3E  4B824252     RSBS R2, R2, #0
2C40  801A4B82     LDR R3, [PC, #520]
2C42  4B81801A     STRH R2, [R3]
643:               }
644:               else if(((int16_t)(MIN_SPE_RPM)) <= ext_speed_ref_rpm)
2CB8  33FF2368     MOVS R3, #104
2CBA  429833FF     ADDS R3, #255
2CBC  DD904298     CMP R0, R3
2CBE  B280DD90     BLE.N .LVL52
645:               {
646:                   u32a = (uint32_t)((uint16_t)ext_speed_ref_rpm * (uint32_t)BASE_VALUE_INT);
2CC0  380B280     UXTH R0, R0
2CC2  49630380     LSLS R0, R0, #14
647:                   ref_abs = (uint16_t)(u32a / ((uint16_t)K_INTSPE2RPM));
2CC4  4B684963     LDR R1, [PC, #396]
2CC6  47984B68     LDR R3, [PC, #416]
2CC8  4B684798     BLX R3
2CCA  80184B68     LDR R3, [PC, #416]
2CCC  22018018     STRH R0, [R3]
648:                   ref_sgn = 1;
2CCE  4B5E2201     MOVS R2, #1
2CD0  801A4B5E     LDR R3, [PC, #376]
2CD2  E7B6801A     STRH R2, [R3]
2CD4  4A5CE7B6     B.N 0x2C44
649:               }
650:               else
651:               {
652:                   ref_abs = 0;
653:                   ref_sgn = 0;
2BE2  4B992200     MOVS R2, #0
2BE4  801A4B99     LDR R3, [PC, #612]
2BE6  2300801A     STRH R2, [R3]
654:               }
655:           
656:               if((0 == ref_sgn) || (sgn_mem != ref_sgn))
2BE8  E0332300     MOVS R3, #0
2BEA  4B98E033     B.N 0x2C54
2C44  22004B81     LDR R3, [PC, #516]
2C46  5E9B2200     MOVS R2, #0
2C48  4A895E9B     LDRSH R3, [R3, R2]
2C4A  21004A89     LDR R2, [PC, #548]
2C4C  5E522100     MOVS R1, #0
2C4E  429A5E52     LDRSH R2, [R2, R1]
2C50  D00D429A     CMP R2, R3
2C52  2100D00D     BEQ.N 0x2C70
657:               {
658:                   /* reset reference */
659:                    ref_abs = 0;
2C54  4A852100     MOVS R1, #0
2C56  80114A85     LDR R2, [PC, #532]
2C58  4A7B8011     STRH R1, [R2]
660:                   /* reset position_lost_alarm if needed */
661:                   if(POS_LOST_ALL == alarm)
2C5A  78124A7B     LDR R2, [PC, #492]
2C5C  2A017812     LDRB R2, [R2]
2C5E  D0392A01     CMP R2, #1
2C60  4A84D039     BEQ.N 0x2CD6
662:                   {
663:                     alarm = NO_ALRM;
2CD6  70114A5C     LDR R2, [PC, #368]
2CD8  4A667011     STRB R1, [R2]
664:                   }
665:           
666:                   /* only if motor stopped updates the sign */
667:                   if((uint16_t)MIN_SPE > spe_ref_abs)
2C62  49844A84     LDR R2, [PC, #528]
2C64  88094984     LDR R1, [PC, #528]
2C66  42918809     LDRH R1, [R1]
2C68  D8014291     CMP R1, R2
2C6A  4A80D801     BHI.N 0x2C70
2CDA  49664A66     LDR R2, [PC, #408]
2CDC  88094966     LDR R1, [PC, #408]
2CDE  42918809     LDRH R1, [R1]
2CE0  D9C34291     CMP R1, R2
2CE2  4A69D9C3     BLS.N 0x2C6C
668:                   {
669:                       sgn_mem = ref_sgn;
2C6C  80134A80     LDR R2, [PC, #512]
2C6E  4A758013     STRH R3, [R2]
670:                   }
671:               }
672:           
673:               if(NO_ALRM == alarm)
2C70  78124A75     LDR R2, [PC, #468]
2C72  2A007812     LDRB R2, [R2]
2C74  D04C2A00     CMP R2, #0
2C76  4B80D04C     BEQ.N 0x2C12
674:               {
675:           
676:                   /* actual ramp values sampling */
677:                   ram_sgn = spe_ref_sgn;
2CE4  25004A69     LDR R2, [PC, #420]
2CE6  5F552500     MOVS R5, #0
2CE8  4A635F55     LDRSH R5, [R2, R5]
2D12  25004A5E     LDR R2, [PC, #376]
2D14  5F552500     MOVS R5, #0
2D16  4A575F55     LDRSH R5, [R2, R5]
678:                   ram_abs = spe_ref_abs;
2CEA  88144A63     LDR R2, [PC, #396]
2CEC  429D8814     LDRH R4, [R2]
2D0E  E0492400     MOVS R4, #0
2D18  88144A57     LDR R2, [PC, #348]
2D1A  429D8814     LDRH R4, [R2]
679:           
680:                   if(ref_sgn != ram_sgn)
2CEE  D116429D     CMP R5, R3
2CF0  4B5ED116     BNE.N 0x2D20
2D1C  D01D429D     CMP R5, R3
2D1E  2200D01D     BEQ.N .LVL31
681:                   {
682:                       ref_abs = 0;
2D20  4B522200     MOVS R2, #0
2D22  801A4B52     LDR R3, [PC, #328]
2D24  2C00801A     STRH R2, [R3]
683:                   }
684:                   else if(MAX_SPE < ref_abs)
2CF2  881B4B5E     LDR R3, [PC, #376]
2CF4  2C00881B     LDRH R3, [R3]
2D5C  881B4B43     LDR R3, [PC, #268]
2D5E  2280881B     LDRH R3, [R3]
2D60  1D22280     MOVS R2, #128
2D62  429301D2     LSLS R2, R2, #7
2D64  D9C64293     CMP R3, R2
2D66  4B40D9C6     BLS.N 0x2CF6
685:                   {
686:                       ref_abs = MAX_SPE;
2D68  801A4B40     LDR R3, [PC, #256]
2D6A  E7DD801A     STRH R2, [R3]
2D6C  4B4AE7DD     B.N 0x2D2A
687:                   }
688:                   else
689:                   {
690:                     /* dummy else for MISRA */
691:                   }
692:           
693:                   /* ramp management */
694:                   if((0U == ram_abs) && (0U == ref_abs))
2CF6  D1172C00     CMP R4, #0
2CF8  2B00D117     BNE.N 0x2D2A
2CFA  D1152B00     CMP R3, #0
2CFC  4B61D115     BNE.N 0x2D2A
2D26  D0E92C00     CMP R4, #0
2D28  4B44D0E9     BEQ.N 0x2CFE
695:                   {
696:                       motor_stop();
2CFE  47984B61     LDR R3, [PC, #388]
2D00  22004798     BLX R3
697:                       motor_stop_source = NO_START_CMD;
2D02  4B602200     MOVS R2, #0
2D04  701A4B60     LDR R3, [PC, #384]
2D06  4B50701A     STRB R2, [R3]
698:                       ram_sgn = ref_sgn;
2D08  25004B50     LDR R3, [PC, #320]
2D0A  5F5D2500     MOVS R5, #0
2D0C  24005F5D     LDRSH R5, [R3, R5]
2D10  4A5EE049     B.N 0x2DA6
699:                   }
700:                   else
701:                   {
702:                       //if (state_run != 1U)
703:                       if (start_toggle == 1U)
2D2A  781B4B44     LDR R3, [PC, #272]
2D2C  2B01781B     LDRB R3, [R3]
2D2E  D01D2B01     CMP R3, #1
2D30  4B57D01D     BEQ.N 0x2D6E
704:                       {
705:                         /* if motor is not already started */
706:                         motor_start();
2D6E  47984B4A     LDR R3, [PC, #296]
2D70  E7DE4798     BLX R3
2D72  4B3FE7DE     B.N 0x2D32
707:                       }
708:                       if(STOPPED == motor_status)
2D32  781B4B57     LDR R3, [PC, #348]
2D34  2B00781B     LDRB R3, [R3]
2D36  D0342B00     CMP R3, #0
2D38  3B01D034     BEQ.N .LVL38
709:                       {
710:                           ram_abs = 0;
2DA4  4B342400     MOVS R4, #0
711:                       }
712:                       else if((ALIGNING == motor_status) || (STARTING == motor_status))
2D3A  2B013B01     SUBS R3, #1
2D3C  D9192B01     CMP R3, #1
2D3E  4B4AD919     BLS.N 0x2D74
713:                       {
714:                          if((uint16_t)MIN_SPE <= ref_abs)
2D74  4A3D4B3F     LDR R3, [PC, #252]
2D76  88124A3D     LDR R2, [PC, #244]
2D78  24008812     LDRH R2, [R2]
2D7C  D912429A     CMP R2, R3
2D7E  4C46D912     BLS.N 0x2DA6
715:                          {
716:                             ram_abs = MIN_SPE;
2D80  E0104C46     LDR R4, [PC, #280]
2D82  429CE010     B.N 0x2DA6
717:                          }
718:                          else
719:                          {
720:                             ram_abs = 0;
2D7A  429A2400     MOVS R4, #0
721:                          }
722:                       }
723:                       else
724:                       {
725:                           if(ref_abs > ram_abs)
2D40  881B4B4A     LDR R3, [PC, #296]
2D42  429C881B     LDRH R3, [R3]
2D44  D21D429C     CMP R4, R3
2D46  4A52D21D     BCS.N .LVL34
726:                           {
727:                               ram_abs += (uint16_t)acc_ramp;
2D48  88124A52     LDR R2, [PC, #328]
2D4A  18A48812     LDRH R2, [R2]
2D4C  1C2218A4     ADDS R4, R4, R2
2D4E  B2A41C22     ADDS R2, R4, #0
2D50  429CB2A4     UXTH R4, R4
2D52  D900429C     CMP R4, R3
2D54  1C1AD900     BLS.N 0x2D58
2D56  B2941C1A     ADDS R2, R3, #0
2D58  E024B294     UXTH R4, R2
2D5A  4B43E024     B.N 0x2DA6
728:                               if(ref_abs < ram_abs)
729:                               {
730:                                   ram_abs = ref_abs;
731:                               }
732:                           }
733:                           else if(ref_abs < ram_abs)
2D84  D90E429C     CMP R4, R3
2D86  4A45D90E     BLS.N 0x2DA6
734:                           {
735:                               ram_abs -= (uint16_t)dec_ramp;
2D88  88124A45     LDR R2, [PC, #276]
2D8A  1AA28812     LDRH R2, [R2]
2D8C  B2921AA2     SUBS R2, R4, R2
2D8E  1C1CB292     UXTH R2, R2
2D90  42931C1C     ADDS R4, R3, #0
2D92  D2004293     CMP R3, R2
2D94  1C14D200     BCS.N 0x2D98
2D96  B2A41C14     ADDS R4, R2, #0
2D98  4B36B2A4     UXTH R4, R4
736:                               if(ref_abs > ram_abs)
737:                               {
738:                                   ram_abs = ref_abs;
739:                               }
740:                               if((uint16_t)MIN_SPE > ram_abs)
741:                               {
742:                                   ram_abs = 0;
2D9A  42A34B36     LDR R3, [PC, #216]
2D9C  419B42A3     CMP R3, R4
2D9E  401C419B     SBCS R3, R3
2DA0  E000401C     ANDS R4, R3
2DA2  2400E000     B.N 0x2DA6
743:                               }
744:                           }
745:                           else
746:                           {
747:                             /*empty else for MISRA 15.7 */
748:                           }
749:                       }
750:                   }
751:           
752:                   /* reference update */
753:                   spe_ref_abs = ram_abs;
2DA6  801C4B34     LDR R3, [PC, #208]
2DA8  4B38801C     STRH R4, [R3]
754:                   spe_ref_sgn = ram_sgn;
2DAA  801D4B38     LDR R3, [PC, #224]
2DAC  E763801D     STRH R5, [R3]
2DAE  4B3CE763     B.N 0x2C78
755:               }
756:                       //u32a = (uint32_t)(espabs_fil) * K_INTSPE2RPM;
757:           //            u32a = (uint32_t)(elespeed) * K_INTSPE2RPM;
758:           //            spe_rpm_abs = (uint16_t)(u32a >> (uint32_t)SH_BASE_VALUE);
759:               /* port_pin_set_output_level(PIN_PB31,false);*/  /* Time debug */
760:           
761:               /* phase lost check */
762:           //    phase_lost_check();
763:           
764:               /* visualization variables */
765:               switch(vis_cnt)
2C78  781A4B80     LDR R3, [PC, #512]
2C7A  2A04781A     LDRB R2, [R3]
2C7C  D9002A04     CMP R2, #4
2C7E  E0D1D900     BLS.N 0x2C82
2C80  93E0D1     B.N .LVL60
2C82  4A7E0093     LSLS R3, R2, #2
2C84  58D34A7E     LDR R2, [PC, #504]
2C86  469F58D3     LDR R3, [R2, R3]
2C88  23B4469F     MOV PC, R3
766:               {
767:                   case 0:
768:                       s32a = (int32_t)idfil * (int32_t)K_INTCUR2MA;
2DB0  22004B3C     LDR R3, [PC, #240]
2DB2  5E9A2200     MOVS R2, #0
2DB4  4B3C5E9A     LDRSH R2, [R3, R2]
2DB6  43534B3C     LDR R3, [PC, #240]
2DB8  139B4353     MULS R3, R2
769:                       /* shift on a signed quantity */
770:                       /* compiler ensures a arithmetic shift is done in these cases.
771:                         MISRA 10.1 violated for optimziation purpose */
772:                       /*lint -save -e9027 */
773:                       d_cur_a1000 = (int16_t)(s32a >> SH_BASE_VALUE);
2DBA  4A3B139B     ASRS R3, R3, #14
2DBC  80134A3B     LDR R2, [PC, #236]
2DBE  22018013     STRH R3, [R2]
774:                       /*lint -restore */
775:                       vis_cnt = 1;
2DC0  4B2E2201     MOVS R2, #1
2DC2  701A4B2E     LDR R3, [PC, #184]
2DC4  BD70701A     STRB R2, [R3]
776:                   break;
777:                   case 1:
778:                       s32a = (int32_t)iqfil * (int32_t)K_INTCUR2MA;
2DC8  22004B39     LDR R3, [PC, #228]
2DCA  5E9A2200     MOVS R2, #0
2DCC  4B365E9A     LDRSH R2, [R3, R2]
2DCE  43534B36     LDR R3, [PC, #216]
2DD0  139B4353     MULS R3, R2
779:                       /*lint -save -e9027 */
780:                       q_cur_a1000 = (int16_t)(s32a >> SH_BASE_VALUE);
2DD2  4A37139B     ASRS R3, R3, #14
2DD4  80134A37     LDR R2, [PC, #220]
2DD6  22028013     STRH R3, [R2]
781:                       /*lint -restore */
782:                       vis_cnt = 2;
2DD8  4B282202     MOVS R2, #2
2DDA  701A4B28     LDR R3, [PC, #160]
2DDC  E7F2701A     STRB R2, [R3]
783:                   break;
2DDE  4B35E7F2     B.N .LVL45
784:                   case 2:
785:                       s32a = (int32_t)vdfil * (int32_t)K_INTVOL2DV;
2DE0  22004B35     LDR R3, [PC, #212]
2DE2  5E9A2200     MOVS R2, #0
2DE4  1535E9A     LDRSH R2, [R3, R2]
2DE6  189B0153     LSLS R3, R2, #5
2DE8  129B189B     ADDS R3, R3, R2
786:                       /*lint -save -e9027 */
787:                       d_vol_v10 = (int16_t)(s32a >> SH_BASE_VALUE);
2DEA  4A33129B     ASRS R3, R3, #10
2DEC  80134A33     LDR R2, [PC, #204]
2DEE  22058013     STRH R3, [R2]
788:                       /*lint -restore*/
789:                       vis_cnt = 5;
2DF0  4B222205     MOVS R2, #5
2DF2  701A4B22     LDR R3, [PC, #136]
2DF4  E7E6701A     STRB R2, [R3]
790:                   break;
2DF6  4B31E7E6     B.N .LVL45
791:                   case 3:
792:                       s32a = (int32_t)vqfil * (int32_t)K_INTVOL2DV;
2DF8  22004B31     LDR R3, [PC, #196]
2DFA  5E9A2200     MOVS R2, #0
2DFC  1535E9A     LDRSH R2, [R3, R2]
2DFE  189B0153     LSLS R3, R2, #5
2E00  129B189B     ADDS R3, R3, R2
793:                       /*lint -save -e9027 */
794:                       q_vol_v10 = (int16_t)(s32a >> SH_BASE_VALUE);
2E02  4A2F129B     ASRS R3, R3, #10
2E04  80134A2F     LDR R2, [PC, #188]
2E06  22048013     STRH R3, [R2]
795:                       /*lint -restore*/
796:                       vis_cnt = 4;
2E08  4B1C2204     MOVS R2, #4
2E0A  701A4B1C     LDR R3, [PC, #112]
2E0C  E7DA701A     STRB R2, [R3]
797:                   break;
2E0E  4B2DE7DA     B.N .LVL45
798:                   case 4:
799:                       u32a = (uint32_t)((uint16_t)vbfil * (uint32_t)K_INTVOL2DV);
2E10  881A4B2D     LDR R3, [PC, #180]
2E12  153881A     LDRH R2, [R3]
2E14  189B0153     LSLS R3, R2, #5
2E16  A9B189B     ADDS R3, R3, R2
800:                       bus_vol_v10 = (uint16_t)(u32a >> SH_BASE_VALUE);
2E18  4A2C0A9B     LSRS R3, R3, #10
2E1A  80134A2C     LDR R2, [PC, #176]
2E1C  22058013     STRH R3, [R2]
801:                       vis_cnt = 5;
2E1E  4B162205     MOVS R2, #5
2E20  701A4B16     LDR R3, [PC, #88]
2E22  E7CF701A     STRB R2, [R3]
802:                   break;
2E24  4B2AE7CF     B.N .LVL45
803:                   case 5:
804:                   default:
805:                       u32a = (uint32_t)(espabs_fil) * K_INTSPE2RPM;
2E26  881A4B2A     LDR R3, [PC, #168]
2E28  4B0A881A     LDRH R2, [R3]
2E2A  43534B0A     LDR R3, [PC, #40]
2E2C  B9B4353     MULS R3, R2
806:                       spe_rpm_abs = (uint16_t)(u32a >> (uint32_t)SH_BASE_VALUE);
2E2E  4A280B9B     LSRS R3, R3, #14
2E30  80134A28     LDR R2, [PC, #160]
2E32  22008013     STRH R3, [R2]
807:                       vis_cnt = 0;
2E34  4B112200     MOVS R2, #0
2E36  701A4B11     LDR R3, [PC, #68]
2E38  E7C4701A     STRB R2, [R3]
808:                   break;
809:               }
810:           
811:               return;
2E3A  2947E7C4     B.N .LVL45
812:           }
2DC6  4B39BD70     POP {R4, R5, R6, PC}
2DC8  22004B39     LDR R3, [PC, #228]
2DCA  5E9A2200     MOVS R2, #0
2DCC  4B365E9A     LDRSH R2, [R3, R2]
2DCE  43534B36     LDR R3, [PC, #216]
2DD0  139B4353     MULS R3, R2
2DD2  4A37139B     ASRS R3, R3, #14
2DD4  80134A37     LDR R2, [PC, #220]
2DD6  22028013     STRH R3, [R2]
2DD8  4B282202     MOVS R2, #2
2DDA  701A4B28     LDR R3, [PC, #160]
2DDC  E7F2701A     STRB R2, [R3]
2DDE  4B35E7F2     B.N .LVL45
2DE0  22004B35     LDR R3, [PC, #212]
2DE2  5E9A2200     MOVS R2, #0
2DE4  1535E9A     LDRSH R2, [R3, R2]
2DE6  189B0153     LSLS R3, R2, #5
2DE8  129B189B     ADDS R3, R3, R2
2DEA  4A33129B     ASRS R3, R3, #10
2DEC  80134A33     LDR R2, [PC, #204]
2DEE  22058013     STRH R3, [R2]
2DF0  4B222205     MOVS R2, #5
2DF2  701A4B22     LDR R3, [PC, #136]
2DF4  E7E6701A     STRB R2, [R3]
2DF6  4B31E7E6     B.N .LVL45
2DF8  22004B31     LDR R3, [PC, #196]
2DFA  5E9A2200     MOVS R2, #0
2DFC  1535E9A     LDRSH R2, [R3, R2]
2DFE  189B0153     LSLS R3, R2, #5
2E00  129B189B     ADDS R3, R3, R2
2E02  4A2F129B     ASRS R3, R3, #10
2E04  80134A2F     LDR R2, [PC, #188]
2E06  22048013     STRH R3, [R2]
2E08  4B1C2204     MOVS R2, #4
2E0A  701A4B1C     LDR R3, [PC, #112]
2E0C  E7DA701A     STRB R2, [R3]
2E0E  4B2DE7DA     B.N .LVL45
2E10  881A4B2D     LDR R3, [PC, #180]
2E12  153881A     LDRH R2, [R3]
2E14  189B0153     LSLS R3, R2, #5
2E16  A9B189B     ADDS R3, R3, R2
2E18  4A2C0A9B     LSRS R3, R3, #10
2E1A  80134A2C     LDR R2, [PC, #176]
2E1C  22058013     STRH R3, [R2]
2E1E  4B162205     MOVS R2, #5
2E20  701A4B16     LDR R3, [PC, #88]
2E22  E7CF701A     STRB R2, [R3]
2E24  4B2AE7CF     B.N .LVL45
2E26  881A4B2A     LDR R3, [PC, #168]
2E28  4B0A881A     LDRH R2, [R3]
2E2A  43534B0A     LDR R3, [PC, #40]
2E2C  B9B4353     MULS R3, R2
2E2E  4A280B9B     LSRS R3, R3, #14
2E30  80134A28     LDR R2, [PC, #160]
2E32  22008013     STRH R3, [R2]
2E34  4B112200     MOVS R2, #0
2E36  701A4B11     LDR R3, [PC, #68]
2E38  E7C4701A     STRB R2, [R3]
2E3A  2947E7C4     B.N .LVL45
2E3C  20002947     CMP R1, #71
2E3E  1362000     MOVS R0, #0
2E40  20000136     LSLS R6, R6, #4
2E42  EA2000     MOVS R0, #0
2E44  200000EA     LSLS R2, R5, #3
2E46  290B2000     MOVS R0, #0
2E48  2000290B     CMP R1, #11
2E4A  CE2000     MOVS R0, #0
2E4C  200000CE     LSLS R6, R1, #3
2E4E  18A2000     MOVS R0, #0
2E50  2000018A     LSLS R2, R1, #6
2E52  BB82000     MOVS R0, #0
2E54  0BB8     LSRS R0, R7, #14
2E56  1140000     MOVS R0, R0
2E58  20000114     LSLS R4, R2, #4
2E5A  E82000     MOVS R0, #0
2E5C  200000E8     LSLS R0, R5, #3
2E5E  29462000     MOVS R0, #0
2E60  20002946     CMP R1, #70
2E62  FE992000     MOVS R0, #0
2E64  FFFFFE99     MRC2 P15, #4, PC, CR9, CR15, {7}
2E66  44D9FFFF     MRC2 P4, #7, R4, CR15, CR9, {6}
2E68  44D9     ADD R9, R11
2E6A  1020000     MOVS R0, R0
2E6C  20000102     LSLS R2, R0, #4
2E6E  1042000     MOVS R0, #0
2E70  20000104     LSLS R4, R0, #4
2E72  7AD2000     MOVS R0, #0
2E74  07AD     LSLS R5, R5, #30
2E76  1220000     MOVS R0, R0
2E78  20000122     LSLS R2, R4, #4
2E7A  29442000     MOVS R0, #0
2E7C  20002944     CMP R1, #68
2E7E  64642000     MOVS R0, #0
2E80  6464     STR R4, [R4, #68]
2E82  61550000     MOVS R0, R0
2E84  6155     STR R5, [R2, #20]
2E86  29430000     MOVS R0, R0
2E88  20002943     CMP R1, #67
2E8A  1322000     MOVS R0, #0
2E8C  20000132     LSLS R2, R6, #4
2E8E  29422000     MOVS R0, #0
2E90  20002942     CMP R1, #66
2E92  FE2000     MOVS R0, #0
2E94  200000FE     LSLS R6, R7, #3
2E96  62792000     MOVS R0, #0
2E98  6279     STR R1, [R7, #36]
2E9A  7AE0000     MOVS R0, R0
2E9C  07AE     LSLS R6, R5, #30
2E9E  13C0000     MOVS R0, R0
2EA0  2000013C     LSLS R4, R7, #4
2EA2  1562000     MOVS R0, #0
2EA4  20000156     LSLS R6, R2, #5
2EA6  11302000     MOVS R0, #0
2EA8  1130     ASRS R0, R6, #4
2EAA  15E0000     MOVS R0, R0
2EAC  2000015E     LSLS R6, R3, #5
2EAE  D62000     MOVS R0, #0
2EB0  200000D6     LSLS R6, R2, #3
2EB2  1002000     MOVS R0, #0
2EB4  20000100     LSLS R0, R0, #4
2EB6  13A2000     MOVS R0, #0
2EB8  2000013A     LSLS R2, R7, #4
2EBA  1182000     MOVS R0, #0
2EBC  20000118     LSLS R0, R3, #4
2EBE  D42000     MOVS R0, #0
2EC0  200000D4     LSLS R4, R2, #3
2EC2  13E2000     MOVS R0, #0
2EC4  2000013E     LSLS R6, R7, #4
2EC6  1122000     MOVS R0, #0
2EC8  20000112     LSLS R2, R2, #4
2ECA  11C2000     MOVS R0, #0
2ECC  2000011C     LSLS R4, R3, #4
2ECE  D22000     MOVS R0, #0
2ED0  200000D2     LSLS R2, R2, #3
2ED2  CC2000     MOVS R0, #0
2ED4  200000CC     LSLS R4, R1, #3
2ED6  B5F82000     MOVS R0, #0
813:           
814:           /******************************************************************************
815:           Function:    current_measurement_management
816:           Description:  calculation of internal current measurement values
817:           Input:      nothing (uses A/D converter results, already corrected from the
818:                   offsets, stored in global variables)
819:           Output:      nothing (updates some internal variables)
820:           Note:      calculates the third phase value from the other two samles;
821:                   converts the A/D results in internal current units;
822:                   calculates the two phases (a, b) vector components from the
823:                   three phases (u, v, w) vector ones
824:           ******************************************************************************/
825:            void current_measurement_management(void)
826:           {
5E84  4A09B510     PUSH {R4, LR}
827:           	int32_t s32a;
828:           	int16_t cur[3];
829:           
830:           	/* currents */
831:           	s32a = ((int32_t)cur_mea[0]) * ((int32_t)KAD_CUR);
5E86  21004A09     LDR R2, [PC, #36]
5E88  5E532100     MOVS R1, #0
5E8A  DB5E53     LDRSH R3, [R2, R1]
5E8C  425B00DB     LSLS R3, R3, #3
5E8E  2102425B     RSBS R3, R3, #0
832:           	#if (0 != SH_KAD_CUR)
833:           	cur[0] = (int16_t)(s32a >> SH_KAD_CUR);
834:           	#else
835:           	cur[0] = (int16_t)s32a;
836:           	#endif
837:           	s32a = ((int32_t)cur_mea[1]) * ((int32_t)KAD_CUR);
5E90  5E522102     MOVS R1, #2
5E92  D25E52     LDRSH R2, [R2, R1]
5E94  425200D2     LSLS R2, R2, #3
5E96  48054252     RSBS R2, R2, #0
838:           	#if (0 != SH_KAD_CUR)
839:           	cur[1] = (int16_t)(s32a >> SH_KAD_CUR);
840:           	#else
841:           	cur[1] = (int16_t)s32a;
842:           	#endif  /* else if(0 != SH_KAD_CUR) */
843:           	cur[2] = -cur[0] - cur[1];
5E9E  425B189B     ADDS R3, R3, R2
5EA0  8083425B     RSBS R3, R3, #0
844:           	cur3m.u = cur[0];
5E98  80034805     LDR R0, [PC, #20]
5E9A  80428003     STRH R3, [R0]
845:           	cur3m.v = cur[1];
5E9C  189B8042     STRH R2, [R0, #2]
846:           	cur3m.w = cur[2];
5EA2  49038083     STRH R3, [R0, #4]
847:           	//REG_PORT_OUTTGL0 =  0x00020000U;
848:           //	REG_PORT_OUT0 =  REG_PORT_OUT0 | 0x00020000U;
849:           	library_uvw_ab(&cur3m, &curabm);
5EA4  4B044903     LDR R1, [PC, #12]
5EA6  47984B04     LDR R3, [PC, #16]
5EA8  BD104798     BLX R3
850:           //	REG_PORT_OUT0 =  REG_PORT_OUT0 & 0xFFFDFFFFU;
851:           	//REG_PORT_OUTTGL0 =  0x00020000U;
852:           
853:           }
5EAA  10CBD10     POP {R4, PC}
5EAC  2000010C     LSLS R4, R1, #4
5EAE  28602000     MOVS R0, #0
5EB0  20002860     CMP R0, #96
5EB2  287C2000     MOVS R0, #0
5EB4  2000287C     CMP R0, #124
5EB6  5C3D2000     MOVS R0, #0
5EB8  5C3D     LDRB R5, [R7, R0]
5EBA  B5100000     MOVS R0, R0
854:           
855:           /******************************************************************************
856:           Function:    pwm_modulation_reset
857:           Description:  resets internal variables used in pwm modulation, and sets
858:                   the unactive value into the pwm registers
859:           Input:      nothing
860:           Output:      nothing
861:           ******************************************************************************/
862:           static inline void pwm_modulation_reset(void)
863:           {
864:               outv3.u = 0;
1566  23004A9B     LDR R2, [PC, #620]
865:               outv3.v = 0;
156C  80938053     STRH R3, [R2, #2]
866:               outv3.w = 0;
156E  22968093     STRH R3, [R2, #4]
867:               du = (int16_t)PWM_HPER_TICKS;
1570  1122296     MOVS R2, #150
868:               dv = (int16_t)PWM_HPER_TICKS;
1578  800A4998     LDR R1, [PC, #608]
869:               dw = (int16_t)PWM_HPER_TICKS;
157C  800A4998     LDR R1, [PC, #608]
870:               dutycycle[0] = (int32_t)PWM_HPER_TICKS;
871:               dutycycle[1] = (int32_t)PWM_HPER_TICKS;
872:               dutycycle[2] = (int32_t)PWM_HPER_TICKS;
873:               /*Using register address of TCC0 */
874:               /*lint -save -e9078 -e923 */
875:              	
876:                
877:           		TCC0_REGS->TCC_CCBUF[0] = dutycycle[0];
1580  670A4998     LDR R1, [PC, #608]
878:           		TCC0_REGS->TCC_CCBUF[1] = dutycycle[1];
1584  678A674A     STR R2, [R1, #116]
879:           		TCC0_REGS->TCC_CCBUF[2] = dutycycle[2];
1586  4A97678A     STR R2, [R1, #120]
880:           		
881:           	    /*lint -restore */
882:           }
883:           
884:           /******************************************************************************
885:           Function:    pwm_modulation
886:           Description:  output duties calc, and three shunts current reading order
887:                   determination
888:           Input:      nothing (uses global variables vbus and outvab)
889:           Output:      nothing (directly updates the duty registers)
890:           Note:      implements a clamped modulation (min-max);
891:                   in case of clamping (hexagonal saturation), it re-calculates
892:                   the output voltage value to keep the saturation into account
893:           ******************************************************************************/
894:           //static inline void pwm_modulation(void)
895:            void pwm_modulation(void)
896:           {
3990  497CB5F8     PUSH {R3, R4, R5, R6, R7, LR}
897:             int32_t s32a;
898:             /* addresses of min, med and max duty */
899:             int16_t *amin, *amed, *amax;  
900:             int16_t s16a, n_shft;
901:           
902:             /* reverse-Clarke transformation */
903:             library_ab_uvw(&outvab, &outv3);
3992  487C497C     LDR R1, [PC, #496]
3994  4B7D487C     LDR R0, [PC, #496]
3996  47984B7D     LDR R3, [PC, #500]
3998  4B7D4798     BLX R3
904:           
905:             /* duty-cycles calculation
906:               the formula is duty = halfper * (vbus - vout) / vbus; 
907:               to avoid repeated divisions, we calculate
908:               the constant k = halfper * (1 << n_shft) / vbus, 
909:               where n_shft is found in order to have k inside the range of short integers;
910:               the condition is k < 32768, and this is true if HALFPER_NRM < vbus, 
911:               since HALFPER_NRM = PWM_HPER_TICKS * (1 << SH_BASE_VALUE) / 32768.0f */
912:             s16a = (int16_t)HALFPER_NRM;
913:             n_shft = (int16_t)SH_BASE_VALUE;
3AC0  E77A230E     MOVS R3, #14
3AC2  493DE77A     B.N .LVL74
914:             while(s16a >= vbus)
399A  24004B7D     LDR R3, [PC, #500]
399C  5F1C2400     MOVS R4, #0
399E  23965F1C     LDRSH R4, [R3, R4]
39A0  DB2396     MOVS R3, #150
39A2  429C00DB     LSLS R3, R3, #3
39A4  DD00429C     CMP R4, R3
39A6  E08ADD00     BLE.N 0x39AA
39A8  230EE08A     B.N .LVL106
39AA  2296230E     MOVS R3, #14
39AC  D22296     MOVS R2, #150
39AE  105200D2     LSLS R2, R2, #3
39B6  DAFA42A2     CMP R2, R4
39B8  1DDAFA     BGE.N .LVL70
915:             {
916:                 /* compiler ensures a arithmetic shift is done in these cases.
917:                 MISRA 10.1 violated for optimziation purpose */
918:                 /*lint -save -e9027 */
919:                 s16a >>= 1;
39B0  3B011052     ASRS R2, R2, #1
39B2  B21B3B01     SUBS R3, #1
39B4  42A2B21B     SXTH R3, R3
920:                n_shft--;
921:             }
922:             s32a = (int32_t)PWM_HPER_TICKS;
923:             s32a <<= n_shft;
39BA  2096001D     MOVS R5, R3
39BC  1002096     MOVS R0, #150
39BE  40980100     LSLS R0, R0, #4
39C0  4B744098     LSLS R0, R3
924:                   if(VBUSMIN <= vbus)
39C2  429C4B74     LDR R3, [PC, #464]
39C4  DC00429C     CMP R4, R3
39C6  E07CDC00     BGT.N 0x39CA
39C8  21E07C     B.N .LVL107
925:                   {
926:                     s16a = (int16_t)(s32a / vbus);
39CA  4B720021     MOVS R1, R4
39CC  47984B72     LDR R3, [PC, #456]
39CE  B2024798     BLX R3
39D0  486CB202     SXTH R2, R0
927:                   }
928:                   else
929:                   {
930:                     s16a = (int16_t)(s32a / VBUSMIN);
3AC4  4B34493D     LDR R1, [PC, #244]
3AC6  47984B34     LDR R3, [PC, #208]
3AC8  B2024798     BLX R3
3ACA  E781B202     SXTH R2, R0
3ACC  2201E781     B.N .LVL77
931:                   }
932:             s32a = ((int32_t)vbus - (int32_t)outv3.u) * (int32_t)s16a;
39D2  2300486C     LDR R0, [PC, #432]
39D4  5EC12300     MOVS R3, #0
39D6  1A615EC1     LDRSH R1, [R0, R3]
39D8  43511A61     SUBS R1, R4, R1
39DA  41294351     MULS R1, R2
933:                   du = (int16_t)(s32a >> n_shft);
39DC  B2094129     ASRS R1, R5
39DE  4B6EB209     SXTH R1, R1
39E0  80194B6E     LDR R3, [PC, #440]
39E2  26028019     STRH R1, [R3]
934:             s32a = ((int32_t)vbus - (int32_t)outv3.v) * (int32_t)s16a;
39E4  5F832602     MOVS R6, #2
39E6  1AE35F83     LDRSH R3, [R0, R6]
39E8  43531AE3     SUBS R3, R4, R3
39EA  412B4353     MULS R3, R2
935:             dv = (int16_t)(s32a >> n_shft);
39EC  B21B412B     ASRS R3, R5
39EE  4E6BB21B     SXTH R3, R3
39F0  80334E6B     LDR R6, [PC, #428]
39F2  26048033     STRH R3, [R6]
936:             s32a = ((int32_t)vbus - (int32_t)outv3.w) * (int32_t)s16a;
39F4  5F802604     MOVS R6, #4
39F6  1A205F80     LDRSH R0, [R0, R6]
39F8  43501A20     SUBS R0, R4, R0
39FA  41284350     MULS R0, R2
937:             dw = (int16_t)(s32a >> n_shft);
39FC  B2004128     ASRS R0, R5
39FE  4A68B200     SXTH R0, R0
3A00  80104A68     LDR R2, [PC, #416]
3A02  42998010     STRH R0, [R2]
938:                   /*lint -restore */
939:           
940:             /* finding duties order:
941:               phaseindex[0] will be the index of minimum duty,
942:               phaseindex[1] will be the index of intermediate duty,
943:               phaseindex[2] will be the index of maximum duty */
944:             if(du >= dv)
3A04  DA004299     CMP R1, R3
3A06  E077DA00     BGE.N 0x3A0A
3A08  4283E077     B.N .LVL115
945:             {
946:               if(dv >= dw)
3A0A  DB5F4283     CMP R3, R0
3A0C  4B66DB5F     BLT.N 0x39CE
947:               {
948:                 amin = &dw;
3A20  88234E60     LDR R6, [PC, #384]
949:                 phaseindex[0] = 2;
3A0E  22024B66     LDR R3, [PC, #408]
3A10  701A2202     MOVS R2, #2
3A12  3A01701A     STRB R2, [R3]
950:                 amed = &dv;
3A1E  4E604C60     LDR R4, [PC, #384]
951:                 phaseindex[1] = 1;
3A14  705A3A01     SUBS R2, #1
3A16  2200705A     STRB R2, [R3, #1]
952:                 amax = &du;
3A1C  4C604D5F     LDR R5, [PC, #380]
953:                 phaseindex[2] = 0;
3A18  709A2200     MOVS R2, #0
3A1A  4D5F709A     STRB R2, [R3, #2]
954:               }
955:               else
956:               {
957:                 amin = &dv;
3AE4  E79C4E2E     LDR R6, [PC, #184]
3AE6  4B2FE79C     B.N .LVL86
3AF6  E7934E2A     LDR R6, [PC, #168]
3AF8  4281E793     B.N .LVL86
958:                 phaseindex[0] = 1;
3ACE  4B352201     MOVS R2, #1
3AD0  701A4B35     LDR R3, [PC, #212]
3AD2  4281701A     STRB R2, [R3]
959:                 if(du >= dw)
3AD4  DB074281     CMP R1, R0
3AD6  3201DB07     BLT.N .LVL113
960:                 {
961:                   amed = &dw;
3AE2  4E2E4C30     LDR R4, [PC, #192]
962:                   phaseindex[1] = 2;
3AD8  705A3201     ADDS R2, #1
3ADA  2200705A     STRB R2, [R3, #1]
963:                   amax = &du;
3AE0  4C304D2E     LDR R5, [PC, #184]
964:                   phaseindex[2] = 0;
3ADC  709A2200     MOVS R2, #0
3ADE  4D2E709A     STRB R2, [R3, #2]
965:                 }
966:                 else
967:                 {
968:                   amed = &du;
3AF4  4E2A4C29     LDR R4, [PC, #164]
969:                   phaseindex[1] = 0;
3AE8  22004B2F     LDR R3, [PC, #188]
3AEA  705A2200     MOVS R2, #0
3AEC  3202705A     STRB R2, [R3, #1]
970:                   amax = &dw;
3AF2  4C294D2C     LDR R5, [PC, #176]
971:                   phaseindex[2] = 2;
3AEE  709A3202     ADDS R2, #2
3AF0  4D2C709A     STRB R2, [R3, #2]
972:                 }
973:               }
974:             }
975:             else
976:             {
977:               if(du >= dw)
3AFA  DB0A4281     CMP R1, R0
3AFC  4B2ADB0A     BLT.N .LVL119
978:               {
979:                 amin = &dw;
3B10  E7864E24     LDR R6, [PC, #144]
3B12  2100E786     B.N .LVL86
980:                 phaseindex[0] = 2;
3AFE  22024B2A     LDR R3, [PC, #168]
3B00  701A2202     MOVS R2, #2
3B02  2200701A     STRB R2, [R3]
981:                 amed = &du;
3B0E  4E244C23     LDR R4, [PC, #140]
982:                 phaseindex[1] = 0;
3B04  705A2200     MOVS R2, #0
3B06  3201705A     STRB R2, [R3, #1]
983:                 amax = &dv;
3B0C  4C234D24     LDR R5, [PC, #144]
984:                 phaseindex[2] = 1;
3B08  709A3201     ADDS R2, #1
3B0A  4D24709A     STRB R2, [R3, #2]
985:               }
986:               else
987:               {
988:                 amin = &du;
3B2C  E7784E1B     LDR R6, [PC, #108]
3B2E  4B1DE778     B.N .LVL86
3B3E  E76F4E17     LDR R6, [PC, #92]
3B40  240EE76F     B.N .LVL86
989:                 phaseindex[0] = 0;
3B14  4A242100     MOVS R1, #0
3B16  70114A24     LDR R2, [PC, #144]
3B18  42837011     STRB R1, [R2]
990:                 if(dv >= dw)
3B1A  DB084283     CMP R3, R0
3B1C  13DB08     BLT.N .LVL122
991:                 {
992:                   amed = &dw;
3B2A  4E1B4C1E     LDR R4, [PC, #120]
993:                   phaseindex[1] = 2;
3B1E  22020013     MOVS R3, R2
3B20  705A2202     MOVS R2, #2
3B22  3A01705A     STRB R2, [R3, #1]
994:                   amax = &dv;
3B28  4C1E4D1D     LDR R5, [PC, #116]
995:                   phaseindex[2] = 1;
3B24  709A3A01     SUBS R2, #1
3B26  4D1D709A     STRB R2, [R3, #2]
996:                 }
997:                 else
998:                 {
999:                   amed = &dv;
3B3C  4E174C18     LDR R4, [PC, #96]
1000:                  phaseindex[1] = 1;
3B30  22014B1D     LDR R3, [PC, #116]
3B32  705A2201     MOVS R2, #1
3B34  3201705A     STRB R2, [R3, #1]
1001:                  amax = &dw;
3B3A  4C184D1A     LDR R5, [PC, #104]
1002:                  phaseindex[2] = 2;
3B36  709A3201     ADDS R2, #1
3B38  4D1A709A     STRB R2, [R3, #2]
1003:                }
1004:              }
1005:            }
1006:          
1007:            /* duties differences calculation */
1008:            (*amed) -= (*amin);
3A22  88328823     LDRH R3, [R4]
3A24  1A9B8832     LDRH R2, [R6]
3A26  80231A9B     SUBS R3, R3, R2
3A28  88298023     STRH R3, [R4]
1009:            (*amax) -= (*amin);
3A2A  88338829     LDRH R1, [R5]
3A2C  1AC98833     LDRH R3, [R6]
3A2E  B2091AC9     SUBS R1, R1, R3
3A30  8029B209     SXTH R1, R1
3A32  4B5D8029     STRH R1, [R5]
1010:          
1011:            /* maximum limit control (and saturation) */
1012:            if((int16_t)DELMAX_TICKS < (*amax))
3A34  42994B5D     LDR R3, [PC, #372]
3A36  DC004299     CMP R1, R3
3A38  E084DC00     BGT.N .LVL87
3A3A  2300E084     B.N .LVL126
1013:            {
1014:              /* duties clamp */
1015:              s32a = (int32_t)(*amed) * (int32_t)DELMAX_TICKS;
3A3C  5EE02300     MOVS R3, #0
3A3E  4F5A5EE0     LDRSH R0, [R4, R3]
3A40  43784F5A     LDR R7, [PC, #360]
3A42  4B544378     MULS R0, R7
1016:              (*amed) = (int16_t)(s32a / (*amax));
3A44  47984B54     LDR R3, [PC, #336]
3A46  80204798     BLX R3
3A48  802F8020     STRH R0, [R4]
1017:              (*amax) = (int16_t)DELMAX_TICKS;
3A4A  233C802F     STRH R7, [R5]
1018:          
1019:              /* duties update */
1020:              (*amin) = (int16_t)PWM_HPER_TICKS - (*amax);
3A4C  8033233C     MOVS R3, #60
3A4E  88238033     STRH R3, [R6]
1021:              /* surely greater than DMIN, due to previous clamp 
1022:              ((*amax) <= DELMAX_TICKS) */
1023:              (*amed) += (*amin);
3A50  333C8823     LDRH R3, [R4]
3A52  8023333C     ADDS R3, #60
3A54  23968023     STRH R3, [R4]
1024:              (*amax) = (int16_t)PWM_HPER_TICKS;
3A56  11B2396     MOVS R3, #150
3A58  802B011B     LSLS R3, R3, #4
3A5A  4B4F802B     STRH R3, [R5]
1025:          
1026:              /* set output duties */
1027:              dutycycle[0] = (int32_t)du;
3A5C  26004B4F     LDR R3, [PC, #316]
3A5E  5F9E2600     MOVS R6, #0
3A60  4B4F5F9E     LDRSH R6, [R3, R6]
1028:              dutycycle[1] = (int32_t)dv;
3A62  25004B4F     LDR R3, [PC, #316]
3A64  5F5D2500     MOVS R5, #0
3A66  4B4E5F5D     LDRSH R5, [R3, R5]
1029:              dutycycle[2] = (int32_t)dw;
3A68  27004B4E     LDR R3, [PC, #312]
3A6A  5FDF2700     MOVS R7, #0
3A6C  4B505FDF     LDRSH R7, [R3, R7]
1030:              /*Using register address of TCC0 */
1031:              /*lint -save -e9078 -e923 */
1032:              	
1033:          		TCC0_REGS->TCC_CCBUF[0] = dutycycle[0];
3A6E  671E4B50     LDR R3, [PC, #320]
3A70  675D671E     STR R6, [R3, #112]
1034:          		TCC0_REGS->TCC_CCBUF[1] = dutycycle[1];
3A72  679F675D     STR R5, [R3, #116]
1035:          		TCC0_REGS->TCC_CCBUF[2] = dutycycle[2];
3A74  4B46679F     STR R7, [R3, #120]
1036:          	
1037:          	
1038:          	
1039:              /*lint -restore*/
1040:          
1041:              /* output voltages re-calculation 
1042:                (necessary because a clamp has been executed);
1043:                the formula is vout = vbus * (halfper - duty) / halfper, 
1044:                and to avoid repeated divisions we calculate
1045:                the constant h = vbus * (1 << n_shft) / halfper */
1046:              /* first find the number of shifts which warrants that the 
1047:                 result of the division stays in a short integer variable */
1048:              s32a = (int32_t)vbus * (int32_t)BASE_VALUE_INT;
3A76  20004B46     LDR R3, [PC, #280]
3A78  5E182000     MOVS R0, #0
3A7A  3805E18     LDRSH R0, [R3, R0]
3A7C  4B4D0380     LSLS R0, R0, #14
1049:              n_shft = (int16_t)SH_BASE_VALUE;
3B42  E7A4240E     MOVS R4, #14
3B44  1049E7A4     B.N .LVL97
1050:              /*lint -save -e9027 */
1051:              /* HALFPER_A15 is defined as PWM_HPER_TICKS * 32768 */
1052:              while((int32_t)HALFPER_A15 <= s32a)  
3A7E  42984B4D     LDR R3, [PC, #308]
3A80  DD5E4298     CMP R0, R3
3A82  240EDD5E     BLE.N 0x3A42
3A84  1040240E     MOVS R4, #14
3A8C  DCFA4298     CMP R0, R3
3A8E  2196DCFA     BGT.N .LVL93
1053:              {
1054:                s32a >>= 1;
3A86  3C011040     ASRS R0, R0, #1
3A88  B2243C01     SUBS R4, #1
3A8A  4298B224     SXTH R4, R4
1055:                n_shft--;
1056:              }
1057:              /* this is the division which result must stay in a short int */
1058:              s16a = (int16_t)(s32a / (int32_t)PWM_HPER_TICKS);    
3A90  1092196     MOVS R1, #150
3A92  4B400109     LSLS R1, R1, #4
3A94  47984B40     LDR R3, [PC, #256]
3A96  B2034798     BLX R3
1059:              s32a = ((int32_t)PWM_HPER_TICKS - (int32_t)du) * (int32_t)s16a;
3A98  483AB203     SXTH R3, R0
3A9C  1122296     MOVS R2, #150
3A9E  1B960112     LSLS R2, R2, #4
3AA0  435E1B96     SUBS R6, R2, R6
3AA2  4126435E     MULS R6, R3
1060:              outv3.u = (int16_t)(s32a >> n_shft);
3A9A  2296483A     LDR R0, [PC, #232]
3AA4  80064126     ASRS R6, R4
3AA6  1B558006     STRH R6, [R0]
1061:              s32a = ((int32_t)PWM_HPER_TICKS - (int32_t)dv) * (int32_t)s16a;
3AA8  435D1B55     SUBS R5, R2, R5
3AAA  4125435D     MULS R5, R3
1062:              outv3.v = (int16_t)(s32a >> n_shft);
3AAC  80454125     ASRS R5, R4
3AAE  1BD78045     STRH R5, [R0, #2]
1063:              s32a = ((int32_t)PWM_HPER_TICKS - (int32_t)dw) * (int32_t)s16a;
3AB0  437B1BD7     SUBS R7, R2, R7
3AB2  4123437B     MULS R3, R7
1064:              outv3.w = (int16_t)(s32a >> n_shft);
3AB4  80834123     ASRS R3, R4
3AB6  49338083     STRH R3, [R0, #4]
1065:          
1066:              /* update output voltage after modulation
1067:               clamping (Clarke transformation) */
1068:              library_uvw_ab(&outv3, &outvab);
3AB8  4B3F4933     LDR R1, [PC, #204]
3ABA  47984B3F     LDR R3, [PC, #252]
3ABC  BDF84798     BLX R3
1069:              /*lint -restore*/
1070:            }
1071:            else
1072:            {
1073:                  /* duties update */
1074:          #if 0  /* 2-phase modulation */
1075:              /* duties update */
1076:              (*amin) = (int16_t)PWM_HPER_TICKS - (*amax);
1077:              /* surely greater than DMIN, due to previous 
1078:              comparison ((*amax) <= DELMAX_TICKS) */
1079:              (*amed) += (*amin);
1080:              (*amax) = (int16_t)PWM_HPER_TICKS;
1081:          #else  /* center-aligned modulation */
1082:              (*amin) = HALF_HPER_TICKS - (*amax>>1);
3B46  23961049     ASRS R1, R1, #1
3B48  DB2396     MOVS R3, #150
3B4A  1A5900DB     LSLS R3, R3, #3
3B4C  B2891A59     SUBS R1, R3, R1
3B4E  8031B289     UXTH R1, R1
3B50  882B8031     STRH R1, [R6]
1083:              (*amax) += (*amin);
3B52  18C9882B     LDRH R3, [R5]
3B54  802918C9     ADDS R1, R1, R3
3B56  88238029     STRH R1, [R5]
1084:              (*amed) += (*amin);
3B58  88328823     LDRH R3, [R4]
3B5A  189B8832     LDRH R2, [R6]
3B5C  8023189B     ADDS R3, R3, R2
3B5E  4B0E8023     STRH R3, [R4]
1085:          #endif
1086:          
1087:              /* set output duties */
1088:              dutycycle[0] = du;
3B60  21004B0E     LDR R3, [PC, #56]
3B62  5E592100     MOVS R1, #0
3B64  4B0E5E59     LDRSH R1, [R3, R1]
1089:              dutycycle[1] = dv;
3B66  22004B0E     LDR R3, [PC, #56]
3B68  5E9A2200     MOVS R2, #0
3B6A  4B0D5E9A     LDRSH R2, [R3, R2]
1090:              dutycycle[2] = dw;
3B6C  20004B0D     LDR R3, [PC, #52]
3B6E  5E182000     MOVS R0, #0
3B70  1A8C5E18     LDRSH R0, [R3, R0]
1091:              delta_duty = du-dv;
3B72  4B121A8C     SUBS R4, R1, R2
3B74  601C4B12     LDR R3, [PC, #72]
3B76  4B0D601C     STR R4, [R3]
1092:              /*Using register address of TCC0 */
1093:              /*lint -save -e9078 -e923 */
1094:              	
1095:          		TCC0_REGS->TCC_CCBUF[0] = dutycycle[0];
3B78  67194B0D     LDR R3, [PC, #52]
3B7A  675A6719     STR R1, [R3, #112]
1096:          		TCC0_REGS->TCC_CCBUF[1] = dutycycle[1];
3B7C  6798675A     STR R2, [R3, #116]
1097:          		TCC0_REGS->TCC_CCBUF[2] = dutycycle[2];
3B7E  E79D6798     STR R0, [R3, #120]
1098:          	
1099:              /*lint -restore*/
1100:            }
1101:          
1102:          }  /* end of function pwm_modulation()*/
3ABE  230EBDF8     POP {R3, R4, R5, R6, R7, PC}
3B80  46C0E79D     B.N .LVL105
3B82  286846C0     MOV R8, R8
3B84  20002868     CMP R0, #104
3B86  28A82000     MOVS R0, #0
3B88  200028A8     CMP R0, #168
3B8A  622D2000     MOVS R0, #0
3B8C  622D     STR R5, [R5, #32]
3B8E  29280000     MOVS R0, R0
3B90  20002928     CMP R1, #40
3B92  CCB2000     MOVS R0, #0
3B94  0CCB     LSRS R3, R1, #19
3B96  41D10000     MOVS R0, R0
3B98  41D1     RORS R1, R2
3B9A  28660000     MOVS R0, R0
3B9C  20002866     CMP R0, #102
3B9E  286E2000     MOVS R0, #0
3BA0  2000286E     CMP R0, #110
3BA2  28762000     MOVS R0, #0
3BA4  20002876     CMP R0, #118
3BA6  29082000     MOVS R0, #0
3BA8  20002908     CMP R1, #8
3BAA  9242000     MOVS R0, #0
3BAC  0924     LSRS R4, R4, #4
3BAE  24000000     MOVS R0, R0
3BB0  42002400     MOVS R4, #0
3BB2  FFFF4200     TST R0, R0
3BB4  4AFFFFF     CDP2 P4, #15, CR0, CR15, CR15, {5}
3BB6  5C3D04AF     LSLS R7, R5, #18
3BB8  5C3D     LDRB R5, [R7, R0]
3BBA  CCC0000     MOVS R0, R0
3BBC  0CCC     LSRS R4, R1, #19
3BBE  28900000     MOVS R0, R0
3BC0  20002890     CMP R0, #144
3BC2  2000     MOVS R0, #0
1103:          
1104:          /******************************************************************************
1105:          Function:    pos_lost_control_reset
1106:          Description:  reset of internal variables used in "pos_lost_control"
1107:          Input:      nothing
1108:          Output:      nothing
1109:          Modifies:    global variable plost_cnt
1110:          ******************************************************************************/
1111:          static inline void pos_lost_control_reset(void)
1112:          {
1113:            plost_cnt = 0;
1114:          }
1115:          
1116:          /******************************************************************************
1117:          Function:    pos_lost_control
1118:          Description:  loosing of control of the phase estimation algorithm check
1119:          Input:      nothing (uses the global variable elespeed_abs)
1120:          Output:      nothing (in case produce an alarm)
1121:          Note:      compares the estimated speed with opportune limits to decide
1122:                  if the estimation algorithm behaviour is consistent
1123:          Modifies:    global alarm, if needed
1124:          ******************************************************************************/
1125:          static inline void pos_lost_control(void)
1126:          {
1127:              uint16_t u16a;
1128:          
1129:            if(POS_LOST_CNTMX <= plost_cnt)
1130:            {
1131:              motor_stop();
1132:              motor_stop_source = POS_LOST_STOP;
1133:              alarm = POS_LOST_ALL;
1134:              plost_cnt = 0;
1135:            }
1136:            else if(0 != spe_ref_sgn)
1137:            {
1138:              u16a = spe_ref_fil;
1139:              u16a <<= 1;
1140:              u16a += 1000U;
1141:              if ((MIN_SPE_PLOST > elespeed_abs) ||
1142:                  (MAX_SPE_PLOST < elespeed_abs) ||
1143:                  (u16a < elespeed_abs)           )
1144:              {
1145:                plost_cnt++;
1146:              }
1147:              else if(1 < plost_cnt)
1148:              {
1149:                plost_cnt -= 2;
1150:              }
1151:              else
1152:              {
1153:                  /*no action */
1154:              }
1155:            }
1156:            else
1157:            {
1158:              if(MIN_SPE < elespeed_abs)
1159:              {
1160:                plost_cnt++;
1161:              }
1162:              else if(0 < plost_cnt)
1163:              {
1164:                plost_cnt --;
1165:              }
1166:              else
1167:              {
1168:                    /* empty else no action */
1169:              }
1170:            }
1171:          }
1172:          
1173:          
1174:          /**
1175:           * \brief check for loss of phase
1176:           *
1177:           * This function will check whether a phase loss obtained
1178:           * between 2 phases
1179:           *
1180:           * \param[in] void
1181:           *
1182:           * \return void
1183:           * Function interval: 10 milli seconds (interrupt time domain)
1184:           *
1185:           * checking if one of the three motor connections is broken
1186:             Note:      this function can be called in the main loop every 10ms;
1187:                  the time constant of the filters (much higher than 10ms)
1188:                  assures than no aliasing is present;
1189:                  the working principle is the following: if one of the three
1190:                  lowpass-filtered absolute values of the currents is significantly
1191:                  lesser than the median of the three, this means that one of the three
1192:                  is missing; this is true is the filter time constant is higher
1193:                  than the sinusoid period; we retain that one of the three is
1194:                  significantly lesser than the median if it is lesser than (3/4)
1195:                  of the media (0.75)
1196:          ******************************************************************************/
1197:          #define PHASE_LOSS_ERROR_LIMIT  (PHLOST_CNT_MAX)
1198:          void phase_lost_check(void)
1199:          {
0000  20007FF8     LDRB R0, [R7, #31]
1200:            uint16_t u16a,u16u, u16v, u16w;
1201:            uint32_t u32a;
1202:          
1203:            /* sampling of the three filtered values (no problems if an
1204:            interrupt comes in the middle, due to filters) */
1205:            u16u = ufil;
0002  596D2000     MOVS R0, #0
1206:            u16v = vfil;
0006  653D0000     MOVS R0, R0
1207:            u16w = wfil;
000A  653F0000     MOVS R0, R0
1208:          
1209:            /* medium value */  /* 3 times the median */
1210:            u32a = (uint32_t)u16u + (uint32_t)u16v + (uint32_t)u16w;    
000E  0000     MOVS R0, R0
1211:            u16a = (uint16_t)(u32a >> 2U);                   /* 3/4 of the median */
1212:            u32a = (uint32_t)u16a * (uint32_t)K_THR_PHLOST;
1213:            u16a = (uint16_t)(u32a >> SH_THR_PHLOST);
0016  0000     MOVS R0, R0
1214:          
1215:          
1216:            /* phase u comparison */
1217:            if(u16u < u16a)
001C  0000     MOVS R0, R0
1218:            {
1219:              ++uall_cnt;
0020  0000     MOVS R0, R0
1220:              if(PHASE_LOSS_ERROR_LIMIT < uall_cnt)
002A  54FB0000     MOVS R0, R0
1221:              {
1222:                motor_stop();
002E  0000     MOVS R0, R0
1223:                motor_stop_source = PHASE_U_LOSS;
0032  0000     MOVS R0, R0
1224:                spe_ref_sgn = 0;
0038  54FB     STRB R3, [R7, R3]
1225:                motor_status = STOPPED;
003E  54FB0000     MOVS R0, R0
1226:          
1227:                alarm = PHASE_U_LOST_ALL;
0044  54FB     STRB R3, [R7, R3]
1228:                uall_cnt = 0;
004A  5BF50000     MOVS R0, R0
1229:                vall_cnt = 0;
004E  54FB0000     MOVS R0, R0
1230:                wall_cnt = 0;
0052  54FB0000     MOVS R0, R0
1231:              }
1232:            }
1233:            else if(1U < uall_cnt)
006E  54FB0000     MOVS R0, R0
1234:            {
1235:              uall_cnt -= 2U;
0076  54FB0000     MOVS R0, R0
1236:            }
1237:            else
1238:            {
1239:              /* no action */
1240:            }
1241:          
1242:            /* v comparison */
1243:            if(u16v < u16a)
0056  54FB0000     MOVS R0, R0
007C  54FB     STRB R3, [R7, R3]
1244:            {
1245:              ++vall_cnt;
005A  54FB0000     MOVS R0, R0
0080  54FB     STRB R3, [R7, R3]
1246:              if(PHASE_LOSS_ERROR_LIMIT < vall_cnt)
008A  54FB0000     MOVS R0, R0
1247:              {
1248:                motor_stop();
008E  54FB0000     MOVS R0, R0
1249:                motor_stop_source = PHASE_V_LOSS;
0092  54FB0000     MOVS R0, R0
1250:                spe_ref_sgn = 0;
0098  54FB     STRB R3, [R7, R3]
1251:                motor_status = STOPPED;
009E  54FB0000     MOVS R0, R0
1252:          
1253:                alarm = PHASE_V_LOST_ALL;
00A4  60FD     STR R5, [R7, #12]
1254:                uall_cnt = 0;
00AA  54FB0000     MOVS R0, R0
1255:                vall_cnt = 0;
00AE  54FB0000     MOVS R0, R0
1256:                wall_cnt = 0;
00B2  54FB0000     MOVS R0, R0
1257:              }
1258:            }
1259:            else if(1U < vall_cnt)
00C4  4770469E     MOV LR, R3
1260:            {
1261:              vall_cnt -= 2U;
00CC  58D5     LDR R5, [R2, R3]
1262:            }
1263:            else
1264:            {
1265:              /* no action */
1266:            }
1267:          
1268:            /* w comparison */
1269:            if(u16w < u16a)
0060  54FB     STRB R3, [R7, R3]
00B6  54FB0000     MOVS R0, R0
00D2  BCF846C0     MOV R8, R8
1270:            {
1271:              ++wall_cnt;
0064  54FB     STRB R3, [R7, R3]
00BA  B5F80000     MOVS R0, R0
00D6  469EBC08     POP {R3}
1272:              if(PHASE_LOSS_ERROR_LIMIT < wall_cnt)
00E0  B085B5F0     PUSH {R4, R5, R6, R7, LR}
00E2  9202B085     SUB SP, #20
1273:              {
1274:                motor_stop();
00E4  93039202     STR R2, [SP, #8]
00E6  234C9303     STR R3, [SP, #12]
1275:                motor_stop_source = PHASE_W_LOSS;
00E8  5CC2234C     MOVS R3, #76
00EA  3B3D5CC2     LDRB R2, [R0, R3]
00EC  40133B3D     SUBS R3, #61
1276:                spe_ref_sgn = 0;
00EE  6514013     ANDS R3, R2
00F0  D4000651     LSLS R1, R2, #25
00F2  E067D400     BMI.N 0xF6
1277:                motor_status = STOPPED;
00F4  2B04E067     B.N 0x1C6
00F6  D0042B04     CMP R3, #4
00F8  2B08D004     BEQ.N 0x104
00FA  D02B2B08     CMP R3, #8
00FC  2000D02B     BEQ.N 0x156
1278:          
1279:                alarm = PHASE_W_LOST_ALL;
00FA  D02B2B08     CMP R3, #8
00FC  2000D02B     BEQ.N 0x156
00FE  B0052000     MOVS R0, #0
1280:                uall_cnt = 0;
0100  BDF0B005     ADD SP, #20
0102  6C03BDF0     POP {R4, R5, R6, R7, PC}
1281:                vall_cnt = 0;
0104  6B846C03     LDR R3, [R0, #64]
0106  9D026B84     LDR R4, [R0, #56]
1282:                wall_cnt = 0;
0108  22749D02     LDR R5, [SP, #8]
010A  5C822274     MOVS R2, #116
010C  2A015C82     LDRB R2, [R0, R2]
010E  D0102A01     CMP R2, #1
0110  1C21D010     BEQ.N 0x134
1283:              }
1284:            }
1285:            else if(1U < wall_cnt)
010E  D0102A01     CMP R2, #1
0110  1C21D010     BEQ.N 0x134
0112  1C181C21     ADDS R1, R4, #0
0114  F0051C18     ADDS R0, R3, #0
1286:            {
1287:              wall_cnt -= 2U;
0116  FB0FF005     BL 0x5738
0118  2800FB0F     MLA R8, PC, R0, R2
011A  D1002800     CMP R0, #0
011C  E16ED100     BNE.N 0x120
011E  2601E16E     B.N 0x3FE
1288:            }
1289:            else
1290:            {
1291:              /* no action */
1292:            }
1293:          }
011C  E16ED100     BNE.N 0x120
1294:          /******************************************************************************
1295:          Function:    motorcontrol
1296:          Description:  motor control implementation
1297:          Input:      nothing (uses many global variables, mainly the current measurements)
1298:          Output:      nothing (modifies many global variables, mainly the pwm timer compare
1299:                  values)
1300:          Note:      firstly calculates the next duty cycle to be imposed using the current
1301:                  PIs with the current references coming from previous cycle;
1302:                  then manages the motor control state machine, which takes care of the
1303:                  different control phases:
1304:                    stop
1305:                    open loop startup (position and speed estimation init and adjustment)
1306:                    speed loop closing (reference system change)
1307:                    speed closed loop operations (with position and speed estimation);
1308:                  refer to the documentation for more detailed description
1309:          ******************************************************************************/
1310:           void motorcontrol(void)
1311:          {
1548  46D6B5F0     PUSH {R4, R5, R6, R7, LR}
154A  464F46D6     MOV LR, R10
154C  4646464F     MOV R7, R9
154E  B5C04646     MOV R6, R8
1550  4B9DB5C0     PUSH {R6, R7, LR}
1312:            int32_t s32a;
1313:            /* bus voltage in internal units */
1314:            s32a = (int32_t)adc_dc_bus_voltage * KAD_VOL;
1552  881B4B9D     LDR R3, [PC, #628]
1554  9B881B     LDRH R3, [R3]
1556  4A9C009B     LSLS R3, R3, #2
1315:            #if(0 != SH_KAD_VOL)
1316:            vbus = (int16_t)(s32a >> SH_KAD_VOL);
1317:            #else   /* if(0 != SH_KAD_CUR) */
1318:            vbus = (int16_t)s32a;
1558  80134A9C     LDR R2, [PC, #624]
155A  4B9C8013     STRH R3, [R2]
1319:            #endif  /* else if(0 != SH_KAD_CUR) */
1320:          
1321:            /* performs motor control if needed */
1322:            if (0U != state_run)
155C  781B4B9C     LDR R3, [PC, #624]
155E  2B00781B     LDRB R3, [R3]
1560  D0002B00     CMP R3, #0
1562  E07DD000     BEQ.N .LBB6
1564  4A9BE07D     B.N .LVL158
1323:            {
1324:          
1325:                  /* current transformations (previous angle) */
1326:                  library_ab_dq(&sysph, &curabm, &curdqm);
1662  4C604D63     LDR R5, [PC, #396]
1664  2A4C60     LDR R4, [PC, #384]
1666  4981002A     MOVS R2, R5
1668  204981     LDR R1, [PC, #516]
166A  4B810020     MOVS R0, R4
166C  47984B81     LDR R3, [PC, #516]
166E  4B674798     BLX R3
1327:          
1328:                  /* angle update */
1329:                  sysph.ang = newsysph;
1670  881B4B67     LDR R3, [PC, #412]
1672  8023881B     LDRH R3, [R3]
1674  208023     STRH R3, [R4]
1330:                  library_sincos(&sysph);
1676  4B7F0020     MOVS R0, R4
1678  47984B7F     LDR R3, [PC, #508]
167A  4F784798     BLX R3
1331:                   /* direct current control */
1332:                  s32a =(int32_t)outvmax * DVOL_MARG;
167C  23004F78     LDR R7, [PC, #480]
167E  5EFA2300     MOVS R3, #0
1680  4B7E5EFA     LDRSH R2, [R7, R3]
1682  43534B7E     LDR R3, [PC, #504]
1684  139B4353     MULS R3, R2
1333:                  /*lint -save -e9027 */
1334:                  id_pi.hlim = (int16_t)(s32a >> SH_BASE_VALUE);      /* vd max */
1686  495A139B     ASRS R3, R3, #14
1688  810B495A     LDR R1, [PC, #360]
168A  425B810B     STRH R3, [R1, #8]
1335:                  /*lint -restore */
1336:                  id_pi.llim = -id_pi.hlim;
168C  814B425B     RSBS R3, R3, #0
168E  4B56814B     STRH R3, [R1, #10]
1337:                  s32a = curdqr.x;
1690  46994B56     LDR R3, [PC, #344]
1692  20004699     MOV R9, R3
1694  5E182000     MOVS R0, #0
1696  22005E18     LDRSH R0, [R3, R0]
1338:                  s32a -= curdqm.x;
1698  5EAB2200     MOVS R2, #0
169A  1AC05EAB     LDRSH R3, [R5, R2]
169C  4B781AC0     SUBS R0, R0, R3
1339:                  outvdq.x = library_pi_control(s32a, &id_pi);
169E  46984B78     LDR R3, [PC, #480]
16A0  47984698     MOV R8, R3
16A2  14798     BLX R3
16A4  4E560001     MOVS R1, R0
16A6  80304E56     LDR R6, [PC, #344]
16A8  23008030     STRH R0, [R6]
1340:          
1341:                  /* quadrature current control */
1342:                  iq_pi.hlim = library_scat(outvmax, outvdq.x);  /* vq max */
16AA  5EF82300     MOVS R3, #0
16AC  4B755EF8     LDRSH R0, [R7, R3]
16AE  47984B75     LDR R3, [PC, #468]
16B0  49514798     BLX R3
16B2  81084951     LDR R1, [PC, #324]
16B4  42408108     STRH R0, [R1, #8]
1343:                  iq_pi.llim = -iq_pi.hlim;
16B6  81484240     RSBS R0, R0, #0
16B8  464B8148     STRH R0, [R1, #10]
1344:                  s32a = curdqr.y;
16BA  2002464B     MOV R3, R9
16BC  5E182002     MOVS R0, #2
16BE  22025E18     LDRSH R0, [R3, R0]
1345:                  s32a -= curdqm.y;
16C0  5EAB2202     MOVS R2, #2
16C2  1AC05EAB     LDRSH R3, [R5, R2]
16C4  47C01AC0     SUBS R0, R0, R3
1346:                  outvdq.y =  library_pi_control(s32a, &iq_pi);
16C6  807047C0     BLX R8
16C8  4A4E8070     STRH R0, [R6, #2]
1347:          
1348:                  /* voltage reverse-Park transformation */
1349:                  library_dq_ab(&sysph, &outvdq, &outvab);
16CA  314A4E     LDR R2, [PC, #312]
16CC  200031     MOVS R1, R6
16CE  4B6D0020     MOVS R0, R4
16D0  47984B6D     LDR R3, [PC, #436]
16D2  4B6D4798     BLX R3
1350:                         
1351:                  /* modulation (uses vbus and outvab to calculate duties, 
1352:                     and sets directly pwm registers) */
1353:          
1354:                 
1355:                      pwm_modulation();
16D4  47984B6D     LDR R3, [PC, #436]
16D6  4B4B4798     BLX R3
1356:                 
1357:                  
1358:                  #ifndef  CURPI_TUN
1359:                  /* motor control state machine */
1360:                  switch(motor_status)
16D8  781A4B4B     LDR R3, [PC, #300]
16DA  2A04781A     LDRB R2, [R3]
16DC  D9002A04     CMP R2, #4
16DE  E12BD900     BLS.N 0x16E2
16E0  93E12B     B.N 0x193A
16E2  4A6A0093     LSLS R3, R2, #2
16E4  58D34A6A     LDR R2, [PC, #424]
16E6  469F58D3     LDR R3, [R2, R3]
16E8  4B6A469F     MOV PC, R3
1361:                  {
1362:          
1363:                      case STOPPED:
1364:                          state_stopped = state_count;
16EA  681A4B6A     LDR R3, [PC, #424]
16EC  4B6A681A     LDR R2, [R3]
16EE  801A4B6A     LDR R3, [PC, #424]
16F0  2300801A     STRH R2, [R3]
1365:                          dcurref_l = 0;
16F2  49452300     MOVS R3, #0
16F4  600B4945     LDR R1, [PC, #276]
16F6  493C600B     STR R3, [R1]
1366:                          curdqr.x = 0;
16F8  800B493C     LDR R1, [PC, #240]
16FA  804B800B     STRH R3, [R1]
1367:                          curdqr.y = 0;
16FC  4944804B     STRH R3, [R1, #2]
1368:                          newsysph = 0;
16FE  800B4944     LDR R1, [PC, #272]
1700  4944800B     STRH R3, [R1]
1369:                          ampsysph = 0;
1702  600B4944     LDR R1, [PC, #272]
1704  4945600B     STR R3, [R1]
1370:                          elespeed = 0;
1706  800B4945     LDR R1, [PC, #276]
1708  4943800B     STRH R3, [R1]
1371:                          elespeed_abs = 0;
170A  800B4943     LDR R1, [PC, #268]
170C  4946800B     STRH R3, [R1]
1372:                          elespeed_l = 0;
170E  600B4946     LDR R1, [PC, #280]
1710  4B62600B     STR R3, [R1]
1373:                          if(0 != spe_ref_sgn)
1712  21004B62     LDR R3, [PC, #392]
1714  5E5B2100     MOVS R1, #0
1716  2B005E5B     LDRSH R3, [R3, R1]
1718  D1002B00     CMP R3, #0
171A  E10DD100     BNE.N 0x171E
171C  2101E10D     B.N 0x193A
1374:                          {
1375:                              motor_status = ALIGNING;
171E  4B392101     MOVS R1, #1
1720  70194B39     LDR R3, [PC, #228]
1722  32017019     STRB R1, [R3]
1376:                              state_count++;
1724  4B5B3201     ADDS R2, #1
1726  601A4B5B     LDR R3, [PC, #364]
1728  E106601A     STR R2, [R3]
172A  4B59E106     B.N 0x193A
1377:                          }
1378:                          break;
1379:                      case ALIGNING:
1380:                          state_align = state_count;
172C  681B4B59     LDR R3, [PC, #356]
172E  4A5B681B     LDR R3, [R3]
1730  80134A5B     LDR R2, [PC, #364]
1732  4A5B8013     STRH R3, [R2]
1381:                         
1382:                          if(0 == ref_sgn)
1734  21004A5B     LDR R2, [PC, #364]
1736  5E522100     MOVS R1, #0
1738  2A005E52     LDRSH R2, [R2, R1]
173A  D10B2A00     CMP R2, #0
173C  4A2BD10B     BNE.N 0x1756
1383:                          {
1384:                              curdqr.x = 0;
173E  23004A2B     LDR R2, [PC, #172]
1740  80132300     MOVS R3, #0
1742  80538013     STRH R3, [R2]
1385:                              curdqr.y = 0;
1744  4A358053     STRH R3, [R2, #2]
1386:                              elespeed = 0;
1746  80134A35     LDR R2, [PC, #212]
1748  4A338013     STRH R3, [R2]
1387:                              elespeed_abs = 0;
174A  80134A33     LDR R2, [PC, #204]
174C  4B2E8013     STRH R3, [R2]
1388:                              motor_status = STOPPED;
174E  22004B2E     LDR R3, [PC, #184]
1750  701A2200     MOVS R2, #0
1752  E0F1701A     STRB R2, [R3]
1754  4A51E0F1     B.N 0x193A
1389:                              
1390:          
1391:                          }
1392:                          else
1393:                          {
1394:                          #ifdef Q_AXIS_STARTUP
1395:                              
1396:                              if(spe_ref_sgn>0)
1756  21004A51     LDR R2, [PC, #324]
1758  5E522100     MOVS R1, #0
175A  2A005E52     LDRSH R2, [R2, R1]
175C  DD192A00     CMP R2, #0
175E  4A51DD19     BLE.N 0x1794
1397:                              {
1398:                                  /* current rising ramp */
1399:                                  if(START_CUR > curdqr.y)
1760  49224A51     LDR R2, [PC, #324]
1762  20024922     LDR R1, [PC, #136]
1764  5E092002     MOVS R0, #2
1766  42915E09     LDRSH R1, [R1, R0]
1768  DC094291     CMP R1, R2
176A  4A27DC09     BGT.N 0x1780
1400:                                  {
1401:                                      dcurref_l += CUR_RAMP_AL;
176C  68134A27     LDR R2, [PC, #156]
176E  494E6813     LDR R3, [R2]
1770  468C494E     LDR R1, [PC, #312]
1772  4463468C     MOV R12, R1
1774  60134463     ADD R3, R12
1776  139B6013     STR R3, [R2]
1402:                                      /*lint -save -e9027 */
1403:                                      curdqr.y = (int16_t)(dcurref_l >> SH_BASE_VALUE);
1778  4A1C139B     ASRS R3, R3, #14
177A  80534A1C     LDR R2, [PC, #112]
177C  E0DC8053     STRH R3, [R2, #2]
177E  494BE0DC     B.N 0x193A
1404:                                      /*lint -restore*/
1405:                                  }
1406:                                  else
1407:                                  {
1408:                                      curdqr.y = START_CUR;
1780  4A1A494B     LDR R1, [PC, #300]
1782  80514A1A     LDR R2, [PC, #104]
1784  21028051     STRH R1, [R2, #2]
1409:                                      motor_status = STARTING;
1786  4A1F2102     MOVS R1, #2
1788  70114A1F     LDR R2, [PC, #124]
178A  33017011     STRB R1, [R2]
1410:                                      state_count++;
178C  4A413301     ADDS R3, #1
178E  60134A41     LDR R2, [PC, #260]
1790  E0D26013     STR R3, [R2]
1792  4A47E0D2     B.N 0x193A
1411:                                  }
1412:                              }
1413:                              else
1414:                              {
1415:                                   /* current decreasing ramp */
1416:                                  if(-START_CUR < curdqr.y)
1794  49154A47     LDR R2, [PC, #284]
1796  20024915     LDR R1, [PC, #84]
1798  5E092002     MOVS R0, #2
179A  42915E09     LDRSH R1, [R1, R0]
179C  DB094291     CMP R1, R2
179E  4A1ADB09     BLT.N 0x17B4
1417:                                  {
1418:                                      dcurref_l -= CUR_RAMP_AL;
17A0  68134A1A     LDR R2, [PC, #104]
17A2  49446813     LDR R3, [R2]
17A4  468C4944     LDR R1, [PC, #272]
17A6  4463468C     MOV R12, R1
17A8  60134463     ADD R3, R12
17AA  139B6013     STR R3, [R2]
1419:                                      /*lint -save -e9027 */
1420:                                      curdqr.y = (int16_t)(dcurref_l >> SH_BASE_VALUE);
17AC  4A0F139B     ASRS R3, R3, #14
17AE  80534A0F     LDR R2, [PC, #60]
17B0  E0C28053     STRH R3, [R2, #2]
17B2  4941E0C2     B.N 0x193A
1421:                                      /*lint -restore*/
1422:                                  }
1423:                                  else
1424:                                  {
1425:                                      curdqr.y = -START_CUR;
17B4  4A0D4941     LDR R1, [PC, #260]
17B6  80514A0D     LDR R2, [PC, #52]
17B8  21028051     STRH R1, [R2, #2]
1426:                                      motor_status = STARTING;
17BA  4A122102     MOVS R1, #2
17BC  70114A12     LDR R2, [PC, #72]
17BE  33017011     STRB R1, [R2]
1427:                                      state_count++;
17C0  4A343301     ADDS R3, #1
17C2  60134A34     LDR R2, [PC, #208]
17C4  E0B86013     STR R3, [R2]
17C6  188E0B8     B.N 0x193A
17C8  20000188     LSLS R0, R1, #6
17CA  29282000     MOVS R0, #0
17CC  20002928     CMP R1, #40
17CE  12E2000     MOVS R0, #0
17D0  2000012E     LSLS R6, R5, #4
17D2  28682000     MOVS R0, #0
17D4  20002868     CMP R0, #104
17D6  28662000     MOVS R0, #0
17D8  20002866     CMP R0, #102
17DA  286E2000     MOVS R0, #0
17DC  2000286E     CMP R0, #110
17DE  28762000     MOVS R0, #0
17E0  20002876     CMP R0, #118
17E2  24002000     MOVS R0, #0
17E4  42002400     MOVS R4, #0
17E6  28704200     TST R0, R0
17E8  20002870     CMP R0, #112
17EA  28882000     MOVS R0, #0
17EC  20002888     CMP R0, #136
17EE  28842000     MOVS R0, #0
17F0  20002884     CMP R0, #132
17F2  D82000     MOVS R0, #0
17F4  200000D8     LSLS R0, R3, #3
17F6  EC2000     MOVS R0, #0
17F8  200000EC     LSLS R4, R5, #3
17FA  1402000     MOVS R0, #0
17FC  20000140     LSLS R0, R0, #5
17FE  28AC2000     MOVS R0, #0
1800  200028AC     CMP R0, #172
1802  28A82000     MOVS R0, #0
1804  200028A8     CMP R0, #168
1806  29422000     MOVS R0, #0
1808  20002942     CMP R1, #66
180A  288C2000     MOVS R0, #0
180C  2000288C     CMP R0, #140
180E  29102000     MOVS R0, #0
1810  20002910     CMP R1, #16
1812  28782000     MOVS R0, #0
1814  20002878     CMP R0, #120
1816  290E2000     MOVS R0, #0
1818  2000290E     CMP R1, #14
181A  290C2000     MOVS R0, #0
181C  2000290C     CMP R1, #12
181E  28B02000     MOVS R0, #0
1820  200028B0     CMP R0, #176
1822  29162000     MOVS R0, #0
1824  20002916     CMP R1, #22
1826  28942000     MOVS R0, #0
1828  20002894     CMP R0, #148
182A  28A02000     MOVS R0, #0
182C  200028A0     CMP R0, #160
182E  1562000     MOVS R0, #0
1830  20000156     LSLS R6, R2, #5
1832  28A42000     MOVS R0, #0
1834  200028A4     CMP R0, #164
1836  D62000     MOVS R0, #0
1838  200000D6     LSLS R6, R2, #3
183A  28BC2000     MOVS R0, #0
183C  200028BC     CMP R0, #188
183E  13A2000     MOVS R0, #0
1840  2000013A     LSLS R2, R7, #4
1842  28C02000     MOVS R0, #0
1844  200028C0     CMP R0, #192
1846  D42000     MOVS R0, #0
1848  200000D4     LSLS R4, R2, #3
184A  28982000     MOVS R0, #0
184C  20002898     CMP R0, #152
184E  D22000     MOVS R0, #0
1850  200000D2     LSLS R2, R2, #3
1852  29262000     MOVS R0, #0
1854  20002926     CMP R1, #38
1856  28B82000     MOVS R0, #0
1858  200028B8     CMP R0, #184
185A  24062000     MOVS R0, #0
185C  2406     MOVS R4, #6
185E  29120000     MOVS R0, R0
1860  20002912     CMP R1, #18
1862  28B42000     MOVS R0, #0
1864  200028B4     CMP R0, #180
1866  1122000     MOVS R0, #0
1868  20000112     LSLS R2, R2, #4
186A  1582000     MOVS R0, #0
186C  20000158     LSLS R0, R3, #5
186E  287C2000     MOVS R0, #0
1870  2000287C     CMP R0, #124
1872  5EF52000     MOVS R0, #0
1874  5EF5     LDRSH R5, [R6, R3]
1876  62E10000     MOVS R0, R0
1878  62E1     STR R1, [R4, #44]
187A  39990000     MOVS R0, R0
187C  3999     SUBS R1, #153
187E  48F50000     MOVS R0, R0
1880  48F5     LDR R0, [PC, #980]
1882  5CCD0000     MOVS R0, R0
1884  5CCD     LDRB R5, [R1, R3]
1886  5F2D0000     MOVS R0, R0
1888  5F2D     LDRSH R5, [R5, R4]
188A  39910000     MOVS R0, R0
188C  3991     SUBS R1, #145
188E  64780000     MOVS R0, R0
1890  6478     STR R0, [R7, #68]
1892  28C40000     MOVS R0, R0
1894  200028C4     CMP R0, #196
1896  29222000     MOVS R0, #0
1898  20002922     CMP R1, #34
189A  1322000     MOVS R0, #0
189C  20000132     LSLS R2, R6, #4
189E  291A2000     MOVS R0, #0
18A0  2000291A     CMP R1, #26
18A2  CE2000     MOVS R0, #0
18A4  200000CE     LSLS R6, R1, #3
18A6  BA12000     MOVS R0, #0
18A8  0BA1     LSRS R1, R4, #14
18AA  261E0000     MOVS R0, R0
18AC  261E     MOVS R6, #30
18AE  BA20000     MOVS R0, R0
18B0  0BA2     LSRS R2, R4, #14
18B2  F45F0000     MOVS R0, R0
18B4  FFFFF45F     BL 0x1C618B6
18B6  D9E2FFFF     CDP2 P9, #15, CR13, CR15, CR2, {7}
18B8  FFFFD9E2     BLS.N 0x1880
18BA  F45EFFFF     MRC2 P4, #7, PC, CR15, CR14, {2}
18BC  FFFFF45E     BL 0x1C608BE
18BE  4BD4FFFF     MRC2 P11, #7, R4, CR15, CR4, {6}
1428:                                  }
1429:                              }
1430:                          #else
1431:                              if(spe_ref_sgn>0)
1432:                              {
1433:                                  /* current rising ramp */
1434:                                  if(START_CUR > curdqr.x)
1435:                                  {
1436:                                      dcurref_l += CUR_RAMP_AL;
1437:                                      /*lint -save -e9027 */
1438:                                      curdqr.x = (int16_t)(dcurref_l >> SH_BASE_VALUE);
1439:                                      /*lint -restore*/
1440:                                  }
1441:                                  else
1442:                                  {
1443:                                      curdqr.x = START_CUR;
1444:          
1445:                                      /* status change */
1446:                                      motor_status = STARTING;
1447:          
1448:                                  }
1449:                              }
1450:                              else
1451:                              {
1452:                              /* current decreasing ramp */
1453:                                  if(-START_CUR < curdqr.x)
1454:                                  {
1455:                                      dcurref_l -= CUR_RAMP_AL;
1456:                                      /*lint -save -e9027 */
1457:                                      curdqr.x = (int16_t)(dcurref_l >> SH_BASE_VALUE);
1458:                                      /*lint -restore*/
1459:                                  }
1460:                                  else
1461:                                  {
1462:                                      curdqr.x = -START_CUR;
1463:          
1464:                                      /* status change */
1465:                                      motor_status = STARTING;
1466:          
1467:                                  }
1468:                              }
1469:                          #endif     
1470:                          }
1471:                          break;
1472:                      case STARTING:
1473:                          state_start = state_count;
18C0  681A4BD4     LDR R3, $d
18C2  4BD4681A     LDR R2, [R3]
18C4  801A4BD4     LDR R3, [PC, #848]
18C6  23F5801A     STRH R2, [R3]
1474:                          /* observer alignment */
1475:                          if((MIN_SPE >> 2) > elespeed_abs)
18C8  5B23F5     MOVS R3, #245
18CA  4AD3005B     LSLS R3, R3, #1
18CC  88124AD3     LDR R2, [PC, #844]
18CE  429A8812     LDRH R2, [R2]
18D0  D900429A     CMP R2, R3
18D2  E080D900     BLS.N 0x18D6
18D4  4BD2E080     B.N 0x19D8
1476:                          {
1477:                            estimation_alignment(elespeed, &outvab, &curabm);
18D6  20004BD2     LDR R3, [PC, #840]
18D8  5E182000     MOVS R0, #0
18DA  4AD15E18     LDRSH R0, [R3, R0]
18DC  49D24AD1     LDR R2, [PC, #836]
18DE  4BD249D2     LDR R1, [PC, #840]
18E0  47984BD2     LDR R3, [PC, #840]
18E2  4BD24798     BLX R3
1478:                            
1479:          
1480:                          }
1481:                          else
1482:                          {
1483:                            position_and_speed_estimation(spe_ref_sgn, &outvab, &curabm);
19D8  20004B99     LDR R3, [PC, #612]
19DA  5E182000     MOVS R0, #0
19DC  4A915E18     LDRSH R0, [R3, R0]
19DE  49914A91     LDR R2, [PC, #580]
19E0  4BA94991     LDR R1, [PC, #580]
19E2  47984BA9     LDR R3, [PC, #676]
19E4  E77D4798     BLX R3
19E6  4BA8E77D     B.N .LVL172
1484:                          }
1485:          
1486:                          /* speed rising ramp */
1487:                          if(MIN_SPE > elespeed_abs)
18E4  4ACD4BD2     LDR R3, [PC, #840]
18E6  88124ACD     LDR R2, [PC, #820]
18E8  429A8812     LDRH R2, [R2]
18EA  D900429A     CMP R2, R3
18EC  E07BD900     BLS.N 0x18F0
18EE  4BD0E07B     B.N 0x19E8
1488:                          {
1489:                              /* speed ramp */
1490:                              elespeed_l += DSPEEDL_STUP;
18F0  681A4BD0     LDR R3, [PC, #832]
18F2  21A1681A     LDR R2, [R3]
18F4  8921A1     MOVS R1, #161
18F6  468C0089     LSLS R1, R1, #2
18F8  4462468C     MOV R12, R1
18FA  104462     ADD R2, R12
18FC  601A0010     MOVS R0, R2
18FE  49CD601A     STR R2, [R3]
1491:                              elespeed_abs = (uint16_t)(elespeed_l / K_SPEED_L);
1900  4BCE49CD     LDR R1, [PC, #820]
1902  47984BCE     LDR R3, [PC, #824]
1904  4BC54798     BLX R3
1906  80184BC5     LDR R3, [PC, #788]
1908  4BCD8018     STRH R0, [R3]
1492:                          }
1493:                          else
1494:                          {
1495:          
1496:                              elespeed_abs = MIN_SPE;
19E8  4A8C4BA8     LDR R3, [PC, #672]
19EA  80134A8C     LDR R2, [PC, #560]
19EC  49A88013     STRH R3, [R2]
1497:                              elespeed_l = (uint32_t)elespeed_abs * (uint32_t)K_SPEED_L;
19EE  4A9049A8     LDR R1, [PC, #672]
19F0  60114A90     LDR R2, [PC, #576]
19F2  4AA76011     STR R1, [R2]
1498:          
1499:                              /* reference speed filter init */
1500:                              spe_ref_mem = elespeed_abs;
1501:                              spe_ref_fil = elespeed_abs;
19F4  80134AA7     LDR R2, [PC, #668]
19F6  4AA78013     STRH R3, [R2]
1502:                              spe_ref_mem <<= SH_REFSPEED_FIL;
19F8  4BA84AA7     LDR R2, [PC, #668]
19FA  601A4BA8     LDR R3, [PC, #672]
19FC  2203601A     STR R2, [R3]
1503:          
1504:                              /* status change */
1505:                          #ifdef ROTOR_ANGLE_OPEN_LOOP_MODE
1506:                              motor_status = STARTING;
1507:                          #else
1508:                              motor_status = CLOSINGLOOP;
19FE  4BA72203     MOVS R2, #3
1A00  701A4BA7     LDR R3, [PC, #668]
1A02  4A83701A     STRB R2, [R3]
1509:                          #endif
1510:                              state_count++;
1A04  68134A83     LDR R2, $d
1A06  33016813     LDR R3, [R2]
1A08  60133301     ADDS R3, #1
1A0A  E77D6013     STR R3, [R2]
1A0C  4B83E77D     B.N 0x190A
1511:                          }
1512:                          if(0 > spe_ref_sgn)
190A  22004BCD     LDR R3, [PC, #820]
190C  5E9B2200     MOVS R2, #0
190E  2B005E9B     LDRSH R3, [R3, R2]
1910  DA002B00     CMP R3, #0
1912  E07BDA00     BGE.N 0x1916
1914  DC00E07B     B.N 0x1A0E
1513:                          {
1514:                              elespeed = (int16_t)(-(int32_t)elespeed_abs);
1A0E  881B4B83     LDR R3, [PC, #524]
1A10  425B881B     LDRH R3, [R3]
1A12  4A82425B     RSBS R3, R3, #0
1A14  80134A82     LDR R2, [PC, #520]
1A16  4A8A8013     STRH R3, [R2]
1515:                              ampsysph -= elespeed_l;
1A18  4B864A8A     LDR R2, [PC, #552]
1A1A  681B4B86     LDR R3, [PC, #536]
1A1C  6811681B     LDR R3, [R3]
1A1E  1ACB6811     LDR R1, [R2]
1A20  60131ACB     SUBS R3, R1, R3
1A22  E7846013     STR R3, [R2]
1A24  4A9FE784     B.N 0x1930
1516:                          }
1517:                          else if(0 < spe_ref_sgn)
1916  E085DC00     BGT.N 0x191A
1918  4BC0E085     B.N 0x1A26
1518:                          {
1519:                              elespeed = (int16_t)elespeed_abs;
191A  881A4BC0     LDR R3, [PC, #768]
191C  4BC0881A     LDRH R2, [R3]
191E  801A4BC0     LDR R3, [PC, #768]
1920  4AC8801A     STRH R2, [R3]
1520:                              ampsysph += elespeed_l;
1922  4BC34AC8     LDR R2, [PC, #800]
1924  681B4BC3     LDR R3, [PC, #780]
1926  6811681B     LDR R3, [R3]
1928  468C6811     LDR R1, [R2]
192A  4463468C     MOV R12, R1
192C  60134463     ADD R3, R12
192E  4BC46013     STR R3, [R2]
1521:                          }
1522:                          else    /* (0 == spe_ref_sgn) */
1523:                          {
1524:                              curdqr.x =  0;
1A26  23004A9F     LDR R2, [PC, #636]
1A28  80132300     MOVS R3, #0
1A2A  80538013     STRH R3, [R2]
1525:                              curdqr.y = 0 ;
1A2C  4A7C8053     STRH R3, [R2, #2]
1526:                              elespeed = 0;
1A2E  80134A7C     LDR R2, [PC, #496]
1A30  4A7A8013     STRH R3, [R2]
1527:                              elespeed_abs = 0;
1A32  80134A7A     LDR R2, [PC, #488]
1A34  4B9A8013     STRH R3, [R2]
1528:                              motor_status = STOPPED;
1A36  22004B9A     LDR R3, [PC, #616]
1A38  701A2200     MOVS R2, #0
1A3A  E778701A     STRB R2, [R3]
1A3C  4B75E778     B.N 0x1930
1529:          
1530:                          }
1531:          
1532:                          /* feed-forward angle management */
1533:                          newsysph = (uint16_t)(ampsysph >> (uint32_t)SH_BASE_VALUE);
1930  681B4BC4     LDR R3, [PC, #784]
1932  B9B681B     LDR R3, [R3]
1934  4AC40B9B     LSRS R3, R3, #14
1936  80134AC4     LDR R2, [PC, #784]
1938  4AC48013     STRH R3, [R2]
1534:          
1535:                          break;
1536:                      case CLOSINGLOOP:
1537:                          state_closingloop = state_count;
1A3E  681A4B75     LDR R3, [PC, #468]
1A40  4B99681A     LDR R2, [R3]
1A42  801A4B99     LDR R3, [PC, #612]
1A44  4B7E801A     STRH R2, [R3]
1538:                          /* position and speed estimation (Luenberger) */
1539:                          position_and_speed_estimation(spe_ref_sgn, &outvab, &curabm);
1A46  20004B7E     LDR R3, [PC, #504]
1A48  5E182000     MOVS R0, #0
1A4A  4A755E18     LDRSH R0, [R3, R0]
1A4C  49764A75     LDR R2, [PC, #468]
1A4E  4B8D4976     LDR R1, [PC, #472]
1A50  47984B8D     LDR R3, [PC, #564]
1A52  4B954798     BLX R3
1540:                          newsysph = position_offset + get_angular_position();
1A54  47984B95     LDR R3, [PC, #596]
1A56  4B954798     BLX R3
1A58  881B4B95     LDR R3, [PC, #596]
1A5A  18C0881B     LDRH R3, [R3]
1A5C  4B7A18C0     ADDS R0, R0, R3
1A5E  80184B7A     LDR R3, [PC, #488]
1A60  4B948018     STRH R0, [R3]
1541:                          #ifdef  SPREF_FIL_ALIGN
1542:                          elespeed = get_angular_speed();
1A62  47984B94     LDR R3, [PC, #592]
1A64  4B6E4798     BLX R3
1A66  80184B6E     LDR R3, [PC, #440]
1A68  28008018     STRH R0, [R3]
1543:                          if(0 >= elespeed)
1A6A  DD502800     CMP R0, #0
1A6C  4B89DD50     BLE.N 0x1A10
1544:                          {
1545:                              spe_ref_fil = (uint16_t)(-elespeed);
1B10  4B604240     RSBS R0, R0, #0
1B12  80184B60     LDR R3, [PC, #384]
1B14  E7AC8018     STRH R0, [R3]
1B16  2300E7AC     B.N 0x1A72
1546:                          }
1547:                          else
1548:                          {
1549:                              spe_ref_fil = (uint16_t)elespeed;
1A6E  80184B89     LDR R3, [PC, #548]
1A70  4B888018     STRH R0, [R3]
1550:                          }
1551:                          spe_ref_mem = spe_ref_fil;
1A72  881B4B88     LDR R3, [PC, #544]
1A74  29B881B     LDRH R3, [R3]
1552:                          spe_ref_mem <<= SH_REFSPEED_FIL;
1A76  4A88029B     LSLS R3, R3, #10
1A78  60134A88     LDR R2, [PC, #544]
1A7A  4C786013     STR R3, [R2]
1553:                          #endif  /* ifdef SPREF_FIL_ALIGN */
1554:          
1555:                          /* control memories calc and setting */
1556:                          /* compiler ensures a arithmetic shift is done in these cases.
1557:                              MISRA 10.1 violated for optimziation purpose */
1558:                          /*lint -save -e9027 */
1559:                          outvdq.x = (int16_t)(id_pi.imem >> id_pi.shp); //Copying the integral output of D axis PI Controller to D axis output voltage
1A7C  4B8E4C78     LDR R4, [PC, #480]
1A7E  469A4B8E     LDR R3, [PC, #568]
1A80  885B469A     MOV R10, R3
1A82  4652885B     LDRH R3, [R3, #2]
1A84  68D24652     MOV R2, R10
1A86  411A68D2     LDR R2, [R2, #12]
1A88  8022411A     ASRS R2, R3
1A8A  4D8B8022     STRH R2, [R4]
1560:                          outvdq.y = (int16_t)(iq_pi.imem >> iq_pi.shp); //Copying the integral output of Q axis PI Controller to Q axis output voltage
1A8C  886B4D8B     LDR R5, [PC, #556]
1A8E  68EA886B     LDRH R3, [R5, #2]
1A90  411A68EA     LDR R2, [R5, #12]
1A92  8062411A     ASRS R2, R3
1A94  4A648062     STRH R2, [R4, #2]
1561:                          /*lint -restore */
1562:                          library_dq_ab(&sysph, &outvdq, &outvab);
1A96  214A64     LDR R2, [PC, #400]
1A98  48890021     MOVS R1, R4
1A9A  4F894889     LDR R0, [PC, #548]
1A9C  47B84F89     LDR R7, [PC, #548]
1A9E  4E8047B8     BLX R7
1563:                          library_dq_ab(&sysph, &curdqr, &curabr);
1AA0  4A894E80     LDR R6, [PC, #512]
1AA2  314A89     LDR R2, [PC, #548]
1AA4  48860031     MOVS R1, R6
1AA6  47B84886     LDR R0, [PC, #536]
1AA8  4B6747B8     BLX R7
1564:          
1565:                          /* new phase alignment */
1566:                          sysph.ang = newsysph;
1AAA  881B4B67     LDR R3, [PC, #412]
1AAC  4A84881B     LDRH R3, [R3]
1AAE  80134A84     LDR R2, [PC, #528]
1AB0  108013     STRH R3, [R2]
1567:                          library_sincos(&sysph);
1AB2  4B850010     MOVS R0, R2
1AB4  47984B85     LDR R3, [PC, #532]
1AB6  224798     BLX R3
1568:          
1569:                          /* control memories setting in the new reference */
1570:                          library_ab_dq(&sysph, &outvab, &outvdq);
1AB8  495B0022     MOVS R2, R4
1ABA  4880495B     LDR R1, [PC, #364]
1ABC  4F844880     LDR R0, [PC, #512]
1ABE  47B84F84     LDR R7, [PC, #528]
1AC0  3247B8     BLX R7
1571:                          library_ab_dq(&sysph, &curabr, &curdqr);
1AC2  49800032     MOVS R2, R6
1AC4  487E4980     LDR R1, [PC, #512]
1AC6  47B8487E     LDR R0, [PC, #504]
1AC8  220047B8     BLX R7
1572:                          #ifdef Q_AXIS_STARTUP
1573:                          curdqr.x = 0 ; // US#C17668
1ACA  80322200     MOVS R2, #0
1ACC  21008032     STRH R2, [R6]
1574:                          #else
1575:                          curdqr.x = 0;//
1576:                          #endif
1577:                          id_pi.imem = outvdq.x;
1ACE  5E632100     MOVS R1, #0
1AD0  46515E63     LDRSH R3, [R4, R1]
1578:                          /*lint -save -e9027 */
1579:                          /* d current PI integral term in new ref. frame */
1580:                          id_pi.imem <<= id_pi.shp;  
1AD2  88494651     MOV R1, R10
1AD4  408B8849     LDRH R1, [R1, #2]
1AD6  4651408B     LSLS R3, R1
1AD8  60CB4651     MOV R1, R10
1ADA  210260CB     STR R3, [R1, #12]
1581:                          iq_pi.imem = outvdq.y;
1ADC  5E632102     MOVS R1, #2
1ADE  88695E63     LDRSH R3, [R4, R1]
1582:                          /* q current PI integral term in new ref. frame */
1583:                          iq_pi.imem <<= iq_pi.shp;  
1AE0  408B8869     LDRH R1, [R5, #2]
1AE2  60EB408B     LSLS R3, R1
1AE4  4B7B60EB     STR R3, [R5, #12]
1584:                          dcurref_l = curdqr.x;
1AE6  601A4B7B     LDR R3, [PC, #492]
1AE8  4A7B601A     STR R2, [R3]
1585:                          dcurref_l <<= SH_BASE_VALUE;
1586:          
1587:                          /* speed PI control memory setting */
1588:                          sp_pi.imem = curdqr.y;
1AEC  5E732102     MOVS R1, #2
1AEE  88515E73     LDRSH R3, [R6, R1]
1589:                          sp_pi.imem <<= sp_pi.shp;  /* speed PI integral term */
1AEA  21024A7B     LDR R2, [PC, #492]
1AF0  408B8851     LDRH R1, [R2, #2]
1AF2  60D3408B     LSLS R3, R1
1AF4  4B7960D3     STR R3, [R2, #12]
1590:                          /*lint -restore */
1591:                          /* position loss control reset */
1592:                          pos_lost_control_reset();
1593:          
1594:                          /* status change */
1595:                          if(0 != ref_sgn)
1AF6  22004B79     LDR R3, [PC, #484]
1AF8  5E9B2200     MOVS R2, #0
1AFA  2B005E9B     LDRSH R3, [R3, R2]
1AFC  D00B2B00     CMP R3, #0
1AFE  2204D00B     BEQ.N 0x1B18
1596:                          {
1597:                              motor_status = RUNNING;
1B00  4B672204     MOVS R2, #4
1B02  701A4B67     LDR R3, [PC, #412]
1B04  4A43701A     STRB R2, [R3]
1598:                              state_count++;
1B06  68134A43     LDR R2, [PC, #268]
1B08  33016813     LDR R3, [R2]
1B0A  60133301     ADDS R3, #1
1B0C  E7146013     STR R3, [R2]
1B0E  4240E714     B.N 0x193A
1599:                          }
1600:                          else
1601:                          {
1602:                              curdqr.x =  0;
1603:                              curdqr.y = 0;
1B18  4A622300     MOVS R3, #0
1B1A  80534A62     LDR R2, [PC, #392]
1B1C  4A408053     STRH R3, [R2, #2]
1604:                              elespeed =  0;
1B1E  80134A40     LDR R2, [PC, #256]
1B20  4A3E8013     STRH R3, [R2]
1605:                              elespeed_abs = 0;
1B22  80134A3E     LDR R2, [PC, #248]
1B24  4B5E8013     STRH R3, [R2]
1606:                              motor_status = STOPPED;
1B26  22004B5E     LDR R3, [PC, #376]
1B28  701A2200     MOVS R2, #0
1B2A  E705701A     STRB R2, [R3]
1B2C  4B39E705     B.N 0x193A
1607:          
1608:                          }
1609:          
1610:                          /* phase lost check filters reset */
1611:           //               phase_lost_filters_reset();
1612:          
1613:                          break;
1614:                          
1615:                      
1616:                      case RUNNING:
1617:                          
1618:                          state_closedloop = state_count;
1B2E  681A4B39     LDR R3, [PC, #228]
1B30  4B6B681A     LDR R2, [R3]
1B32  801A4B6B     LDR R3, [PC, #428]
1B34  4B6B801A     STRH R2, [R3]
1619:                         /* reference speed filter */
1620:                          spe_ref_mem += spe_ref_abs;
1B36  881B4B6B     LDR R3, [PC, #428]
1B38  4958881B     LDRH R3, [R3]
1B3A  680A4958     LDR R1, [PC, #352]
1B3C  4694680A     LDR R2, [R1]
1B3E  44634694     MOV R12, R2
1B40  4A544463     ADD R3, R12
1621:                          spe_ref_mem -= spe_ref_fil;
1B42  88104A54     LDR R2, [PC, #336]
1B44  1A1B8810     LDRH R0, [R2]
1B46  600B1A1B     SUBS R3, R3, R0
1B48  A9B600B     STR R3, [R1]
1622:                          spe_ref_fil = (uint16_t)(spe_ref_mem >> SH_REFSPEED_FIL);
1B4A  80130A9B     LSRS R3, R3, #10
1B4C  4B3C8013     STRH R3, [R2]
1623:          
1624:                          /* position and speed estimation (Luenberger) */
1625:                          position_and_speed_estimation(spe_ref_sgn, &outvab, &curabm);
1B4E  20004B3C     LDR R3, [PC, #240]
1B50  5E182000     MOVS R0, #0
1B52  4A335E18     LDRSH R0, [R3, R0]
1B54  49344A33     LDR R2, [PC, #204]
1B56  4B4B4934     LDR R1, [PC, #208]
1B58  47984B4B     LDR R3, [PC, #300]
1B5A  4B534798     BLX R3
1626:                          /* estimated position */
1627:                          newsysph = position_offset + get_angular_position();    
1B5C  47984B53     LDR R3, [PC, #332]
1B5E  4B534798     BLX R3
1B60  881B4B53     LDR R3, [PC, #332]
1B62  18C0881B     LDRH R3, [R3]
1B64  4B3818C0     ADDS R0, R0, R3
1B66  80184B38     LDR R3, [PC, #224]
1B68  4B528018     STRH R0, [R3]
1628:                          /* estimated speed */
1629:                          elespeed = get_angular_speed(); 
1B6A  47984B52     LDR R3, [PC, #328]
1B6C  4B2C4798     BLX R3
1B6E  80184B2C     LDR R3, [PC, #176]
1B70  28008018     STRH R0, [R3]
1630:                          if(0 > elespeed)
1B72  DB332800     CMP R0, #0
1B74  4B29DB33     BLT.N 0x1BDE
1631:                          {
1632:                              elespeed_abs = (uint16_t)(-elespeed);
1BDE  4A0E4243     RSBS R0, R3, #0
1BE0  80134A0E     LDR R2, [PC, #56]
1BE2  E7C98013     STRH R3, [R2]
1BE4  425BE7C9     B.N 0x1B7A
1633:                          }
1634:                          else
1635:                          {
1636:                              elespeed_abs = (uint16_t)elespeed;
1B76  80184B29     LDR R3, [PC, #164]
1B78  4B578018     STRH R0, [R3]
1637:                          }
1638:          
1639:                          /* speed control */
1640:                          sp_pi.hlim = MAX_CUR;
1B7A  4A5A4B57     LDR R3, [PC, #348]
1B7C  811A4A5A     LDR R2, [PC, #360]
1B7E  4A5A811A     STRH R2, [R3, #8]
1641:                          sp_pi.llim = -MAX_CUR;
1B80  815A4A5A     LDR R2, [PC, #360]
1B82  4B43815A     STRH R2, [R3, #10]
1642:                          s32a = (int32_t)spe_ref_fil;
1B84  881B4B43     LDR R3, [PC, #268]
1B86  4A2D881B     LDRH R3, [R3]
1643:                          if(0 > spe_ref_sgn)
1B88  21004A2D     LDR R2, [PC, #180]
1B8A  5E522100     MOVS R1, #0
1B8C  2A005E52     LDRSH R2, [R2, R1]
1B8E  DB292A00     CMP R2, #0
1B90  1A18DB29     BLT.N .LVL194
1644:                          {
1645:                              s32a = -s32a;
1BE6  E7D3425B     RSBS R3, R3, #0
1BE8  4240E7D3     B.N .LVL187
1646:                          }
1647:                          s32a -= elespeed;
1B92  49501A18     SUBS R0, R3, R0
1648:                          curdqr.y = library_pi_control(s32a, &sp_pi);
1B94  4B564950     LDR R1, [PC, #320]
1B96  47984B56     LDR R3, [PC, #344]
1B98  4B424798     BLX R3
1B9A  80584B42     LDR R3, [PC, #264]
1B9C  22008058     STRH R0, [R3, #2]
1649:          
1650:                          /* d current reduction */
1651:                          if(0 != curdqr.x)
1B9E  5E9B2200     MOVS R2, #0
1BA0  2B005E9B     LDRSH R3, [R3, R2]
1BA2  D1002B00     CMP R3, #0
1BA4  E6C8D100     BNE.N 0x1BA8
1BA6  1E6C8     B.N 0x193A
1652:                          {
1653:                              /* idmax calc and d reference clamping */
1654:                              s32a = library_scat(MAX_CUR, curdqr.y);
1BA8  484F0001     MOVS R1, R0
1BAA  4B51484F     LDR R0, [PC, #316]
1BAC  47984B51     LDR R3, [PC, #324]
1BAE  3804798     BLX R3
1655:                              /*lint -save -e9027 */
1656:                              s32a <<= SH_BASE_VALUE;
1BB0  4B480380     LSLS R0, R0, #14
1657:                              /*lint -restore */
1658:                              if(s32a < dcurref_l)
1BB2  681B4B48     LDR R3, [PC, #288]
1BB4  4298681B     LDR R3, [R3]
1BB6  DA174298     CMP R0, R3
1BB8  4B46DA17     BGE.N .LVL196
1659:                              {
1660:                                  dcurref_l = s32a;
1BBA  60184B46     LDR R3, [PC, #280]
1BBC  4B456018     STR R0, [R3]
1661:                              }
1662:                              else if(-s32a > dcurref_l)
1BEA  42834240     RSBS R0, R0, #0
1BEC  DAE64283     CMP R3, R0
1BEE  4B38DAE6     BGE.N .LVL193
1663:                              {
1664:                                  dcurref_l = -s32a;
1BF0  60184B38     LDR R3, [PC, #224]
1BF2  E7E36018     STR R0, [R3]
1BF4  4A41E7E3     B.N .LVL193
1665:                              }
1666:                              else
1667:                              {
1668:                                /* no action */
1669:                              }
1670:          
1671:                              /* d current ramp */
1672:                              if(CUR_RAMP_RU < dcurref_l)
1BBE  681B4B45     LDR R3, [PC, #276]
1BC0  4A4D681B     LDR R3, [R3]
1BC2  42934A4D     LDR R2, [PC, #308]
1BC4  DD164293     CMP R3, R2
1BC6  4A4CDD16     BLE.N .LVL198
1673:                              {
1674:                                  dcurref_l -= CUR_RAMP_RU;
1BC8  46944A4C     LDR R2, [PC, #304]
1BCA  44634694     MOV R12, R2
1BCC  4A414463     ADD R3, R12
1BCE  60134A41     LDR R2, [PC, #260]
1BD0  4B406013     STR R3, [R2]
1675:                              }
1676:                              else if(-CUR_RAMP_RU > dcurref_l)
1BF6  42934A41     LDR R2, [PC, #260]
1BF8  DA054293     CMP R3, R2
1BFA  4A3EDA05     BGE.N 0x1C08
1677:                              {
1678:                                  dcurref_l += CUR_RAMP_RU;
1BFC  46944A3E     LDR R2, [PC, #248]
1BFE  44634694     MOV R12, R2
1C00  4A344463     ADD R3, R12
1C02  60134A34     LDR R2, [PC, #208]
1C04  E7E46013     STR R3, [R2]
1C06  2200E7E4     B.N 0x1BD2
1679:                              }
1680:                              else
1681:                              {
1682:                                  dcurref_l = 0;
1C08  4B322200     MOVS R2, #0
1C0A  601A4B32     LDR R3, [PC, #200]
1C0C  E7E0601A     STR R2, [R3]
1C0E  11BE7E0     B.N 0x1BD2
1683:                              }
1684:                              /*lint -save -e9027 , 10.1 violated for optimization*/
1685:                              curdqr.x = (int16_t)(dcurref_l >> SH_BASE_VALUE);
1BD2  681B4B40     LDR R3, [PC, #256]
1BD4  139B681B     LDR R3, [R3]
1BD6  4A32139B     ASRS R3, R3, #14
1BD8  80134A32     LDR R2, [PC, #200]
1BDA  E6AD8013     STRH R3, [R2]
1BDC  4243E6AD     B.N 0x193A
1686:                              /*lint -restore */
1687:                          }
1688:          
1689:                          /* phase lost check filters */
1690:          //                phase_lost_filters();
1691:          
1692:                          /* position loss control */
1693:          //                pos_lost_control();
1694:          
1695:                          break;
1696:                      default:
1697:                        /* empty case: control should not come here */
1698:                        break;
1699:                  }/* end of switch case */
1700:          
1701:                  #else   /* ifndef CURPI_TUN */
1702:                  curdqr.x = CUR_STEP_VAL;
1703:                  curdqr.y = 0;
1704:                  #endif  /* else ifndef CURPI_TUN */
1705:          
1706:                  /* filters */
1707:                  idfil_mem += curdqm.x;          /* direct current */
193A  21004AC4     LDR R2, [PC, #784]
193C  5E532100     MOVS R1, #0
193E  48C35E53     LDRSH R3, [R2, R1]
1940  680148C3     LDR R0, [PC, #780]
1942  468C6801     LDR R1, [R0]
1944  4463468C     MOV R12, R1
1946  49C24463     ADD R3, R12
1708:                  idfil_mem -= idfil;
1948  250049C2     LDR R1, [PC, #776]
194A  5F4C2500     MOVS R5, #0
194C  1B1B5F4C     LDRSH R4, [R1, R5]
194E  60031B1B     SUBS R3, R3, R4
1950  129B6003     STR R3, [R0]
1709:                  /*lint -save -e9027 , 10.1 violated for optimization*/
1710:                  idfil = (int16_t)(idfil_mem >> SH_MEAS_FIL);
1952  800B129B     ASRS R3, R3, #10
1954  2302800B     STRH R3, [R1]
1711:                  iqfil_mem += curdqm.y;          /* quadrature current */
1956  5ED32302     MOVS R3, #2
1958  49BF5ED3     LDRSH R3, [R2, R3]
195A  680A49BF     LDR R1, [PC, #764]
195C  4694680A     LDR R2, [R1]
195E  44634694     MOV R12, R2
1960  4ABE4463     ADD R3, R12
1712:                  iqfil_mem -= iqfil;
1962  24004ABE     LDR R2, [PC, #760]
1964  5F102400     MOVS R4, #0
1966  1A1B5F10     LDRSH R0, [R2, R4]
1968  600B1A1B     SUBS R3, R3, R0
196A  129B600B     STR R3, [R1]
1713:                  iqfil = (int16_t)(iqfil_mem >> SH_MEAS_FIL);
196C  8013129B     ASRS R3, R3, #10
196E  4ABB8013     STRH R3, [R2]
1714:                  vdfil_mem += outvdq.x;          /* direct voltage */
1970  21004ABB     LDR R2, [PC, #748]
1972  5E532100     MOVS R1, #0
1974  48BB5E53     LDRSH R3, [R2, R1]
1976  680148BB     LDR R0, [PC, #748]
1978  468C6801     LDR R1, [R0]
197A  4463468C     MOV R12, R1
197C  49BA4463     ADD R3, R12
1715:                  vdfil_mem -= vdfil;
197E  250049BA     LDR R1, [PC, #744]
1980  5F4C2500     MOVS R5, #0
1982  1B1B5F4C     LDRSH R4, [R1, R5]
1984  60031B1B     SUBS R3, R3, R4
1986  129B6003     STR R3, [R0]
1716:                  vdfil = (int16_t)(vdfil_mem >> SH_MEAS_FIL);
1988  800B129B     ASRS R3, R3, #10
198A  2302800B     STRH R3, [R1]
1717:                  vqfil_mem += outvdq.y;          /* quadrature voltage */
198C  5ED32302     MOVS R3, #2
198E  49B65ED3     LDRSH R3, [R2, R3]
1990  680A49B6     LDR R1, [PC, #728]
1992  4694680A     LDR R2, [R1]
1994  44634694     MOV R12, R2
1996  4AB54463     ADD R3, R12
1718:                  vqfil_mem -= vqfil;
1998  24004AB5     LDR R2, [PC, #724]
199A  5F102400     MOVS R4, #0
199C  1A1B5F10     LDRSH R0, [R2, R4]
199E  600B1A1B     SUBS R3, R3, R0
19A0  129B600B     STR R3, [R1]
1719:                  vqfil = (int16_t)(vqfil_mem >> SH_MEAS_FIL);
19A2  8013129B     ASRS R3, R3, #10
19A4  4B9D8013     STRH R3, [R2]
1720:                  espabs_mem += elespeed_abs;    /* estimated abs speed */
19A6  881B4B9D     LDR R3, [PC, #628]
19A8  49B2881B     LDRH R3, [R3]
19AA  680A49B2     LDR R1, [PC, #712]
19AC  4694680A     LDR R2, [R1]
19AE  44634694     MOV R12, R2
19B0  4AB14463     ADD R3, R12
1721:                  espabs_mem -= espabs_fil;
19B2  88104AB1     LDR R2, [PC, #708]
19B4  1A1B8810     LDRH R0, [R2]
19B6  600B1A1B     SUBS R3, R3, R0
19B8  A9B600B     STR R3, [R1]
1722:                  espabs_fil = (uint16_t)(espabs_mem >> SH_MEAS_FIL);
19BA  80130A9B     LSRS R3, R3, #10
19BC  4BAF8013     STRH R3, [R2]
1723:                  
1724:                  ext_spe_ref_mem += rpm_ref_abs;    /* Filtered reference speed speed in RPM */
19BE  881B4BAF     LDR R3, [PC, #700]
19C0  49AF881B     LDRH R3, [R3]
19C2  680A49AF     LDR R1, [PC, #700]
19C4  4694680A     LDR R2, [R1]
19C6  44634694     MOV R12, R2
19C8  4AAE4463     ADD R3, R12
1725:                  ext_spe_ref_mem -= ext_spe_ref_fil;
19CA  88104AAE     LDR R2, [PC, #696]
19CC  1A1B8810     LDRH R0, [R2]
19CE  600B1A1B     SUBS R3, R3, R0
19D0  A9B600B     STR R3, [R1]
1726:                  ext_spe_ref_fil = (uint16_t)(ext_spe_ref_mem >> SH_MEAS_FIL);
19D2  80130A9B     LSRS R3, R3, #10
19D4  E6168013     STRH R3, [R2]
19D6  4B99E616     B.N 0x1606
1727:                  /*lint -restore */
1728:              }/* if state run is not zero */
1729:              else
1730:              {
1731:                  pwm_modulation_reset();
1732:          //        phase_lost_filters_reset();
1733:          
1734:                  sysph.ang = 0;
1588  80134A97     LDR R2, [PC, #604]
158A  80538013     STRH R3, [R2]
1735:                  sysph.sin = 0;
158C  21808053     STRH R3, [R2, #2]
1736:                  sysph.cos = (int16_t)BASE_VALUE_INT;
158E  1C92180     MOVS R1, #128
1590  809101C9     LSLS R1, R1, #7
1592  4A958091     STRH R1, [R2, #4]
1737:          
1738:                  curdqr.x = 0;
1594  80134A95     LDR R2, [PC, #596]
1596  80538013     STRH R3, [R2]
1739:                  curdqr.y = 0;
1598  4A958053     STRH R3, [R2, #2]
1740:                  curdqm.x = 0;
159A  80134A95     LDR R2, [PC, #596]
159C  80538013     STRH R3, [R2]
1741:                  curdqm.y = 0;
159E  4A948053     STRH R3, [R2, #2]
1742:                  id_pi.imem = 0;
15A0  60D34A94     LDR R2, [PC, #592]
15A2  4A9460D3     STR R3, [R2, #12]
1743:                  iq_pi.imem = 0;
15A4  60D34A94     LDR R2, [PC, #592]
15A6  4A9460D3     STR R3, [R2, #12]
1744:                  sp_pi.imem = 0;
15A8  60D34A94     LDR R2, [PC, #592]
15AA  4A9460D3     STR R3, [R2, #12]
1745:          
1746:                  outvdq.x = 0;
15AC  80134A94     LDR R2, [PC, #592]
15AE  80538013     STRH R3, [R2]
1747:                  outvdq.y = 0;
15B0  4A948053     STRH R3, [R2, #2]
1748:                  outvab.x = 0;
15B2  80134A94     LDR R2, [PC, #592]
15B4  80538013     STRH R3, [R2]
1749:                  outvab.y = 0;
15B6  4A938053     STRH R3, [R2, #2]
1750:          
1751:          
1752:                  motor_status = STOPPED;
15B8  21004A93     LDR R2, [PC, #588]
15BA  70112100     MOVS R1, #0
15BC  4A937011     STRB R1, [R2]
1753:          
1754:                  dcurref_l = 0;
15BE  60134A93     LDR R2, [PC, #588]
15C0  4A936013     STR R3, [R2]
1755:                  newsysph = 0;
15C2  80134A93     LDR R2, [PC, #588]
15C4  4A938013     STRH R3, [R2]
1756:                  ampsysph = 0;
15C6  60134A93     LDR R2, [PC, #588]
15C8  4A936013     STR R3, [R2]
1757:                  elespeed_abs = 0;
15CA  80134A93     LDR R2, [PC, #588]
15CC  4A938013     STRH R3, [R2]
1758:                  elespeed = 0;
15CE  80134A93     LDR R2, [PC, #588]
15D0  4A938013     STRH R3, [R2]
1759:                  spe_ref_mem = 0;
15D2  60134A93     LDR R2, [PC, #588]
15D4  4A936013     STR R3, [R2]
1760:                  spe_ref_fil = 0;
15D6  80134A93     LDR R2, [PC, #588]
15D8  4A938013     STRH R3, [R2]
1761:                  elespeed_l = 0;
15DA  60134A93     LDR R2, [PC, #588]
15DC  4A936013     STR R3, [R2]
1762:          
1763:                  idfil_mem = 0;
15DE  60134A93     LDR R2, [PC, #588]
15E0  4A936013     STR R3, [R2]
1764:                  idfil = 0;
15E2  80134A93     LDR R2, [PC, #588]
15E4  4A938013     STRH R3, [R2]
1765:                  iqfil_mem = 0;
15E6  60134A93     LDR R2, [PC, #588]
15E8  4A936013     STR R3, [R2]
1766:                  iqfil = 0;
15EA  80134A93     LDR R2, [PC, #588]
15EC  4A938013     STRH R3, [R2]
1767:                  vdfil_mem = 0;
15EE  60134A93     LDR R2, [PC, #588]
15F0  4A936013     STR R3, [R2]
1768:                  vdfil = 0;
15F2  80134A93     LDR R2, [PC, #588]
15F4  4A938013     STRH R3, [R2]
1769:                  vqfil_mem = 0;
15F6  60134A93     LDR R2, [PC, #588]
15F8  4A936013     STR R3, [R2]
1770:                  vqfil = 0;
15FA  80134A93     LDR R2, [PC, #588]
15FC  4A938013     STRH R3, [R2]
1771:                  espabs_mem = 0;
15FE  60134A93     LDR R2, [PC, #588]
1600  4A936013     STR R3, [R2]
1772:                  espabs_fil = 0;
1602  80134A93     LDR R2, [PC, #588]
1604  4B718013     STRH R3, [R2]
1773:          
1774:              }
1775:          
1776:              /* minimum bus voltage calculation */
1777:              s32a = vbus;
1606  22004B71     LDR R3, [PC, #452]
1608  5E9A2200     MOVS R2, #0
160A  4B915E9A     LDRSH R2, [R3, R2]
1778:              s32a -= vbmin;
160C  21004B91     LDR R3, [PC, #580]
160E  5E5B2100     MOVS R1, #0
1610  1AD35E5B     LDRSH R3, [R3, R1]
1612  D5001AD3     SUBS R3, R2, R3
1779:              if(0 > s32a)
1614  E2FBD500     BPL.N 0x1618
1616  498FE2FB     B.N 0x1410
1780:              {
1781:                /*lint -save -e9027 , 10.1 violated for optimization*/
1782:                  s32a <<= SH_VBMIN_DEC;  /* faster decrease */
1C10  E501011B     LSLS R3, R3, #4
1783:              }
1784:              vbmin_mem += s32a;
1618  6808498F     LDR R1, [PC, #572]
161A  46846808     LDR R0, [R1]
161C  44634684     MOV R12, R0
161E  600B4463     ADD R3, R12
1620  129B600B     STR R3, [R1]
1785:              vbmin = (int16_t)(vbmin_mem >> SH_VBMIN_INC);
1622  B21B129B     ASRS R3, R3, #10
1624  498BB21B     SXTH R3, R3
1626  800B498B     LDR R1, [PC, #556]
1628  498C800B     STRH R3, [R1]
1786:          
1787:              /* available voltage calculation */
1788:              s32a = (int32_t)vbmin * K_AVAIL_VOL;
162A  434B498C     LDR R1, [PC, #560]
162C  139B434B     MULS R3, R1
1789:              outvmax = (int16_t)(s32a >> SH_BASE_VALUE);
162E  498B139B     ASRS R3, R3, #14
1630  800B498B     LDR R1, [PC, #556]
1632  488B800B     STRH R3, [R1]
1790:          
1791:              /* filters */
1792:              vbfil_mem += vbus;
1634  6803488B     LDR R0, [PC, #556]
1636  469C6803     LDR R3, [R0]
1638  4462469C     MOV R12, R3
163A  498A4462     ADD R2, R12
1793:              vbfil_mem -= vbfil;
163C  2400498A     LDR R1, [PC, #552]
163E  5F0B2400     MOVS R4, #0
1640  1AD35F0B     LDRSH R3, [R1, R4]
1642  60031AD3     SUBS R3, R2, R3
1644  131B6003     STR R3, [R0]
1794:              vbfil = (int16_t)(vbfil_mem >> 12);
1646  800B131B     ASRS R3, R3, #12
1648  4B88800B     STRH R3, [R1]
1795:              /*lint -restore */
1796:          
1797:              /* slower routines synchronization counter management */
1798:              if(0U < syn_cnt)
164A  881B4B88     LDR R3, [PC, #544]
164C  2B00881B     LDRH R3, [R3]
164E  D0022B00     CMP R3, #0
1650  3B01D002     BEQ.N 0x1658
1799:              {
1800:                  --syn_cnt;
1652  4A853B01     SUBS R3, #1
1654  80134A85     LDR R2, [PC, #532]
1656  BC1C8013     STRH R3, [R2]
1801:              }
1802:          
1803:            
1804:          }
1658  4690BC1C     POP {R2, R3, R4}
165A  46994690     MOV R8, R2
165C  46A24699     MOV R9, R3
165E  BDF046A2     MOV R10, R4
1660  4D63BDF0     POP {R4, R5, R6, R7, PC}
1662  4C604D63     LDR R5, [PC, #396]
1664  2A4C60     LDR R4, [PC, #384]
1666  4981002A     MOVS R2, R5
1668  204981     LDR R1, [PC, #516]
166A  4B810020     MOVS R0, R4
166C  47984B81     LDR R3, [PC, #516]
166E  4B674798     BLX R3
1670  881B4B67     LDR R3, [PC, #412]
1672  8023881B     LDRH R3, [R3]
1674  208023     STRH R3, [R4]
1676  4B7F0020     MOVS R0, R4
1678  47984B7F     LDR R3, [PC, #508]
167A  4F784798     BLX R3
167C  23004F78     LDR R7, [PC, #480]
167E  5EFA2300     MOVS R3, #0
1680  4B7E5EFA     LDRSH R2, [R7, R3]
1682  43534B7E     LDR R3, [PC, #504]
1684  139B4353     MULS R3, R2
1686  495A139B     ASRS R3, R3, #14
1688  810B495A     LDR R1, [PC, #360]
168A  425B810B     STRH R3, [R1, #8]
168C  814B425B     RSBS R3, R3, #0
168E  4B56814B     STRH R3, [R1, #10]
1690  46994B56     LDR R3, [PC, #344]
1692  20004699     MOV R9, R3
1694  5E182000     MOVS R0, #0
1696  22005E18     LDRSH R0, [R3, R0]
1698  5EAB2200     MOVS R2, #0
169A  1AC05EAB     LDRSH R3, [R5, R2]
169C  4B781AC0     SUBS R0, R0, R3
169E  46984B78     LDR R3, [PC, #480]
16A0  47984698     MOV R8, R3
16A2  14798     BLX R3
16A4  4E560001     MOVS R1, R0
16A6  80304E56     LDR R6, [PC, #344]
16A8  23008030     STRH R0, [R6]
16AA  5EF82300     MOVS R3, #0
16AC  4B755EF8     LDRSH R0, [R7, R3]
16AE  47984B75     LDR R3, [PC, #468]
16B0  49514798     BLX R3
16B2  81084951     LDR R1, [PC, #324]
16B4  42408108     STRH R0, [R1, #8]
16B6  81484240     RSBS R0, R0, #0
16B8  464B8148     STRH R0, [R1, #10]
16BA  2002464B     MOV R3, R9
16BC  5E182002     MOVS R0, #2
16BE  22025E18     LDRSH R0, [R3, R0]
16C0  5EAB2202     MOVS R2, #2
16C2  1AC05EAB     LDRSH R3, [R5, R2]
16C4  47C01AC0     SUBS R0, R0, R3
16C6  807047C0     BLX R8
16C8  4A4E8070     STRH R0, [R6, #2]
16CA  314A4E     LDR R2, [PC, #312]
16CC  200031     MOVS R1, R6
16CE  4B6D0020     MOVS R0, R4
16D0  47984B6D     LDR R3, [PC, #436]
16D2  4B6D4798     BLX R3
16D4  47984B6D     LDR R3, [PC, #436]
16D6  4B4B4798     BLX R3
16D8  781A4B4B     LDR R3, [PC, #300]
16DA  2A04781A     LDRB R2, [R3]
16DC  D9002A04     CMP R2, #4
16DE  E12BD900     BLS.N 0x16E2
16E0  93E12B     B.N 0x193A
16E2  4A6A0093     LSLS R3, R2, #2
16E4  58D34A6A     LDR R2, [PC, #424]
16E6  469F58D3     LDR R3, [R2, R3]
16E8  4B6A469F     MOV PC, R3
16EA  681A4B6A     LDR R3, [PC, #424]
16EC  4B6A681A     LDR R2, [R3]
16EE  801A4B6A     LDR R3, [PC, #424]
16F0  2300801A     STRH R2, [R3]
16F2  49452300     MOVS R3, #0
16F4  600B4945     LDR R1, [PC, #276]
16F6  493C600B     STR R3, [R1]
16F8  800B493C     LDR R1, [PC, #240]
16FA  804B800B     STRH R3, [R1]
16FC  4944804B     STRH R3, [R1, #2]
16FE  800B4944     LDR R1, [PC, #272]
1700  4944800B     STRH R3, [R1]
1702  600B4944     LDR R1, [PC, #272]
1704  4945600B     STR R3, [R1]
1706  800B4945     LDR R1, [PC, #276]
1708  4943800B     STRH R3, [R1]
170A  800B4943     LDR R1, [PC, #268]
170C  4946800B     STRH R3, [R1]
170E  600B4946     LDR R1, [PC, #280]
1710  4B62600B     STR R3, [R1]
1712  21004B62     LDR R3, [PC, #392]
1714  5E5B2100     MOVS R1, #0
1716  2B005E5B     LDRSH R3, [R3, R1]
1718  D1002B00     CMP R3, #0
171A  E10DD100     BNE.N 0x171E
171C  2101E10D     B.N 0x193A
171E  4B392101     MOVS R1, #1
1720  70194B39     LDR R3, [PC, #228]
1722  32017019     STRB R1, [R3]
1724  4B5B3201     ADDS R2, #1
1726  601A4B5B     LDR R3, [PC, #364]
1728  E106601A     STR R2, [R3]
172A  4B59E106     B.N 0x193A
172C  681B4B59     LDR R3, [PC, #356]
172E  4A5B681B     LDR R3, [R3]
1730  80134A5B     LDR R2, [PC, #364]
1732  4A5B8013     STRH R3, [R2]
1734  21004A5B     LDR R2, [PC, #364]
1736  5E522100     MOVS R1, #0
1738  2A005E52     LDRSH R2, [R2, R1]
173A  D10B2A00     CMP R2, #0
173C  4A2BD10B     BNE.N 0x1756
173E  23004A2B     LDR R2, [PC, #172]
1740  80132300     MOVS R3, #0
1742  80538013     STRH R3, [R2]
1744  4A358053     STRH R3, [R2, #2]
1746  80134A35     LDR R2, [PC, #212]
1748  4A338013     STRH R3, [R2]
174A  80134A33     LDR R2, [PC, #204]
174C  4B2E8013     STRH R3, [R2]
174E  22004B2E     LDR R3, [PC, #184]
1750  701A2200     MOVS R2, #0
1752  E0F1701A     STRB R2, [R3]
1754  4A51E0F1     B.N 0x193A
1756  21004A51     LDR R2, [PC, #324]
1758  5E522100     MOVS R1, #0
175A  2A005E52     LDRSH R2, [R2, R1]
175C  DD192A00     CMP R2, #0
175E  4A51DD19     BLE.N 0x1794
1760  49224A51     LDR R2, [PC, #324]
1762  20024922     LDR R1, [PC, #136]
1764  5E092002     MOVS R0, #2
1766  42915E09     LDRSH R1, [R1, R0]
1768  DC094291     CMP R1, R2
176A  4A27DC09     BGT.N 0x1780
176C  68134A27     LDR R2, [PC, #156]
176E  494E6813     LDR R3, [R2]
1770  468C494E     LDR R1, [PC, #312]
1772  4463468C     MOV R12, R1
1774  60134463     ADD R3, R12
1776  139B6013     STR R3, [R2]
1778  4A1C139B     ASRS R3, R3, #14
177A  80534A1C     LDR R2, [PC, #112]
177C  E0DC8053     STRH R3, [R2, #2]
177E  494BE0DC     B.N 0x193A
1780  4A1A494B     LDR R1, [PC, #300]
1782  80514A1A     LDR R2, [PC, #104]
1784  21028051     STRH R1, [R2, #2]
1786  4A1F2102     MOVS R1, #2
1788  70114A1F     LDR R2, [PC, #124]
178A  33017011     STRB R1, [R2]
178C  4A413301     ADDS R3, #1
178E  60134A41     LDR R2, [PC, #260]
1790  E0D26013     STR R3, [R2]
1792  4A47E0D2     B.N 0x193A
1794  49154A47     LDR R2, [PC, #284]
1796  20024915     LDR R1, [PC, #84]
1798  5E092002     MOVS R0, #2
179A  42915E09     LDRSH R1, [R1, R0]
179C  DB094291     CMP R1, R2
179E  4A1ADB09     BLT.N 0x17B4
17A0  68134A1A     LDR R2, [PC, #104]
17A2  49446813     LDR R3, [R2]
17A4  468C4944     LDR R1, [PC, #272]
17A6  4463468C     MOV R12, R1
17A8  60134463     ADD R3, R12
17AA  139B6013     STR R3, [R2]
17AC  4A0F139B     ASRS R3, R3, #14
17AE  80534A0F     LDR R2, [PC, #60]
17B0  E0C28053     STRH R3, [R2, #2]
17B2  4941E0C2     B.N 0x193A
17B4  4A0D4941     LDR R1, [PC, #260]
17B6  80514A0D     LDR R2, [PC, #52]
17B8  21028051     STRH R1, [R2, #2]
17BA  4A122102     MOVS R1, #2
17BC  70114A12     LDR R2, [PC, #72]
17BE  33017011     STRB R1, [R2]
17C0  4A343301     ADDS R3, #1
17C2  60134A34     LDR R2, [PC, #208]
17C4  E0B86013     STR R3, [R2]
17C6  188E0B8     B.N 0x193A
17C8  20000188     LSLS R0, R1, #6
17CA  29282000     MOVS R0, #0
17CC  20002928     CMP R1, #40
17CE  12E2000     MOVS R0, #0
17D0  2000012E     LSLS R6, R5, #4
17D2  28682000     MOVS R0, #0
17D4  20002868     CMP R0, #104
17D6  28662000     MOVS R0, #0
17D8  20002866     CMP R0, #102
17DA  286E2000     MOVS R0, #0
17DC  2000286E     CMP R0, #110
17DE  28762000     MOVS R0, #0
17E0  20002876     CMP R0, #118
17E2  24002000     MOVS R0, #0
17E4  42002400     MOVS R4, #0
17E6  28704200     TST R0, R0
17E8  20002870     CMP R0, #112
17EA  28882000     MOVS R0, #0
17EC  20002888     CMP R0, #136
17EE  28842000     MOVS R0, #0
17F0  20002884     CMP R0, #132
17F2  D82000     MOVS R0, #0
17F4  200000D8     LSLS R0, R3, #3
17F6  EC2000     MOVS R0, #0
17F8  200000EC     LSLS R4, R5, #3
17FA  1402000     MOVS R0, #0
17FC  20000140     LSLS R0, R0, #5
17FE  28AC2000     MOVS R0, #0
1800  200028AC     CMP R0, #172
1802  28A82000     MOVS R0, #0
1804  200028A8     CMP R0, #168
1806  29422000     MOVS R0, #0
1808  20002942     CMP R1, #66
180A  288C2000     MOVS R0, #0
180C  2000288C     CMP R0, #140
180E  29102000     MOVS R0, #0
1810  20002910     CMP R1, #16
1812  28782000     MOVS R0, #0
1814  20002878     CMP R0, #120
1816  290E2000     MOVS R0, #0
1818  2000290E     CMP R1, #14
181A  290C2000     MOVS R0, #0
181C  2000290C     CMP R1, #12
181E  28B02000     MOVS R0, #0
1820  200028B0     CMP R0, #176
1822  29162000     MOVS R0, #0
1824  20002916     CMP R1, #22
1826  28942000     MOVS R0, #0
1828  20002894     CMP R0, #148
182A  28A02000     MOVS R0, #0
182C  200028A0     CMP R0, #160
182E  1562000     MOVS R0, #0
1830  20000156     LSLS R6, R2, #5
1832  28A42000     MOVS R0, #0
1834  200028A4     CMP R0, #164
1836  D62000     MOVS R0, #0
1838  200000D6     LSLS R6, R2, #3
183A  28BC2000     MOVS R0, #0
183C  200028BC     CMP R0, #188
183E  13A2000     MOVS R0, #0
1840  2000013A     LSLS R2, R7, #4
1842  28C02000     MOVS R0, #0
1844  200028C0     CMP R0, #192
1846  D42000     MOVS R0, #0
1848  200000D4     LSLS R4, R2, #3
184A  28982000     MOVS R0, #0
184C  20002898     CMP R0, #152
184E  D22000     MOVS R0, #0
1850  200000D2     LSLS R2, R2, #3
1852  29262000     MOVS R0, #0
1854  20002926     CMP R1, #38
1856  28B82000     MOVS R0, #0
1858  200028B8     CMP R0, #184
185A  24062000     MOVS R0, #0
185C  2406     MOVS R4, #6
185E  29120000     MOVS R0, R0
1860  20002912     CMP R1, #18
1862  28B42000     MOVS R0, #0
1864  200028B4     CMP R0, #180
1866  1122000     MOVS R0, #0
1868  20000112     LSLS R2, R2, #4
186A  1582000     MOVS R0, #0
186C  20000158     LSLS R0, R3, #5
186E  287C2000     MOVS R0, #0
1870  2000287C     CMP R0, #124
1872  5EF52000     MOVS R0, #0
1874  5EF5     LDRSH R5, [R6, R3]
1876  62E10000     MOVS R0, R0
1878  62E1     STR R1, [R4, #44]
187A  39990000     MOVS R0, R0
187C  3999     SUBS R1, #153
187E  48F50000     MOVS R0, R0
1880  48F5     LDR R0, [PC, #980]
1882  5CCD0000     MOVS R0, R0
1884  5CCD     LDRB R5, [R1, R3]
1886  5F2D0000     MOVS R0, R0
1888  5F2D     LDRSH R5, [R5, R4]
188A  39910000     MOVS R0, R0
188C  3991     SUBS R1, #145
188E  64780000     MOVS R0, R0
1890  6478     STR R0, [R7, #68]
1892  28C40000     MOVS R0, R0
1894  200028C4     CMP R0, #196
1896  29222000     MOVS R0, #0
1898  20002922     CMP R1, #34
189A  1322000     MOVS R0, #0
189C  20000132     LSLS R2, R6, #4
189E  291A2000     MOVS R0, #0
18A0  2000291A     CMP R1, #26
18A2  CE2000     MOVS R0, #0
18A4  200000CE     LSLS R6, R1, #3
18A6  BA12000     MOVS R0, #0
18A8  0BA1     LSRS R1, R4, #14
18AA  261E0000     MOVS R0, R0
18AC  261E     MOVS R6, #30
18AE  BA20000     MOVS R0, R0
18B0  0BA2     LSRS R2, R4, #14
18B2  F45F0000     MOVS R0, R0
18B4  FFFFF45F     BL 0x1C618B6
18B6  D9E2FFFF     CDP2 P9, #15, CR13, CR15, CR2, {7}
18B8  FFFFD9E2     BLS.N 0x1880
18BA  F45EFFFF     MRC2 P4, #7, PC, CR15, CR14, {2}
18BC  FFFFF45E     BL 0x1C608BE
18BE  4BD4FFFF     MRC2 P11, #7, R4, CR15, CR4, {6}
18C0  681A4BD4     LDR R3, $d
18C2  4BD4681A     LDR R2, [R3]
18C4  801A4BD4     LDR R3, [PC, #848]
18C6  23F5801A     STRH R2, [R3]
18C8  5B23F5     MOVS R3, #245
18CA  4AD3005B     LSLS R3, R3, #1
18CC  88124AD3     LDR R2, [PC, #844]
18CE  429A8812     LDRH R2, [R2]
18D0  D900429A     CMP R2, R3
18D2  E080D900     BLS.N 0x18D6
18D4  4BD2E080     B.N 0x19D8
18D6  20004BD2     LDR R3, [PC, #840]
18D8  5E182000     MOVS R0, #0
18DA  4AD15E18     LDRSH R0, [R3, R0]
18DC  49D24AD1     LDR R2, [PC, #836]
18DE  4BD249D2     LDR R1, [PC, #840]
18E0  47984BD2     LDR R3, [PC, #840]
18E2  4BD24798     BLX R3
18E4  4ACD4BD2     LDR R3, [PC, #840]
18E6  88124ACD     LDR R2, [PC, #820]
18E8  429A8812     LDRH R2, [R2]
18EA  D900429A     CMP R2, R3
18EC  E07BD900     BLS.N 0x18F0
18EE  4BD0E07B     B.N 0x19E8
18F0  681A4BD0     LDR R3, [PC, #832]
18F2  21A1681A     LDR R2, [R3]
18F4  8921A1     MOVS R1, #161
18F6  468C0089     LSLS R1, R1, #2
18F8  4462468C     MOV R12, R1
18FA  104462     ADD R2, R12
18FC  601A0010     MOVS R0, R2
18FE  49CD601A     STR R2, [R3]
1900  4BCE49CD     LDR R1, [PC, #820]
1902  47984BCE     LDR R3, [PC, #824]
1904  4BC54798     BLX R3
1906  80184BC5     LDR R3, [PC, #788]
1908  4BCD8018     STRH R0, [R3]
190A  22004BCD     LDR R3, [PC, #820]
190C  5E9B2200     MOVS R2, #0
190E  2B005E9B     LDRSH R3, [R3, R2]
1910  DA002B00     CMP R3, #0
1912  E07BDA00     BGE.N 0x1916
1914  DC00E07B     B.N 0x1A0E
1916  E085DC00     BGT.N 0x191A
1918  4BC0E085     B.N 0x1A26
191A  881A4BC0     LDR R3, [PC, #768]
191C  4BC0881A     LDRH R2, [R3]
191E  801A4BC0     LDR R3, [PC, #768]
1920  4AC8801A     STRH R2, [R3]
1922  4BC34AC8     LDR R2, [PC, #800]
1924  681B4BC3     LDR R3, [PC, #780]
1926  6811681B     LDR R3, [R3]
1928  468C6811     LDR R1, [R2]
192A  4463468C     MOV R12, R1
192C  60134463     ADD R3, R12
192E  4BC46013     STR R3, [R2]
1930  681B4BC4     LDR R3, [PC, #784]
1932  B9B681B     LDR R3, [R3]
1934  4AC40B9B     LSRS R3, R3, #14
1936  80134AC4     LDR R2, [PC, #784]
1938  4AC48013     STRH R3, [R2]
193A  21004AC4     LDR R2, [PC, #784]
193C  5E532100     MOVS R1, #0
193E  48C35E53     LDRSH R3, [R2, R1]
1940  680148C3     LDR R0, [PC, #780]
1942  468C6801     LDR R1, [R0]
1944  4463468C     MOV R12, R1
1946  49C24463     ADD R3, R12
1948  250049C2     LDR R1, [PC, #776]
194A  5F4C2500     MOVS R5, #0
194C  1B1B5F4C     LDRSH R4, [R1, R5]
194E  60031B1B     SUBS R3, R3, R4
1950  129B6003     STR R3, [R0]
1952  800B129B     ASRS R3, R3, #10
1954  2302800B     STRH R3, [R1]
1956  5ED32302     MOVS R3, #2
1958  49BF5ED3     LDRSH R3, [R2, R3]
195A  680A49BF     LDR R1, [PC, #764]
195C  4694680A     LDR R2, [R1]
195E  44634694     MOV R12, R2
1960  4ABE4463     ADD R3, R12
1962  24004ABE     LDR R2, [PC, #760]
1964  5F102400     MOVS R4, #0
1966  1A1B5F10     LDRSH R0, [R2, R4]
1968  600B1A1B     SUBS R3, R3, R0
196A  129B600B     STR R3, [R1]
196C  8013129B     ASRS R3, R3, #10
196E  4ABB8013     STRH R3, [R2]
1970  21004ABB     LDR R2, [PC, #748]
1972  5E532100     MOVS R1, #0
1974  48BB5E53     LDRSH R3, [R2, R1]
1976  680148BB     LDR R0, [PC, #748]
1978  468C6801     LDR R1, [R0]
197A  4463468C     MOV R12, R1
197C  49BA4463     ADD R3, R12
197E  250049BA     LDR R1, [PC, #744]
1980  5F4C2500     MOVS R5, #0
1982  1B1B5F4C     LDRSH R4, [R1, R5]
1984  60031B1B     SUBS R3, R3, R4
1986  129B6003     STR R3, [R0]
1988  800B129B     ASRS R3, R3, #10
198A  2302800B     STRH R3, [R1]
198C  5ED32302     MOVS R3, #2
198E  49B65ED3     LDRSH R3, [R2, R3]
1990  680A49B6     LDR R1, [PC, #728]
1992  4694680A     LDR R2, [R1]
1994  44634694     MOV R12, R2
1996  4AB54463     ADD R3, R12
1998  24004AB5     LDR R2, [PC, #724]
199A  5F102400     MOVS R4, #0
199C  1A1B5F10     LDRSH R0, [R2, R4]
199E  600B1A1B     SUBS R3, R3, R0
19A0  129B600B     STR R3, [R1]
19A2  8013129B     ASRS R3, R3, #10
19A4  4B9D8013     STRH R3, [R2]
19A6  881B4B9D     LDR R3, [PC, #628]
19A8  49B2881B     LDRH R3, [R3]
19AA  680A49B2     LDR R1, [PC, #712]
19AC  4694680A     LDR R2, [R1]
19AE  44634694     MOV R12, R2
19B0  4AB14463     ADD R3, R12
19B2  88104AB1     LDR R2, [PC, #708]
19B4  1A1B8810     LDRH R0, [R2]
19B6  600B1A1B     SUBS R3, R3, R0
19B8  A9B600B     STR R3, [R1]
19BA  80130A9B     LSRS R3, R3, #10
19BC  4BAF8013     STRH R3, [R2]
19BE  881B4BAF     LDR R3, [PC, #700]
19C0  49AF881B     LDRH R3, [R3]
19C2  680A49AF     LDR R1, [PC, #700]
19C4  4694680A     LDR R2, [R1]
19C6  44634694     MOV R12, R2
19C8  4AAE4463     ADD R3, R12
19CA  88104AAE     LDR R2, [PC, #696]
19CC  1A1B8810     LDRH R0, [R2]
19CE  600B1A1B     SUBS R3, R3, R0
19D0  A9B600B     STR R3, [R1]
19D2  80130A9B     LSRS R3, R3, #10
19D4  E6168013     STRH R3, [R2]
19D6  4B99E616     B.N 0x1606
19D8  20004B99     LDR R3, [PC, #612]
19DA  5E182000     MOVS R0, #0
19DC  4A915E18     LDRSH R0, [R3, R0]
19DE  49914A91     LDR R2, [PC, #580]
19E0  4BA94991     LDR R1, [PC, #580]
19E2  47984BA9     LDR R3, [PC, #676]
19E4  E77D4798     BLX R3
19E6  4BA8E77D     B.N .LVL172
19E8  4A8C4BA8     LDR R3, [PC, #672]
19EA  80134A8C     LDR R2, [PC, #560]
19EC  49A88013     STRH R3, [R2]
19EE  4A9049A8     LDR R1, [PC, #672]
19F0  60114A90     LDR R2, [PC, #576]
19F2  4AA76011     STR R1, [R2]
19F4  80134AA7     LDR R2, [PC, #668]
19F6  4AA78013     STRH R3, [R2]
19F8  4BA84AA7     LDR R2, [PC, #668]
19FA  601A4BA8     LDR R3, [PC, #672]
19FC  2203601A     STR R2, [R3]
19FE  4BA72203     MOVS R2, #3
1A00  701A4BA7     LDR R3, [PC, #668]
1A02  4A83701A     STRB R2, [R3]
1A04  68134A83     LDR R2, $d
1A06  33016813     LDR R3, [R2]
1A08  60133301     ADDS R3, #1
1A0A  E77D6013     STR R3, [R2]
1A0C  4B83E77D     B.N 0x190A
1A0E  881B4B83     LDR R3, [PC, #524]
1A10  425B881B     LDRH R3, [R3]
1A12  4A82425B     RSBS R3, R3, #0
1A14  80134A82     LDR R2, [PC, #520]
1A16  4A8A8013     STRH R3, [R2]
1A18  4B864A8A     LDR R2, [PC, #552]
1A1A  681B4B86     LDR R3, [PC, #536]
1A1C  6811681B     LDR R3, [R3]
1A1E  1ACB6811     LDR R1, [R2]
1A20  60131ACB     SUBS R3, R1, R3
1A22  E7846013     STR R3, [R2]
1A24  4A9FE784     B.N 0x1930
1A26  23004A9F     LDR R2, [PC, #636]
1A28  80132300     MOVS R3, #0
1A2A  80538013     STRH R3, [R2]
1A2C  4A7C8053     STRH R3, [R2, #2]
1A2E  80134A7C     LDR R2, [PC, #496]
1A30  4A7A8013     STRH R3, [R2]
1A32  80134A7A     LDR R2, [PC, #488]
1A34  4B9A8013     STRH R3, [R2]
1A36  22004B9A     LDR R3, [PC, #616]
1A38  701A2200     MOVS R2, #0
1A3A  E778701A     STRB R2, [R3]
1A3C  4B75E778     B.N 0x1930
1A3E  681A4B75     LDR R3, [PC, #468]
1A40  4B99681A     LDR R2, [R3]
1A42  801A4B99     LDR R3, [PC, #612]
1A44  4B7E801A     STRH R2, [R3]
1A46  20004B7E     LDR R3, [PC, #504]
1A48  5E182000     MOVS R0, #0
1A4A  4A755E18     LDRSH R0, [R3, R0]
1A4C  49764A75     LDR R2, [PC, #468]
1A4E  4B8D4976     LDR R1, [PC, #472]
1A50  47984B8D     LDR R3, [PC, #564]
1A52  4B954798     BLX R3
1A54  47984B95     LDR R3, [PC, #596]
1A56  4B954798     BLX R3
1A58  881B4B95     LDR R3, [PC, #596]
1A5A  18C0881B     LDRH R3, [R3]
1A5C  4B7A18C0     ADDS R0, R0, R3
1A5E  80184B7A     LDR R3, [PC, #488]
1A60  4B948018     STRH R0, [R3]
1A62  47984B94     LDR R3, [PC, #592]
1A64  4B6E4798     BLX R3
1A66  80184B6E     LDR R3, [PC, #440]
1A68  28008018     STRH R0, [R3]
1A6A  DD502800     CMP R0, #0
1A6C  4B89DD50     BLE.N 0x1A10
1A6E  80184B89     LDR R3, [PC, #548]
1A70  4B888018     STRH R0, [R3]
1A72  881B4B88     LDR R3, [PC, #544]
1A74  29B881B     LDRH R3, [R3]
1A76  4A88029B     LSLS R3, R3, #10
1A78  60134A88     LDR R2, [PC, #544]
1A7A  4C786013     STR R3, [R2]
1A7C  4B8E4C78     LDR R4, [PC, #480]
1A7E  469A4B8E     LDR R3, [PC, #568]
1A80  885B469A     MOV R10, R3
1A82  4652885B     LDRH R3, [R3, #2]
1A84  68D24652     MOV R2, R10
1A86  411A68D2     LDR R2, [R2, #12]
1A88  8022411A     ASRS R2, R3
1A8A  4D8B8022     STRH R2, [R4]
1A8C  886B4D8B     LDR R5, [PC, #556]
1A8E  68EA886B     LDRH R3, [R5, #2]
1A90  411A68EA     LDR R2, [R5, #12]
1A92  8062411A     ASRS R2, R3
1A94  4A648062     STRH R2, [R4, #2]
1A96  214A64     LDR R2, [PC, #400]
1A98  48890021     MOVS R1, R4
1A9A  4F894889     LDR R0, [PC, #548]
1A9C  47B84F89     LDR R7, [PC, #548]
1A9E  4E8047B8     BLX R7
1AA0  4A894E80     LDR R6, [PC, #512]
1AA2  314A89     LDR R2, [PC, #548]
1AA4  48860031     MOVS R1, R6
1AA6  47B84886     LDR R0, [PC, #536]
1AA8  4B6747B8     BLX R7
1AAA  881B4B67     LDR R3, [PC, #412]
1AAC  4A84881B     LDRH R3, [R3]
1AAE  80134A84     LDR R2, [PC, #528]
1AB0  108013     STRH R3, [R2]
1AB2  4B850010     MOVS R0, R2
1AB4  47984B85     LDR R3, [PC, #532]
1AB6  224798     BLX R3
1AB8  495B0022     MOVS R2, R4
1ABA  4880495B     LDR R1, [PC, #364]
1ABC  4F844880     LDR R0, [PC, #512]
1ABE  47B84F84     LDR R7, [PC, #528]
1AC0  3247B8     BLX R7
1AC2  49800032     MOVS R2, R6
1AC4  487E4980     LDR R1, [PC, #512]
1AC6  47B8487E     LDR R0, [PC, #504]
1AC8  220047B8     BLX R7
1ACA  80322200     MOVS R2, #0
1ACC  21008032     STRH R2, [R6]
1ACE  5E632100     MOVS R1, #0
1AD0  46515E63     LDRSH R3, [R4, R1]
1AD2  88494651     MOV R1, R10
1AD4  408B8849     LDRH R1, [R1, #2]
1AD6  4651408B     LSLS R3, R1
1AD8  60CB4651     MOV R1, R10
1ADA  210260CB     STR R3, [R1, #12]
1ADC  5E632102     MOVS R1, #2
1ADE  88695E63     LDRSH R3, [R4, R1]
1AE0  408B8869     LDRH R1, [R5, #2]
1AE2  60EB408B     LSLS R3, R1
1AE4  4B7B60EB     STR R3, [R5, #12]
1AE6  601A4B7B     LDR R3, [PC, #492]
1AE8  4A7B601A     STR R2, [R3]
1AEA  21024A7B     LDR R2, [PC, #492]
1AEC  5E732102     MOVS R1, #2
1AEE  88515E73     LDRSH R3, [R6, R1]
1AF0  408B8851     LDRH R1, [R2, #2]
1AF2  60D3408B     LSLS R3, R1
1AF4  4B7960D3     STR R3, [R2, #12]
1AF6  22004B79     LDR R3, [PC, #484]
1AF8  5E9B2200     MOVS R2, #0
1AFA  2B005E9B     LDRSH R3, [R3, R2]
1AFC  D00B2B00     CMP R3, #0
1AFE  2204D00B     BEQ.N 0x1B18
1B00  4B672204     MOVS R2, #4
1B02  701A4B67     LDR R3, [PC, #412]
1B04  4A43701A     STRB R2, [R3]
1B06  68134A43     LDR R2, [PC, #268]
1B08  33016813     LDR R3, [R2]
1B0A  60133301     ADDS R3, #1
1B0C  E7146013     STR R3, [R2]
1B0E  4240E714     B.N 0x193A
1B10  4B604240     RSBS R0, R0, #0
1B12  80184B60     LDR R3, [PC, #384]
1B14  E7AC8018     STRH R0, [R3]
1B16  2300E7AC     B.N 0x1A72
1B18  4A622300     MOVS R3, #0
1B1A  80534A62     LDR R2, [PC, #392]
1B1C  4A408053     STRH R3, [R2, #2]
1B1E  80134A40     LDR R2, [PC, #256]
1B20  4A3E8013     STRH R3, [R2]
1B22  80134A3E     LDR R2, [PC, #248]
1B24  4B5E8013     STRH R3, [R2]
1B26  22004B5E     LDR R3, [PC, #376]
1B28  701A2200     MOVS R2, #0
1B2A  E705701A     STRB R2, [R3]
1B2C  4B39E705     B.N 0x193A
1B2E  681A4B39     LDR R3, [PC, #228]
1B30  4B6B681A     LDR R2, [R3]
1B32  801A4B6B     LDR R3, [PC, #428]
1B34  4B6B801A     STRH R2, [R3]
1B36  881B4B6B     LDR R3, [PC, #428]
1B38  4958881B     LDRH R3, [R3]
1B3A  680A4958     LDR R1, [PC, #352]
1B3C  4694680A     LDR R2, [R1]
1B3E  44634694     MOV R12, R2
1B40  4A544463     ADD R3, R12
1B42  88104A54     LDR R2, [PC, #336]
1B44  1A1B8810     LDRH R0, [R2]
1B46  600B1A1B     SUBS R3, R3, R0
1B48  A9B600B     STR R3, [R1]
1B4A  80130A9B     LSRS R3, R3, #10
1B4C  4B3C8013     STRH R3, [R2]
1B4E  20004B3C     LDR R3, [PC, #240]
1B50  5E182000     MOVS R0, #0
1B52  4A335E18     LDRSH R0, [R3, R0]
1B54  49344A33     LDR R2, [PC, #204]
1B56  4B4B4934     LDR R1, [PC, #208]
1B58  47984B4B     LDR R3, [PC, #300]
1B5A  4B534798     BLX R3
1B5C  47984B53     LDR R3, [PC, #332]
1B5E  4B534798     BLX R3
1B60  881B4B53     LDR R3, [PC, #332]
1B62  18C0881B     LDRH R3, [R3]
1B64  4B3818C0     ADDS R0, R0, R3
1B66  80184B38     LDR R3, [PC, #224]
1B68  4B528018     STRH R0, [R3]
1B6A  47984B52     LDR R3, [PC, #328]
1B6C  4B2C4798     BLX R3
1B6E  80184B2C     LDR R3, [PC, #176]
1B70  28008018     STRH R0, [R3]
1B72  DB332800     CMP R0, #0
1B74  4B29DB33     BLT.N 0x1BDE
1B76  80184B29     LDR R3, [PC, #164]
1B78  4B578018     STRH R0, [R3]
1B7A  4A5A4B57     LDR R3, [PC, #348]
1B7C  811A4A5A     LDR R2, [PC, #360]
1B7E  4A5A811A     STRH R2, [R3, #8]
1B80  815A4A5A     LDR R2, [PC, #360]
1B82  4B43815A     STRH R2, [R3, #10]
1B84  881B4B43     LDR R3, [PC, #268]
1B86  4A2D881B     LDRH R3, [R3]
1B88  21004A2D     LDR R2, [PC, #180]
1B8A  5E522100     MOVS R1, #0
1B8C  2A005E52     LDRSH R2, [R2, R1]
1B8E  DB292A00     CMP R2, #0
1B90  1A18DB29     BLT.N .LVL194
1B92  49501A18     SUBS R0, R3, R0
1B94  4B564950     LDR R1, [PC, #320]
1B96  47984B56     LDR R3, [PC, #344]
1B98  4B424798     BLX R3
1B9A  80584B42     LDR R3, [PC, #264]
1B9C  22008058     STRH R0, [R3, #2]
1B9E  5E9B2200     MOVS R2, #0
1BA0  2B005E9B     LDRSH R3, [R3, R2]
1BA2  D1002B00     CMP R3, #0
1BA4  E6C8D100     BNE.N 0x1BA8
1BA6  1E6C8     B.N 0x193A
1BA8  484F0001     MOVS R1, R0
1BAA  4B51484F     LDR R0, [PC, #316]
1BAC  47984B51     LDR R3, [PC, #324]
1BAE  3804798     BLX R3
1BB0  4B480380     LSLS R0, R0, #14
1BB2  681B4B48     LDR R3, [PC, #288]
1BB4  4298681B     LDR R3, [R3]
1BB6  DA174298     CMP R0, R3
1BB8  4B46DA17     BGE.N .LVL196
1BBA  60184B46     LDR R3, [PC, #280]
1BBC  4B456018     STR R0, [R3]
1BBE  681B4B45     LDR R3, [PC, #276]
1BC0  4A4D681B     LDR R3, [R3]
1BC2  42934A4D     LDR R2, [PC, #308]
1BC4  DD164293     CMP R3, R2
1BC6  4A4CDD16     BLE.N .LVL198
1BC8  46944A4C     LDR R2, [PC, #304]
1BCA  44634694     MOV R12, R2
1BCC  4A414463     ADD R3, R12
1BCE  60134A41     LDR R2, [PC, #260]
1BD0  4B406013     STR R3, [R2]
1BD2  681B4B40     LDR R3, [PC, #256]
1BD4  139B681B     LDR R3, [R3]
1BD6  4A32139B     ASRS R3, R3, #14
1BD8  80134A32     LDR R2, [PC, #200]
1BDA  E6AD8013     STRH R3, [R2]
1BDC  4243E6AD     B.N 0x193A
1BDE  4A0E4243     RSBS R0, R3, #0
1BE0  80134A0E     LDR R2, [PC, #56]
1BE2  E7C98013     STRH R3, [R2]
1BE4  425BE7C9     B.N 0x1B7A
1BE6  E7D3425B     RSBS R3, R3, #0
1BE8  4240E7D3     B.N .LVL187
1BEA  42834240     RSBS R0, R0, #0
1BEC  DAE64283     CMP R3, R0
1BEE  4B38DAE6     BGE.N .LVL193
1BF0  60184B38     LDR R3, [PC, #224]
1BF2  E7E36018     STR R0, [R3]
1BF4  4A41E7E3     B.N .LVL193
1BF6  42934A41     LDR R2, [PC, #260]
1BF8  DA054293     CMP R3, R2
1BFA  4A3EDA05     BGE.N 0x1C08
1BFC  46944A3E     LDR R2, [PC, #248]
1BFE  44634694     MOV R12, R2
1C00  4A344463     ADD R3, R12
1C02  60134A34     LDR R2, [PC, #208]
1C04  E7E46013     STR R3, [R2]
1C06  2200E7E4     B.N 0x1BD2
1C08  4B322200     MOVS R2, #0
1C0A  601A4B32     LDR R3, [PC, #200]
1C0C  E7E0601A     STR R2, [R3]
1C0E  11BE7E0     B.N 0x1BD2
1C10  E501011B     LSLS R3, R3, #4
1C12  28C4E501     B.N 0x2618
1C14  200028C4     CMP R0, #196
1C16  29202000     MOVS R0, #0
1C18  20002920     CMP R1, #32
1C1A  290E2000     MOVS R0, #0
1C1C  2000290E     CMP R1, #14
1C1E  290C2000     MOVS R0, #0
1C20  2000290C     CMP R1, #12
1C22  287C2000     MOVS R0, #0
1C24  2000287C     CMP R0, #124
1C26  28A82000     MOVS R0, #0
1C28  200028A8     CMP R0, #168
1C2A  606D2000     MOVS R0, #0
1C2C  606D     STR R5, [R5, #4]
1C2E  7AD0000     MOVS R0, R0
1C30  07AD     LSLS R5, R5, #30
1C32  28940000     MOVS R0, R0
1C34  20002894     CMP R0, #148
1C36  CCC2000     MOVS R0, #0
1C38  0CCC     LSRS R4, R1, #19
1C3A  44D90000     MOVS R0, R0
1C3C  44D9     ADD R9, R11
1C3E  1320000     MOVS R0, R0
1C40  20000132     LSLS R2, R6, #4
1C42  28782000     MOVS R0, #0
1C44  20002878     CMP R0, #120
1C46  29102000     MOVS R0, #0
1C48  20002910     CMP R1, #16
1C4A  28842000     MOVS R0, #0
1C4C  20002884     CMP R0, #132
1C4E  28A02000     MOVS R0, #0
1C50  200028A0     CMP R0, #160
1C52  1562000     MOVS R0, #0
1C54  20000156     LSLS R6, R2, #5
1C56  28A42000     MOVS R0, #0
1C58  200028A4     CMP R0, #164
1C5A  D62000     MOVS R0, #0
1C5C  200000D6     LSLS R6, R2, #3
1C5E  28AC2000     MOVS R0, #0
1C60  200028AC     CMP R0, #172
1C62  28BC2000     MOVS R0, #0
1C64  200028BC     CMP R0, #188
1C66  13A2000     MOVS R0, #0
1C68  2000013A     LSLS R2, R7, #4
1C6A  28C02000     MOVS R0, #0
1C6C  200028C0     CMP R0, #192
1C6E  D42000     MOVS R0, #0
1C70  200000D4     LSLS R4, R2, #3
1C72  28982000     MOVS R0, #0
1C74  20002898     CMP R0, #152
1C76  D22000     MOVS R0, #0
1C78  200000D2     LSLS R2, R2, #3
1C7A  EA2000     MOVS R0, #0
1C7C  200000EA     LSLS R2, R5, #3
1C7E  289C2000     MOVS R0, #0
1C80  2000289C     CMP R0, #156
1C82  1542000     MOVS R0, #0
1C84  20000154     LSLS R4, R2, #5
1C86  61AD2000     MOVS R0, #0
1C88  61AD     STR R5, [R5, #24]
1C8A  7AE0000     MOVS R0, R0
1C8C  07AE     LSLS R6, R5, #30
1C8E  46A80000     MOVS R0, R0
1C90  6246A8     MOV R8, R5
1C92  29160062     LSLS R2, R4, #1
1C94  20002916     CMP R1, #22
1C96  B8002000     MOVS R0, #0
1C98  1EB800     CBNZ R0, 0x1C9C
1C9A  28B0001E     MOVS R6, R3
1C9C  200028B0     CMP R0, #176
1C9E  29422000     MOVS R0, #0
1CA0  20002942     CMP R1, #66
1CA2  28882000     MOVS R0, #0
1CA4  20002888     CMP R0, #136
1CA6  291E2000     MOVS R0, #0
1CA8  2000291E     CMP R1, #30
1CAA  64092000     MOVS R0, #0
1CAC  6409     STR R1, [R1, #64]
1CAE  29140000     MOVS R0, R0
1CB0  20002914     CMP R1, #20
1CB2  651D2000     MOVS R0, #0
1CB4  651D     STR R5, [R3, #80]
1CB6  D80000     MOVS R0, R0
1CB8  200000D8     LSLS R0, R3, #3
1CBA  EC2000     MOVS R0, #0
1CBC  200000EC     LSLS R4, R5, #3
1CBE  28702000     MOVS R0, #0
1CC0  20002870     CMP R0, #112
1CC2  5F2D2000     MOVS R0, #0
1CC4  5F2D     LDRSH R5, [R5, R4]
1CC6  28800000     MOVS R0, R0
1CC8  20002880     CMP R0, #128
1CCA  62E12000     MOVS R0, #0
1CCC  62E1     STR R1, [R4, #44]
1CCE  5EF50000     MOVS R0, R0
1CD0  5EF5     LDRSH R5, [R6, R3]
1CD2  288C0000     MOVS R0, R0
1CD4  2000288C     CMP R0, #140
1CD6  1402000     MOVS R0, #0
1CD8  20000140     LSLS R0, R0, #5
1CDA  CE2000     MOVS R0, #0
1CDC  200000CE     LSLS R6, R1, #3
1CDE  291C2000     MOVS R0, #0
1CE0  2000291C     CMP R1, #28
1CE2  1222000     MOVS R0, #0
1CE4  20000122     LSLS R2, R4, #4
1CE6  1D172000     MOVS R0, #0
1CE8  1D17     ADDS R7, R2, #4
1CEA  E2E90000     MOVS R0, R0
1CEC  FFFFE2E9     B.N .LVL181
1CEE  48F5FFFF     MRC2 P8, #7, R4, CR15, CR5, {7}
1CF0  48F5     LDR R0, [PC, #980]
1CF2  5CCD0000     MOVS R0, R0
1CF4  5CCD     LDRB R5, [R1, R3]
1CF6  261E0000     MOVS R0, R0
1CF8  261E     MOVS R6, #30
1CFA  D9E20000     MOVS R0, R0
1CFC  FFFFD9E2     BLS.N 0x1CC4
1CFE  B510FFFF     MRC2 P5, #7, R11, CR15, CR0, {0}
1805:          
1806:          /* EOF motor_control.c */
1807:          
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/main_mclv2_sam_c21_pim.c  
1:             /*******************************************************************************
2:               Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This file contains the "main" function for a project.
12:            
13:              Description:
14:                This file contains the "main" function for a project.  The
15:                "main" function calls the "SYS_Initialize" function to initialize the state
16:                machines of all modules in the system
17:             *******************************************************************************/
18:            
19:            // *****************************************************************************
20:            // *****************************************************************************
21:            // Section: Included Files
22:            // *****************************************************************************
23:            // *****************************************************************************
24:            
25:            #include <stddef.h>                     // Defines NULL
26:            #include <stdbool.h>                    // Defines true
27:            #include <stdlib.h>                     // Defines EXIT_FAILURE
28:            #include "definitions.h"                // SYS function prototypes
29:            #include "X2CScope.h"
30:            #include "mc_app.h"
31:            #include "X2CScopeCommunication.h"
32:            #include <sys/attribs.h>
33:            
34:            
35:            static uint8_t  adc_interrupt_counter = 0U;
36:            uint16_t adc_result_data[2];
37:            uint8_t start_toggle = 0;
38:            uint16_t adc_dc_bus_voltage;
39:            uint16_t speed_ref_pot;
40:            uint8_t  direction = 0x0U;
41:            uint16_t calibration_sample_count = 0x0000U;
42:            uint16_t adc_0_offset = 0;
43:            uint16_t adc_1_offset = 0;
44:            
45:            uint32_t adc_0_sum = 0;
46:            uint32_t adc_1_sum = 0;
47:            
48:            button_response_t button_S2_data;
49:            button_response_t button_S3_data;
50:            void ADC_ISR(uintptr_t context);
51:            void ADC_CALIB_ISR (uintptr_t context);
52:            void OC_FAULT_ISR(uintptr_t context);
53:            void motor_start_stop(void);
54:            void motor_direction_toggle(void);
55:            void buttonRespond(button_response_t * buttonResData, void (* buttonJob)(void));
56:            
57:            
58:            
59:            // *****************************************************************************
60:            // *****************************************************************************
61:            // Section: Main Entry Point
62:            // *****************************************************************************
63:            // *****************************************************************************
64:            
65:            int main ( void )
66:            {
506C  2000B570     PUSH {R4, R5, R6, LR}
67:                /* Initialize all modules */
68:                SYS_Initialize ( NULL );
506E  4B1B2000     MOVS R0, #0
5070  47984B1B     LDR R3, $d
5072  4B1B4798     BLX R3
69:                motor_stop();
5074  47984B1B     LDR R3, [PC, #108]
5076  21004798     BLX R3
70:                ADC0_CallbackRegister((ADC_CALLBACK) ADC_CALIB_ISR, (uintptr_t)NULL);
5078  481B2100     MOVS R1, #0
507A  4B1B481B     LDR R0, [PC, #108]
507C  47984B1B     LDR R3, [PC, #108]
507E  22004798     BLX R3
71:                EIC_CallbackRegister ((EIC_PIN)EIC_PIN_2, (EIC_CALLBACK) OC_FAULT_ISR,(uintptr_t)NULL);
5080  491B2200     MOVS R2, #0
5082  2002491B     LDR R1, [PC, #108]
5084  4B1B2002     MOVS R0, #2
5086  47984B1B     LDR R3, [PC, #108]
5088  4B1B4798     BLX R3
72:                motorcontrol_vars_init();
508A  47984B1B     LDR R3, [PC, #108]
508C  4B1B4798     BLX R3
73:                ADC0_Enable();
508E  47984B1B     LDR R3, [PC, #108]
5090  4B1B4798     BLX R3
74:            
75:                X2CScope_Init();
5092  47984B1B     LDR R3, [PC, #108]
5094  4B1B4798     BLX R3
76:                TCC0_PWMStart();
5096  47984B1B     LDR R3, [PC, #108]
5098  4D1B4798     BLX R3
77:                 
78:            
79:                while ( true )
80:                {
81:                    
82:                    
83:                    /* Maintain state machines of all polled MPLAB Harmony modules. */
84:                    SYS_Tasks ( );
85:                    X2CScope_Communicate();
509A  4C1B4D1B     LDR R5, [PC, #108]
50A0  47A047A8     BLX R5
86:                    if(0U == syn10ms())
509C  4E1C4C1B     LDR R4, [PC, #108]
50A2  280047A0     BLX R4
50A4  D1FB2800     CMP R0, #0
50A6  23A0D1FB     BNE.N 0x50A0
87:                    {
88:                      
89:                        
90:                        button_S2_data.inputVal = BTN_START_STOP_Get();
509E  47A84E1C     LDR R6, [PC, #112]
50A8  228223A0     MOVS R3, #160
50AA  5D22282     MOVS R2, #130
50AC  58D305D2     LSLS R2, R2, #23
50AE  3DB58D3     LDR R3, [R2, R3]
50B0  FDB03DB     LSLS R3, R3, #15
50B2  60330FDB     LSRS R3, R3, #31
50B4  49176033     STR R3, [R6]
91:                        buttonRespond(&button_S2_data, &motor_start_stop);
50B6  304917     LDR R1, [PC, #92]
50B8  4B170030     MOVS R0, R6
50BA  47984B17     LDR R3, [PC, #92]
50BC  4B174798     BLX R3
92:            
93:                       
94:                        speed_ramp(); 
50BE  47984B17     LDR R3, [PC, #92]
50C0  4B174798     BLX R3
95:                        if(!start_toggle) // Accept direction only if motor is stopped
50C2  781B4B17     LDR R3, [PC, #92]
50C4  2B00781B     LDRB R3, [R3]
50C6  D1EA2B00     CMP R3, #0
50C8  33A0D1EA     BNE.N 0x50A0
96:                        {
97:            
98:                            button_S3_data.inputVal = BTN_DIR_TGL_Get();
50CA  228233A0     ADDS R3, #160
50CC  5D22282     MOVS R2, #130
50CE  58D305D2     LSLS R2, R2, #23
50D0  481458D3     LDR R3, [R2, R3]
50D2  FDB4814     LDR R0, [PC, #80]
50D4  60030FDB     LSRS R3, R3, #31
50D6  49136003     STR R3, [R0]
99:                            buttonRespond(&button_S3_data, &motor_direction_toggle);
50D8  4B0F4913     LDR R1, [PC, #76]
50DA  47984B0F     LDR R3, [PC, #60]
50DC  E7DF4798     BLX R3
50DE  5AC5E7DF     B.N 0x50A0
50E0  5AC5     LDRH R5, [R0, R3]
50E2  61550000     MOVS R0, R0
50E4  6155     STR R5, [R2, #20]
50E6  51C50000     MOVS R0, R0
50E8  51C5     STR R5, [R0, R7]
50EA  64ED0000     MOVS R0, R0
50EC  64ED     STR R5, [R5, #76]
50EE  61D90000     MOVS R0, R0
50F0  61D9     STR R1, [R3, #28]
50F2  62050000     MOVS R0, R0
50F4  6205     STR R5, [R0, #32]
50F6  4D450000     MOVS R0, R0
50F8  4D45     LDR R5, [PC, #276]
50FA  63910000     MOVS R0, R0
50FC  6391     STR R1, [R2, #56]
50FE  61290000     MOVS R0, R0
5100  6129     STR R1, [R5, #16]
5102  63210000     MOVS R0, R0
5104  6321     STR R1, [R4, #48]
5106  44850000     MOVS R0, R0
5108  4485     ADD SP, R0
510A  63F10000     MOVS R0, R0
510C  63F1     STR R1, [R6, #60]
510E  1940000     MOVS R0, R0
5110  20000194     LSLS R4, R2, #6
5112  64C12000     MOVS R0, #0
5114  64C1     STR R1, [R0, #76]
5116  5F650000     MOVS R0, R0
5118  5F65     LDRSH R5, [R4, R5]
511A  2BC90000     MOVS R0, R0
511C  2BC9     CMP R3, #201
511E  29470000     MOVS R0, R0
5120  20002947     CMP R1, #71
5122  18C2000     MOVS R0, #0
5124  2000018C     LSLS R4, R1, #6
5126  63752000     MOVS R0, #0
5128  6375     STR R5, [R6, #52]
512A  4B190000     MOVS R0, R0
100:           
101:                       }
102:                   }
103:           
104:                   
105:               }
106:           
107:               /* Execution should not come here during normal operation */
108:           
109:               return ( EXIT_FAILURE );
110:           }
111:           
112:           void OC_FAULT_ISR(uintptr_t context)
113:           {
61D8  4B07B510     PUSH {R4, LR}
114:               motor_stop();
61DA  47984B07     LDR R3, [PC, #28]
61DC  22084798     BLX R3
115:               motor_stop_source = OC_FAULT_STOP;
61DE  4B062208     MOVS R2, #8
61E0  701A4B06     LDR R3, [PC, #24]
61E2  2200701A     STRB R2, [R3]
116:               start_toggle=0;
61E4  4B062200     MOVS R2, #0
61E6  701A4B06     LDR R3, [PC, #24]
61E8  2180701A     STRB R2, [R3]
117:               LED1_OC_FAULT_Set();
61EA  1892180     MOVS R1, #128
61EC  23980189     LSLS R1, R1, #6
61EE  22822398     MOVS R3, #152
61F0  5D22282     MOVS R2, #130
61F2  50D105D2     LSLS R2, R2, #23
61F4  E7FE50D1     STR R1, [R2, R3]
61F6  6155E7FE     B.N 0x61F6
61F8  6155     STR R5, [R2, #20]
61FA  29430000     MOVS R0, R0
61FC  20002943     CMP R1, #67
61FE  29472000     MOVS R0, #0
6200  20002947     CMP R1, #71
6202  B5302000     MOVS R0, #0
118:               while(1);
119:               
120:           }
121:           /* This ISR calibrates zero crossing point for Phase U and Phase V currents*/
122:           void ADC_CALIB_ISR (uintptr_t context)
123:           {
51C4  4B18B510     PUSH {R4, LR}
124:               
125:               X2CScope_Update();
51C6  47984B18     LDR R3, [PC, #96]
51C8  4A184798     BLX R3
126:               calibration_sample_count++;
51CA  88134A18     LDR R2, [PC, #96]
51CC  33018813     LDRH R3, [R2]
51CE  B29B3301     ADDS R3, #1
51D0  8013B29B     UXTH R3, R3
51D2  22808013     STRH R3, [R2]
127:               if(calibration_sample_count <= 4096)
51D4  1522280     MOVS R2, #128
51D6  42930152     LSLS R2, R2, #5
51D8  D9154293     CMP R3, R2
51DA  4B14D915     BLS.N 0x5208
128:               {
129:                   adc_0_sum += ADC0_ConversionResultGet();    
5208  47984B12     LDR R3, [PC, #72]
520A  4B084798     BLX R3
520C  681A4B08     LDR R3, [PC, #32]
520E  4694681A     LDR R2, [R3]
5210  44604694     MOV R12, R2
5212  60184460     ADD R0, R12
5214  4B106018     STR R0, [R3]
130:                   adc_1_sum += ADC1_ConversionResultGet();
5216  47984B10     LDR R3, [PC, #64]
131:               }
132:               else
133:               {
134:                   adc_0_offset = adc_0_sum>>12;
51DC  681B4B14     LDR R3, [PC, #80]
51DE  B1B681B     LDR R3, [R3]
51E0  4A140B1B     LSRS R3, R3, #12
51E2  80134A14     LDR R2, [PC, #80]
51E4  4B148013     STRH R3, [R2]
135:                   adc_1_offset = adc_1_sum>>12;
51E6  681B4B14     LDR R3, [PC, #80]
51E8  B1B681B     LDR R3, [R3]
51EA  4A130B1B     LSRS R3, R3, #12
51EC  80134A13     LDR R2, [PC, #76]
51EE  4B138013     STRH R3, [R2]
136:                   ADC0_Disable();
51F0  47984B13     LDR R3, [PC, #76]
51F2  21004798     BLX R3
137:                   ADC0_CallbackRegister((ADC_CALLBACK) ADC_ISR, (uintptr_t)NULL);
51F4  48132100     MOVS R1, #0
51F6  4B134813     LDR R0, [PC, #76]
51F8  47984B13     LDR R3, [PC, #76]
51FA  4B134798     BLX R3
138:                   ADC0_Enable();
51FC  47984B13     LDR R3, [PC, #76]
51FE  22074798     BLX R3
139:           
140:               }
141:               
142:               ADC0_REGS->ADC_INTFLAG = ADC_INTFLAG_Msk;
5200  4B132207     MOVS R2, #7
5202  719A4B13     LDR R3, [PC, #76]
5204  BD10719A     STRB R2, [R3, #6]
143:               
144:               
145:           }
5206  4B12BD10     POP {R4, PC}
5208  47984B12     LDR R3, [PC, #72]
520A  4B084798     BLX R3
520C  681A4B08     LDR R3, [PC, #32]
520E  4694681A     LDR R2, [R3]
5210  44604694     MOV R12, R2
5212  60184460     ADD R0, R12
5214  4B106018     STR R0, [R3]
5216  47984B10     LDR R3, [PC, #64]
5218  4B074798     BLX R3
521A  681A4B07     LDR R3, [PC, #28]
521C  4694681A     LDR R2, [R3]
521E  44604694     MOV R12, R2
5220  60184460     ADD R0, R12
5222  E7EC6018     STR R0, [R3]
5224  46C0E7EC     B.N .LVL6
5226  449946C0     MOV R8, R8
5228  4499     ADD R9, R3
522A  29400000     MOVS R0, R0
522C  20002940     CMP R1, #64
522E  28FC2000     MOVS R0, #0
5230  200028FC     CMP R0, #252
5232  293C2000     MOVS R0, #0
5234  2000293C     CMP R1, #60
5236  29002000     MOVS R0, #0
5238  20002900     CMP R1, #0
523A  293E2000     MOVS R0, #0
523C  2000293E     CMP R1, #62
523E  63A92000     MOVS R0, #0
5240  63A9     STR R1, [R5, #56]
5242  4E150000     MOVS R0, R0
5244  4E15     LDR R6, [PC, #84]
5246  64ED0000     MOVS R0, R0
5248  64ED     STR R5, [R5, #76]
524A  63910000     MOVS R0, R0
524C  6391     STR R1, [R2, #56]
524E  44000000     MOVS R0, R0
5250  42004400     ADD R0, R0
5252  64E14200     TST R0, R0
5254  64E1     STR R1, [R4, #76]
5256  64F90000     MOVS R0, R0
5258  64F9     STR R1, [R7, #76]
525A  4A200000     MOVS R0, R0
146:           void ADC_ISR(uintptr_t context)
147:           {
4E14  4B23B510     PUSH {R4, LR}
148:              
149:               adc_result_data[0] = ADC0_ConversionResultGet();
4E16  47984B23     LDR R3, [PC, #140]
4E18  4C234798     BLX R3
4E1A  80204C23     LDR R4, [PC, #140]
4E1C  4B238020     STRH R0, [R4]
150:               adc_result_data[1] = ADC1_ConversionResultGet();
4E1E  47984B23     LDR R3, [PC, #140]
4E20  80604798     BLX R3
4E22  4B228060     STRH R0, [R4, #2]
151:               X2CScope_Update();
4E24  47984B22     LDR R3, [PC, #136]
4E26  22074798     BLX R3
152:             
153:            /* Clear all interrupt flags */
154:               ADC1_REGS->ADC_INTFLAG = ADC_INTFLAG_Msk;
4E28  4B222207     MOVS R2, #7
4E2A  719A4B22     LDR R3, [PC, #136]
4E2C  4B22719A     STRB R2, [R3, #6]
155:           	if (0U == adc_interrupt_counter)
4E2E  781B4B22     LDR R3, [PC, #136]
4E30  2B00781B     LDRB R3, [R3]
4E32  D0022B00     CMP R3, #0
4E34  2B01D002     BEQ.N 0x4E3C
156:           	{
157:               	/* select the next channel */
158:           		/* select the next ADC channel for conversion */
159:                   ADC0_ChannelSelect(ADC_POSINPUT_AIN9,ADC_NEGINPUT_GND); // DC Bus Voltage to ADC0
4E3C  16424C0     MOVS R4, #192
4E3E  210164     LSLS R4, R4, #5
4E40  20090021     MOVS R1, R4
4E42  4B1D2009     MOVS R0, #9
4E44  47984B1D     LDR R3, [PC, #116]
4E46  214798     BLX R3
160:                   ADC1_ChannelSelect(ADC_POSINPUT_AIN0,ADC_NEGINPUT_GND); // Potentiometer to ADC1
4E48  20000021     MOVS R1, R4
4E4A  4B1C2000     MOVS R0, #0
4E4C  47984B1C     LDR R3, [PC, #112]
4E4E  4B1C4798     BLX R3
161:           		current_measurement_management();
4E50  47984B1C     LDR R3, [PC, #112]
4E52  4B1C4798     BLX R3
162:           		 
163:           		/* motor control */
164:           		motorcontrol();
4E54  47984B1C     LDR R3, [PC, #112]
4E56  4A1C4798     BLX R3
165:           		 
166:           		/* store the first ADC result value */
167:           	     cur_mea[1] = ((int16_t)adc_result_data[0] - (int16_t)adc_0_offset);               
4E58  49134A1C     LDR R2, [PC, #112]
4E5A  880B4913     LDR R1, [PC, #76]
4E5C  481C880B     LDRH R3, [R1]
4E5E  8800481C     LDR R0, [PC, #112]
4E60  1A1B8800     LDRH R0, [R0]
4E62  80531A1B     SUBS R3, R3, R0
4E64  884B8053     STRH R3, [R2, #2]
168:           							
169:                    /* store the first ADC result value */
170:                    cur_mea[0] =  ((int16_t)adc_result_data[1] - (int16_t)adc_1_offset);     
4E66  491A884B     LDRH R3, [R1, #2]
4E68  8809491A     LDR R1, [PC, #104]
4E6A  1A5B8809     LDRH R1, [R1]
4E6C  80131A5B     SUBS R3, R3, R1
4E6E  22018013     STRH R3, [R2]
171:                     adc_interrupt_counter = 1;
4E70  4B112201     MOVS R2, #1
4E72  701A4B11     LDR R3, [PC, #68]
4E74  E7E0701A     STRB R2, [R3]
4E76  2200E7E0     B.N 0x4E3A
172:           	      
173:           	}
174:           	else if (1U == adc_interrupt_counter)
4E36  D01E2B01     CMP R3, #1
4E38  BD10D01E     BEQ.N 0x4E78
175:           	{
176:                                 
177:                    adc_interrupt_counter = 0;	    
4E78  4B0F2200     MOVS R2, #0
4E7A  701A4B0F     LDR R3, [PC, #60]
4E7C  4B0A701A     STRB R2, [R3]
178:                    
179:                    /* Read the ADC result value */
180:                     adc_dc_bus_voltage =  adc_result_data[0];
4E7E  88194B0A     LDR R3, [PC, #40]
4E80  4A158819     LDRH R1, [R3]
4E82  80114A15     LDR R2, [PC, #84]
4E84  885A8011     STRH R1, [R2]
181:           		  speed_ref_pot = adc_result_data[1];
4E86  4B14885A     LDRH R2, [R3, #2]
4E88  801A4B14     LDR R3, [PC, #80]
4E8A  24C0801A     STRH R2, [R3]
182:             
183:                     /* select the next ADC channel for conversion */
184:                     ADC0_ChannelSelect(ADC_POSINPUT_AIN3,ADC_NEGINPUT_GND); // Phase V to ADC0
4E8C  16424C0     MOVS R4, #192
4E8E  210164     LSLS R4, R4, #5
4E90  20030021     MOVS R1, R4
4E92  4B092003     MOVS R0, #3
4E94  47984B09     LDR R3, [PC, #36]
4E96  214798     BLX R3
185:                     ADC1_ChannelSelect(ADC_POSINPUT_AIN4,ADC_NEGINPUT_GND); // Phase U to ADC1
4E98  20040021     MOVS R1, R4
4E9A  4B082004     MOVS R0, #4
4E9C  47984B08     LDR R3, [PC, #32]
4E9E  E7CB4798     BLX R3
186:           
187:           	}
188:           	else
189:           	{
190:           		
191:                 
192:           
193:           	}
194:           
195:               return;
4EA0  46C0E7CB     B.N 0x4E3A
196:           }
4E3A  24C0BD10     POP {R4, PC}
4E3C  16424C0     MOVS R4, #192
4E3E  210164     LSLS R4, R4, #5
4E40  20090021     MOVS R1, R4
4E42  4B1D2009     MOVS R0, #9
4E44  47984B1D     LDR R3, [PC, #116]
4E46  214798     BLX R3
4E48  20000021     MOVS R1, R4
4E4A  4B1C2000     MOVS R0, #0
4E4C  47984B1C     LDR R3, [PC, #112]
4E4E  4B1C4798     BLX R3
4E50  47984B1C     LDR R3, [PC, #112]
4E52  4B1C4798     BLX R3
4E54  47984B1C     LDR R3, [PC, #112]
4E56  4A1C4798     BLX R3
4E58  49134A1C     LDR R2, [PC, #112]
4E5A  880B4913     LDR R1, [PC, #76]
4E5C  481C880B     LDRH R3, [R1]
4E5E  8800481C     LDR R0, [PC, #112]
4E60  1A1B8800     LDRH R0, [R0]
4E62  80531A1B     SUBS R3, R3, R0
4E64  884B8053     STRH R3, [R2, #2]
4E66  491A884B     LDRH R3, [R1, #2]
4E68  8809491A     LDR R1, [PC, #104]
4E6A  1A5B8809     LDRH R1, [R1]
4E6C  80131A5B     SUBS R3, R3, R1
4E6E  22018013     STRH R3, [R2]
4E70  4B112201     MOVS R2, #1
4E72  701A4B11     LDR R3, [PC, #68]
4E74  E7E0701A     STRB R2, [R3]
4E76  2200E7E0     B.N 0x4E3A
4E78  4B0F2200     MOVS R2, #0
4E7A  701A4B0F     LDR R3, [PC, #60]
4E7C  4B0A701A     STRB R2, [R3]
4E7E  88194B0A     LDR R3, [PC, #40]
4E80  4A158819     LDRH R1, [R3]
4E82  80114A15     LDR R2, [PC, #84]
4E84  885A8011     STRH R1, [R2]
4E86  4B14885A     LDRH R2, [R3, #2]
4E88  801A4B14     LDR R3, [PC, #80]
4E8A  24C0801A     STRH R2, [R3]
4E8C  16424C0     MOVS R4, #192
4E8E  210164     LSLS R4, R4, #5
4E90  20030021     MOVS R1, R4
4E92  4B092003     MOVS R0, #3
4E94  47984B09     LDR R3, [PC, #36]
4E96  214798     BLX R3
4E98  20040021     MOVS R1, R4
4E9A  4B082004     MOVS R0, #4
4E9C  47984B08     LDR R3, [PC, #32]
4E9E  E7CB4798     BLX R3
4EA0  46C0E7CB     B.N 0x4E3A
4EA2  64E146C0     MOV R8, R8
4EA4  64E1     STR R1, [R4, #76]
4EA6  1840000     MOVS R0, R0
4EA8  20000184     LSLS R4, R0, #6
4EAA  64F92000     MOVS R0, #0
4EAC  64F9     STR R1, [R7, #76]
4EAE  44990000     MOVS R0, R0
4EB0  4499     ADD R9, R3
4EB2  48000000     MOVS R0, R0
4EB4  42004800     LDR R0, [PC]
4EB6  29454200     TST R0, R0
4EB8  20002945     CMP R1, #69
4EBA  63C12000     MOVS R0, #0
4EBC  63C1     STR R1, [R0, #60]
4EBE  63D90000     MOVS R0, R0
4EC0  63D9     STR R1, [R3, #60]
4EC2  5E850000     MOVS R0, R0
4EC4  5E85     LDRSH R5, [R0, R2]
4EC6  15490000     MOVS R0, R0
4EC8  1549     ASRS R1, R1, #21
4ECA  10C0000     MOVS R0, R0
4ECC  2000010C     LSLS R4, R1, #4
4ECE  293C2000     MOVS R0, #0
4ED0  2000293C     CMP R1, #60
4ED2  293E2000     MOVS R0, #0
4ED4  2000293E     CMP R1, #62
4ED6  1882000     MOVS R0, #0
4ED8  20000188     LSLS R0, R1, #6
4EDA  18A2000     MOVS R0, #0
4EDC  2000018A     LSLS R2, R1, #6
4EDE  B5F02000     MOVS R0, #0
197:           
198:           void motor_start_stop(void)
199:           {
200:               start_toggle = !start_toggle; // Pressing Button S2 on MCLV2 start/stops the motor
64C0  78134A02     LDR R2, $d
64C2  42597813     LDRB R3, [R2]
64C4  414B4259     RSBS R3, R1, #0
64C6  7013414B     ADCS R3, R1
64C8  47707013     STRB R3, [R2]
201:           
202:           }
64CA  29474770     BX LR
64CC  20002947     CMP R1, #71
64CE  B5102000     MOVS R0, #0
203:           
204:           void motor_direction_toggle(void)
205:           {
206:               direction = !direction; // Pressing Button S3 on MCLV2 changes motor direction.
6374  78134A05     LDR R2, $d
6376  42597813     LDRB R3, [R2]
6378  414B4259     RSBS R3, R1, #0
637A  7013414B     ADCS R3, R1
637C  21807013     STRB R3, [R2]
207:               LED2_DIRECTION_Set(); 
637E  1492180     MOVS R1, #128
6380  23980149     LSLS R1, R1, #5
6382  22822398     MOVS R3, #152
6384  5D22282     MOVS R2, #130
6386  50D105D2     LSLS R2, R2, #23
6388  477050D1     STR R1, [R2, R3]
208:           }
638A  29464770     BX LR
638C  20002946     CMP R1, #70
638E  4A042000     MOVS R0, #0
209:           
210:           void buttonRespond(button_response_t * buttonResData, void (* buttonJob)(void))
211:           {
5F64  4B510     PUSH {R4, LR}
5F66  88830004     MOVS R4, R0
212:               switch(buttonResData->state){
5F68  2B008883     LDRH R3, [R0, #4]
5F6A  D0022B00     CMP R3, #0
5F6C  2B01D002     BEQ.N .LVL22
5F6E  D0092B01     CMP R3, #1
5F70  BD10D009     BEQ.N .LVL24
213:                   case 0u:  /* Detect if button is pressed. */
214:                       if(buttonResData->inputVal == 0u){
5F74  2B006803     LDR R3, [R0]
5F76  D1FB2B00     CMP R3, #0
5F78  4788D1FB     BNE.N .LVL20, .LVL21
215:                           buttonJob();
5F7A  23004788     BLX R1
216:                           buttonResData->cnt = 0u;
5F7C  80E32300     MOVS R3, #0
5F7E  330180E3     STRH R3, [R4, #6]
217:                           buttonResData->state = 1u;
5F80  80A33301     ADDS R3, #1
5F82  E7F580A3     STRH R3, [R4, #4]
5F84  88C3E7F5     B.N .LVL20, .LVL21
218:                       }
219:                       break;
220:                   case 1u:  /* Stay idle for 500ms, and then return to detect. */
221:                       buttonResData->cnt++;
5F86  330188C3     LDRH R3, [R0, #6]
5F88  B29B3301     ADDS R3, #1
5F8A  2B31B29B     UXTH R3, R3
5F98  E7EA80C3     STRH R3, [R0, #6]
222:                       if(buttonResData->cnt >= RL_500MS_10MS){
5F8C  D9032B31     CMP R3, #49
5F8E  2300D903     BLS.N 0x5F98
223:                           buttonResData->cnt = 0u;
5F90  80C32300     MOVS R3, #0
5F92  808380C3     STRH R3, [R0, #6]
224:                           buttonResData->state = 0u;
5F94  E7EC8083     STRH R3, [R0, #4]
225:                       }
226:                       break;
227:                   default:
228:                       break;
229:               }
230:           }
5F72  6803BD10     POP {R4, PC}
5F96  80C3E7EC     B.N .LVL20, .LVL21
5F98  E7EA80C3     STRH R3, [R0, #6]
5F9A  B530E7EA     B.N .LVL20, .LVL21
231:           
232:           /*******************************************************************************
233:            End of File
234:           */
235:           
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/startup_xc32.c
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
4:             *
5:             * Subject to your compliance with these terms, you may use Microchip software
6:             * and any derivatives exclusively with Microchip products. It is your
7:             * responsibility to comply with third party license terms applicable to your
8:             * use of third party software (including open source software) that may
9:             * accompany Microchip software.
10:            *
11:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:            * PARTICULAR PURPOSE.
15:            *
16:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:            *******************************************************************************/
24:            // DOM-IGNORE-END
25:            
26:            #include "definitions.h" /* for potential custom handler names */
27:            #include <libpic32c.h>
28:            #include <sys/cdefs.h>
29:            #include <stdbool.h>
30:            
31:            /*
32:             *  The MPLAB X Simulator does not yet support simulation of programming the
33:             *  GPNVM bits yet. We can remove this once it supports the FRDY bit.
34:             */
35:            #ifdef __MPLAB_DEBUGGER_SIMULATOR
36:            #define __XC32_SKIP_STARTUP_GPNVM_WAIT
37:            #endif
38:            
39:            /*
40:             *  This startup code relies on features that are specific to the MPLAB XC32
41:             *  toolchain. Do not use it with other toolchains.
42:             */
43:            #ifndef __XC32
44:            #warning This startup code is intended for use with the MPLAB XC32 Compiler only.
45:            #endif
46:            
47:            /* Initialize segments */
48:            extern uint32_t __svectors;
49:            
50:            int main(void);
51:            extern void __attribute__((long_call)) __libc_init_array(void);
52:            
53:            /* Declaration of Reset handler (may be custom) */
54:            void __attribute__((optimize("-O1"), long_call)) Reset_Handler(void);
55:            
56:            /* Device Vector information is available in interrupt.c file */
57:            
58:            /* Optional application-provided functions */
59:            extern void __attribute__((weak,long_call)) _on_reset(void);
60:            extern void __attribute__((weak,long_call)) _on_bootstrap(void);
61:            
62:            /* Reserved for use by the MPLAB XC32 Compiler */
63:            extern void __attribute__((weak,long_call)) __xc32_on_reset(void);
64:            extern void __attribute__((weak,long_call)) __xc32_on_bootstrap(void);
65:            
66:            
67:            /**
68:             * \brief This is the code that gets called on processor reset.
69:             * To initialize the device, and call the main() routine.
70:             */
71:            void __attribute__((optimize("-O1"), section(".text.Reset_Handler"), long_call)) Reset_Handler(void)
72:            {
596C  4B0EB510     PUSH {R4, LR}
73:                uint32_t *pSrc;
74:            
75:                /* Call the optional application-provided _on_reset() function. */
76:                if (_on_reset)
596E  2B004B0E     LDR R3, [PC, #56]
5970  D0002B00     CMP R3, #0
5972  4798D000     BEQ.N .LVL0
77:                {
78:                    _on_reset();
5974  4B0D4798     BLX R3
79:                }
80:            
81:                /* Reserved for use by MPLAB XC32. */
82:                if (__xc32_on_reset)
5976  2B004B0D     LDR R3, [PC, #52]
5978  D0002B00     CMP R3, #0
597A  4798D000     BEQ.N .LVL1
83:                    __xc32_on_reset();
597C  4B0C4798     BLX R3
84:            
85:            
86:            
87:                /* Initialize data after TCM is enabled.
88:                 * Data initialization from the XC32 .dinit template */
89:                __pic32c_data_initialization();
597E  47984B0C     LDR R3, [PC, #48]
5980  4A0C4798     BLX R3
90:            
91:            
92:            #  ifdef SCB_VTOR_TBLOFF_Msk
93:                /*  Set the vector-table base address in FLASH */
94:                pSrc = (uint32_t *) & __svectors;
95:                SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
5982  21FF4A0C     LDR R2, [PC, #48]
5984  4B0C21FF     MOVS R1, #255
5986  438B4B0C     LDR R3, [PC, #48]
5988  6093438B     BICS R3, R1
598A  4B0B6093     STR R3, [R2, #8]
96:            #  endif /* SCB_VTOR_TBLOFF_Msk */
97:            
98:                /* Initialize the C library */
99:                __libc_init_array();
598C  47984B0B     LDR R3, [PC, #44]
598E  4B0B4798     BLX R3
100:           
101:           
102:           
103:           
104:               /* Call the optional application-provided _on_bootstrap() function. */
105:               if (_on_bootstrap)
5990  2B004B0B     LDR R3, [PC, #44]
5992  D0002B00     CMP R3, #0
5994  4798D000     BEQ.N .LVL4
106:               {
107:                   _on_bootstrap();
5996  4B0A4798     BLX R3
108:               }
109:           
110:               /* Reserved for use by MPLAB XC32. */
111:               if (__xc32_on_bootstrap)
5998  2B004B0A     LDR R3, [PC, #40]
599A  D0002B00     CMP R3, #0
599C  4798D000     BEQ.N .LVL5
112:               {
113:                   __xc32_on_bootstrap();
599E  4B094798     BLX R3
114:               }
115:           
116:               /* Branch to application's main function */
117:               main();
59A0  47984B09     LDR R3, [PC, #36]
59A2  E7FE4798     BLX R3
59A4  46C0E7FE     B.N .LVL6
59A6  46C0     MOV R8, R8
59A8  0000     MOVS R0, R0
59AA  0000     MOVS R0, R0
59AC  0000     MOVS R0, R0
59AE  525D0000     MOVS R0, R0
59B0  525D     STRH R5, [R3, R1]
59B2  ED000000     MOVS R0, R0
59B4  E000ED00     STC P0, CR14, [R0]
59B6  E000     B.N 0x59BA
59B8  0000     MOVS R0, R0
59BA  5C850000     MOVS R0, R0
59BC  5C85     LDRB R5, [R0, R2]
59BE  0000     MOVS R0, R0
59C0  0000     MOVS R0, R0
59C2  0000     MOVS R0, R0
59C4  0000     MOVS R0, R0
59C6  506D0000     MOVS R0, R0
59C8  506D     STR R5, [R5, R1]
59CA  22010000     MOVS R0, R0
118:               /* Infinite loop */
119:               while (1) {}
120:           }
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/tcc/plib_tcc0.c
1:             /*******************************************************************************
2:               TCC Peripheral Library Interface Source File
3:             
4:               Company
5:                 Microchip Technology Inc.
6:             
7:               File Name
8:                 plib_tcc0.c
9:             
10:              Summary
11:                TCC0 peripheral library source file.
12:            
13:              Description
14:                This file implements the interface to the TCC peripheral library.  This
15:                library provides access to and control of the associated peripheral
16:                instance.
17:            
18:            *******************************************************************************/
19:            
20:            // DOM-IGNORE-BEGIN
21:            /*******************************************************************************
22:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
23:            *
24:            * Subject to your compliance with these terms, you may use Microchip software
25:            * and any derivatives exclusively with Microchip products. It is your
26:            * responsibility to comply with third party license terms applicable to your
27:            * use of third party software (including open source software) that may
28:            * accompany Microchip software.
29:            *
30:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
31:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
32:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
33:            * PARTICULAR PURPOSE.
34:            *
35:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:            *******************************************************************************/
43:            // DOM-IGNORE-END
44:            
45:            
46:            // *****************************************************************************
47:            // *****************************************************************************
48:            // Section: Included Files
49:            // *****************************************************************************
50:            // *****************************************************************************
51:            
52:            /*  This section lists the other files that are included in this file.
53:            */
54:            
55:            #include "plib_tcc0.h"
56:            
57:            
58:            
59:            /* Initialize TCC module */
60:            void TCC0_PWMInitialize(void)
61:            {
62:                /* Reset TCC */
63:                TCC0_REGS->TCC_CTRLA = TCC_CTRLA_SWRST_Msk;
590C  4B122201     MOVS R2, #1
590E  601A4B12     LDR R3, [PC, #72]
5910  19601A     STR R2, [R3]
64:                while (TCC0_REGS->TCC_SYNCBUSY & (TCC_SYNCBUSY_SWRST_Msk))
5912  688B0019     MOVS R1, R3
5914  421A688B     LDR R3, [R1, #8]
5916  D1FC421A     TST R2, R3
5918  4B0FD1FC     BNE.N 0x5914
65:                {
66:                    /* Wait for sync */
67:                }
68:                /* Clock prescaler */
69:                TCC0_REGS->TCC_CTRLA = TCC_CTRLA_PRESCALER_DIV1;
591A  22004B0F     LDR R3, [PC, #60]
591C  601A2200     MOVS R2, #0
591E  615A601A     STR R2, [R3]
70:                TCC0_REGS->TCC_WEXCTRL = TCC_WEXCTRL_OTMX(0U);
5920  6958615A     STR R2, [R3, #20]
71:                /* Dead time configurations */
72:                TCC0_REGS->TCC_WEXCTRL |= TCC_WEXCTRL_DTIEN0_Msk | TCC_WEXCTRL_DTIEN1_Msk | TCC_WEXCTRL_DTIEN2_Msk | TCC_WEXCTRL_DTIEN3_Msk
5922  490D6958     LDR R0, [R3, #20]
5924  4301490D     LDR R1, [PC, #52]
5926  61594301     ORRS R1, R0
5928  21056159     STR R1, [R3, #20]
73:             	 	 | TCC_WEXCTRL_DTLS(48U) | TCC_WEXCTRL_DTHS(48U);
74:            
75:                TCC0_REGS->TCC_WAVE = TCC_WAVE_WAVEGEN_DSBOTTOM;
592A  63D92105     MOVS R1, #5
592C  645A63D9     STR R1, [R3, #60]
76:            
77:                /* Configure duty cycle values */
78:                TCC0_REGS->TCC_CC[0] = 0U;
592E  649A645A     STR R2, [R3, #68]
79:                TCC0_REGS->TCC_CC[1] = 0U;
5930  64DA649A     STR R2, [R3, #72]
80:                TCC0_REGS->TCC_CC[2] = 0U;
5932  651A64DA     STR R2, [R3, #76]
81:                TCC0_REGS->TCC_CC[3] = 0U;
5934  4A0A651A     STR R2, [R3, #80]
82:                TCC0_REGS->TCC_PER = 2399U;
5936  641A4A0A     LDR R2, [PC, #40]
5938  4A0A641A     STR R2, [R3, #64]
83:            
84:                /* Fault configurations */
85:                TCC0_REGS->TCC_EVCTRL = TCC_EVCTRL_TCEI0_Msk | TCC_EVCTRL_EVACT0_FAULT;
593A  621A4A0A     LDR R2, [PC, #40]
593C  4A0A621A     STR R2, [R3, #32]
86:                TCC0_REGS->TCC_DRVCTRL = TCC_DRVCTRL_FILTERVAL0(5U) | TCC_DRVCTRL_NRE0_Msk
593E  619A4A0A     LDR R2, [PC, #40]
5940  6A19619A     STR R2, [R3, #24]
87:            		 | TCC_DRVCTRL_NRE1_Msk
88:            		 | TCC_DRVCTRL_NRE2_Msk
89:            		 | TCC_DRVCTRL_NRE4_Msk
90:            		 | TCC_DRVCTRL_NRE5_Msk
91:            		 | TCC_DRVCTRL_NRE6_Msk;
92:            
93:            
94:            
95:                TCC0_REGS->TCC_EVCTRL |= TCC_EVCTRL_OVFEO_Msk;
5942  22806A19     LDR R1, [R3, #32]
5944  522280     MOVS R2, #128
5946  430A0052     LSLS R2, R2, #1
5948  621A430A     ORRS R2, R1
594A  1A621A     STR R2, [R3, #32]
96:                while (TCC0_REGS->TCC_SYNCBUSY)
594C  6893001A     MOVS R2, R3
594E  2B006893     LDR R3, [R2, #8]
5950  D1FC2B00     CMP R3, #0
5952  4770D1FC     BNE.N 0x594E
97:                {
98:                    /* Wait for sync */
99:                }
100:           }
5954  46C04770     BX LR
5956  240046C0     MOV R8, R8
5958  42002400     MOVS R4, #0
595A  F004200     TST R0, R0
595C  30300F00     LSRS R0, R0, #28
595E  95F3030     ADDS R0, #48
5960  095F     LSRS R7, R3, #5
5962  40070000     MOVS R0, R0
5964  4007     ANDS R7, R0
5966  770000     MOVS R0, R0
5968  5000077     LSLS R7, R6, #1
596A  B5100500     LSLS R0, R0, #20
101:           
102:           
103:           /* Start the PWM generation */
104:           void TCC0_PWMStart(void)
105:           {
106:               TCC0_REGS->TCC_CTRLA |= TCC_CTRLA_ENABLE_Msk;
6320  68134A05     LDR R2, $d
6322  21026813     LDR R3, [R2]
6324  430B2102     MOVS R1, #2
6326  6013430B     ORRS R3, R1
6328  116013     STR R3, [R2]
107:               while (TCC0_REGS->TCC_SYNCBUSY & (TCC_SYNCBUSY_ENABLE_Msk))
632A  22020011     MOVS R1, R2
632C  688B2202     MOVS R2, #2
632E  421A688B     LDR R3, [R1, #8]
6330  D1FC421A     TST R2, R3
6332  4770D1FC     BNE.N 0x632E
108:               {
109:                   /* Wait for sync */
110:               }
111:           }
6334  46C04770     BX LR
6336  240046C0     MOV R8, R8
6338  42002400     MOVS R4, #0
633A  B5004200     TST R0, R0
112:           
113:           /* Stop the PWM generation */
114:           void TCC0_PWMStop (void)
115:           {
116:               TCC0_REGS->TCC_CTRLA &= ~TCC_CTRLA_ENABLE_Msk;
0000  20007FF8     LDRB R0, [R7, #31]
117:               while (TCC0_REGS->TCC_SYNCBUSY & (TCC_SYNCBUSY_ENABLE_Msk))
000A  653F0000     MOVS R0, R0
000E  0000     MOVS R0, R0
118:               {
119:                   /* Wait for sync */
120:               }
121:           }
0014  0000     MOVS R0, R0
122:           
123:           /* Configure PWM period */
124:           void TCC0_PWM24bitPeriodSet (uint32_t period)
125:           {
126:               TCC0_REGS->TCC_PERBUF = period & 0xFFFFFF;
0000  20007FF8     LDRB R0, [R7, #31]
127:           }
0008  653D     STR R5, [R7, #80]
128:           
129:           /* Read TCC period */
130:           uint32_t TCC0_PWM24bitPeriodGet (void)
131:           {
132:               while (TCC0_REGS->TCC_SYNCBUSY & (TCC_SYNCBUSY_PER_Msk))
0000  20007FF8     LDRB R0, [R7, #31]
0004  596D     LDR R5, [R5, R5]
133:               {
134:                   /* Wait for sync */
135:               }
136:               return (TCC0_REGS->TCC_PER & 0xFFFFFF);
000A  653F0000     MOVS R0, R0
137:           }
0012  0000     MOVS R0, R0
138:           
139:           /* Configure dead time */
140:           void TCC0_PWMDeadTimeSet (uint8_t deadtime_high, uint8_t deadtime_low)
141:           {
142:               TCC0_REGS->TCC_WEXCTRL &= ~(TCC_WEXCTRL_DTHS_Msk | TCC_WEXCTRL_DTLS_Msk);
0000  20007FF8     LDRB R0, [R7, #31]
143:               TCC0_REGS->TCC_WEXCTRL |= TCC_WEXCTRL_DTHS(deadtime_high) | TCC_WEXCTRL_DTLS(deadtime_low);
000A  653F0000     MOVS R0, R0
144:           }
0016  0000     MOVS R0, R0
145:           
146:           void TCC0_PWMPatternSet(uint8_t pattern_enable, uint8_t pattern_output)
147:           {
148:               TCC0_REGS->TCC_PATTBUF = (uint16_t)(pattern_enable | (pattern_output << 8));
0000  20007FF8     LDRB R0, [R7, #31]
149:           }
000A  653F0000     MOVS R0, R0
150:           
151:           /* Set the counter*/
152:           void TCC0_PWM24bitCounterSet (uint32_t count_value)
153:           {
154:               TCC0_REGS->TCC_COUNT = count_value & 0xFFFFFF;
0000  20007FF8     LDRB R0, [R7, #31]
155:               while (TCC0_REGS->TCC_SYNCBUSY & (TCC_SYNCBUSY_COUNT_Msk))
0008  653D     STR R5, [R7, #80]
000C  653F     STR R7, [R7, #80]
156:               {
157:                   /* Wait for sync */
158:               }
159:           }
0012  0000     MOVS R0, R0
160:           
161:           /* Enable forced synchronous update */
162:           void TCC0_PWMForceUpdate(void)
163:           {
164:               TCC0_REGS->TCC_CTRLBSET |= TCC_CTRLBCLR_CMD_UPDATE;
0000  20007FF8     LDRB R0, [R7, #31]
165:               while (TCC0_REGS->TCC_SYNCBUSY & (TCC_SYNCBUSY_CTRLB_Msk))
000A  653F0000     MOVS R0, R0
000E  0000     MOVS R0, R0
166:               {
167:                   /* Wait for sync */
168:               }
169:           }
0014  0000     MOVS R0, R0
170:           
171:           /* Enable the period interrupt - overflow or underflow interrupt */
172:           void TCC0_PWMPeriodInterruptEnable(void)
173:           {
174:               TCC0_REGS->TCC_INTENSET = TCC_INTENSET_OVF_Msk;
0000  20007FF8     LDRB R0, [R7, #31]
175:           }
0006  653D0000     MOVS R0, R0
176:           
177:           /* Disable the period interrupt - overflow or underflow interrupt */
178:           void TCC0_PWMPeriodInterruptDisable(void)
179:           {
180:               TCC0_REGS->TCC_INTENCLR = TCC_INTENCLR_OVF_Msk;
0000  20007FF8     LDRB R0, [R7, #31]
181:           }
0006  653D0000     MOVS R0, R0
182:           
183:           /* Read interrupt flags */
184:           uint32_t TCC0_PWMInterruptStatusGet(void)
185:           {
186:               uint32_t interrupt_status;
187:               interrupt_status = TCC0_REGS->TCC_INTFLAG;
0000  20007FF8     LDRB R0, [R7, #31]
188:               /* Clear interrupt flags */
189:               TCC0_REGS->TCC_INTFLAG = TCC_INTFLAG_Msk;
0004  596D     LDR R5, [R5, R5]
190:               return interrupt_status;
191:           }
0008  653D     STR R5, [R7, #80]
192:           
193:           
194:           /**
195:            End of File
196:           */
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/sercom/usart/plib_sercom3_usart.c
1:             /*******************************************************************************
2:               SERCOM Universal Synchronous/Asynchrnous Receiver/Transmitter PLIB
3:             
4:               Company
5:                 Microchip Technology Inc.
6:             
7:               File Name
8:                 plib_sercom3_usart.c
9:             
10:              Summary
11:                USART peripheral library interface.
12:            
13:              Description
14:                This file defines the interface to the USART peripheral library. This
15:                library provides access to and control of the associated peripheral
16:                instance.
17:            
18:              Remarks:
19:                None.
20:            *******************************************************************************/
21:            
22:            /*******************************************************************************
23:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
24:            *
25:            * Subject to your compliance with these terms, you may use Microchip software
26:            * and any derivatives exclusively with Microchip products. It is your
27:            * responsibility to comply with third party license terms applicable to your
28:            * use of third party software (including open source software) that may
29:            * accompany Microchip software.
30:            *
31:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
32:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
33:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
34:            * PARTICULAR PURPOSE.
35:            *
36:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:            *******************************************************************************/
44:            
45:            // *****************************************************************************
46:            // *****************************************************************************
47:            // Section: Included Files
48:            // *****************************************************************************
49:            // *****************************************************************************
50:            
51:            #include "plib_sercom3_usart.h"
52:            
53:            // *****************************************************************************
54:            // *****************************************************************************
55:            // Section: Global Data
56:            // *****************************************************************************
57:            // *****************************************************************************
58:            
59:            /* SERCOM3 USART baud value for 115200 Hz baud rate */
60:            #define SERCOM3_USART_INT_BAUD_VALUE			(63019U)
61:            
62:            
63:            // *****************************************************************************
64:            // *****************************************************************************
65:            // Section: SERCOM3 USART Interface Routines
66:            // *****************************************************************************
67:            // *****************************************************************************
68:            
69:            void SERCOM3_USART_Initialize( void )
70:            {
71:                /*
72:                 * Configures USART Clock Mode
73:                 * Configures TXPO and RXPO
74:                 * Configures Data Order
75:                 * Configures Standby Mode
76:                 * Configures sampling rate
77:                 * Configures IBON
78:                 * Configures Parity
79:                 * Configures Stop bits
80:                 */
81:                SERCOM3_REGS->USART_INT.SERCOM_CTRLA = SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK | SERCOM_USART_INT_CTRLA_RXPO_PAD1 | SERCOM_USART_INT_CTRLA_TXPO_PAD0 | SERCOM_USART_INT_CTRLA_DORD_Msk | SERCOM_USART_INT_CTRLA_IBON_Msk | SERCOM_USART_INT_CTRLA_FORM(0x0) | SERCOM_USART_INT_CTRLA_SAMPR(0) ;
5E4C  4A0B4B0A     LDR R3, $d
5E4E  601A4A0B     LDR R2, [PC, #44]
5E50  4A0B601A     STR R2, [R3]
82:            
83:                /* Configure Baud Rate */
84:                SERCOM3_REGS->USART_INT.SERCOM_BAUD = SERCOM_USART_INT_BAUD_BAUD(SERCOM3_USART_INT_BAUD_VALUE);
5E52  819A4A0B     LDR R2, [PC, #44]
5E54  22C0819A     STRH R2, [R3, #12]
85:            
86:                /*
87:                 * Configures RXEN
88:                 * Configures TXEN
89:                 * Configures CHSIZE
90:                 * Configures Parity
91:                 * Configures Stop bits
92:                 */
93:                SERCOM3_REGS->USART_INT.SERCOM_CTRLB = SERCOM_USART_INT_CTRLB_CHSIZE_8_BIT | SERCOM_USART_INT_CTRLB_SBMODE_1_BIT | SERCOM_USART_INT_CTRLB_RXEN_Msk | SERCOM_USART_INT_CTRLB_TXEN_Msk;
5E56  29222C0     MOVS R2, #192
5E58  605A0292     LSLS R2, R2, #10
5E5A  1A605A     STR R2, [R3, #4]
94:            
95:                /* Wait for sync */
96:                while(SERCOM3_REGS->USART_INT.SERCOM_SYNCBUSY);
5E5C  69D3001A     MOVS R2, R3
5E5E  2B0069D3     LDR R3, [R2, #28]
5E60  D1FC2B00     CMP R3, #0
5E62  4A04D1FC     BNE.N 0x5E5E
97:            
98:                /* Enable the UART after the configurations */
99:                SERCOM3_REGS->USART_INT.SERCOM_CTRLA |= SERCOM_USART_INT_CTRLA_ENABLE_Msk;
5E64  68134A04     LDR R2, $d
5E66  21026813     LDR R3, [R2]
5E68  430B2102     MOVS R1, #2
5E6A  6013430B     ORRS R3, R1
5E6C  69D36013     STR R3, [R2]
100:           
101:               /* Wait for sync */
102:               while(SERCOM3_REGS->USART_INT.SERCOM_SYNCBUSY);
5E6E  2B0069D3     LDR R3, [R2, #28]
5E70  D1FC2B00     CMP R3, #0
5E72  4770D1FC     BNE.N 0x5E6E
103:           }
5E74  46C04770     BX LR
5E76  100046C0     MOV R8, R8
5E78  42001000     MOVS R0, R0
5E7A  1044200     TST R0, R0
5E7C  40100104     LSLS R4, R0, #4
5E7E  F62B4010     ANDS R0, R2
5E80  FFFFF62B     BL 0x1E31E82
5E82  B510FFFF     MRC2 P5, #7, R11, CR15, CR0, {0}
104:           
105:           uint32_t SERCOM3_USART_FrequencyGet( void )
106:           {
107:               return (uint32_t) (48000000UL);
108:           }
109:           
110:           bool SERCOM3_USART_SerialSetup( USART_SERIAL_SETUP * serialSetup, uint32_t clkFrequency )
111:           {
0000  20007FF8     LDRB R0, [R7, #31]
112:               bool setupStatus       = false;
00EE  6514013     ANDS R3, R2
113:               uint32_t baudValue     = 0;
114:               uint32_t sampleRate    = 0;
115:           
116:               if((serialSetup != NULL) & (serialSetup->baudRate != 0))
0006  653D0000     MOVS R0, R0
117:               {
118:                   if(clkFrequency == 0)
0018  0000     MOVS R0, R0
119:                   {
120:                       clkFrequency = SERCOM3_USART_FrequencyGet();
001C  0000     MOVS R0, R0
121:                   }
122:           
123:                   if(clkFrequency >= (16 * serialSetup->baudRate))
001E  0000     MOVS R0, R0
124:                   {
125:                       baudValue = 65536 - ((uint64_t)65536 * 16 * serialSetup->baudRate) / clkFrequency;
0024  0000     MOVS R0, R0
126:                       sampleRate = 0;
0036  54FB0000     MOVS R0, R0
127:                   }
128:                   else if(clkFrequency >= (8 * serialSetup->baudRate))
0094  54FB     STRB R3, [R7, R3]
129:                   {
130:                       baudValue = 65536 - ((uint64_t)65536 * 8 * serialSetup->baudRate) / clkFrequency;
009A  54FB0000     MOVS R0, R0
131:                       sampleRate = 2;
00AC  54FB     STRB R3, [R7, R3]
132:                   }
133:                   else if(clkFrequency >= (3 * serialSetup->baudRate))
00B0  54FB     STRB R3, [R7, R3]
134:                   {
135:                       baudValue = 65536 - ((uint64_t)65536 * 3 * serialSetup->baudRate) / clkFrequency;
00B8  54FB     STRB R3, [R7, R3]
136:                       sampleRate = 4;
00D2  BCF846C0     MOV R8, R8
137:                   }
138:           
139:                   if(baudValue != 0)
0038  54FB     STRB R3, [R7, R3]
140:                   {
141:                       /* Disable the USART before configurations */
142:                       SERCOM3_REGS->USART_INT.SERCOM_CTRLA &= ~SERCOM_USART_INT_CTRLA_ENABLE_Msk;
003C  54FB     STRB R3, [R7, R3]
143:           
144:                       /* Wait for sync */
145:                       while(SERCOM3_REGS->USART_INT.SERCOM_SYNCBUSY);
0046  54FB0000     MOVS R0, R0
146:           
147:                       /* Configure Baud Rate */
148:                       SERCOM3_REGS->USART_INT.SERCOM_BAUD = SERCOM_USART_INT_BAUD_BAUD(baudValue);
004C  5BF5     LDRH R5, [R6, R7]
149:           
150:                       /* Configure Parity Options */
151:                       if(serialSetup->parity == USART_PARITY_NONE)
0052  54FB0000     MOVS R0, R0
152:                       {
153:                           SERCOM3_REGS->USART_INT.SERCOM_CTRLA |= SERCOM_USART_INT_CTRLA_FORM(0x0) | SERCOM_USART_INT_CTRLA_SAMPR(sampleRate);
00D6  469EBC08     POP {R3}
154:           
155:                           SERCOM3_REGS->USART_INT.SERCOM_CTRLB |= serialSetup->dataWidth | serialSetup->stopBits;
00E0  B085B5F0     PUSH {R4, R5, R6, R7, LR}
00E2  9202B085     SUB SP, #20
00E4  93039202     STR R2, [SP, #8]
00E6  234C9303     STR R3, [SP, #12]
00E8  5CC2234C     MOVS R3, #76
00EA  3B3D5CC2     LDRB R2, [R0, R3]
00EC  40133B3D     SUBS R3, #61
00EE  6514013     ANDS R3, R2
156:                       }
157:                       else
158:                       {
159:                           SERCOM3_REGS->USART_INT.SERCOM_CTRLA |= SERCOM_USART_INT_CTRLA_FORM(0x1) | SERCOM_USART_INT_CTRLA_SAMPR(sampleRate);
0058  54FB     STRB R3, [R7, R3]
160:           
161:                           SERCOM3_REGS->USART_INT.SERCOM_CTRLB |= serialSetup->dataWidth | serialSetup->parity | serialSetup->stopBits;
0068  54FB     STRB R3, [R7, R3]
162:                       }
163:           
164:                       /* Wait for sync */
165:                       while(SERCOM3_REGS->USART_INT.SERCOM_SYNCBUSY);
0078  54FB     STRB R3, [R7, R3]
166:           
167:                       /* Enable the USART after the configurations */
168:                       SERCOM3_REGS->USART_INT.SERCOM_CTRLA |= SERCOM_USART_INT_CTRLA_ENABLE_Msk;
0080  54FB     STRB R3, [R7, R3]
169:           
170:                       /* Wait for sync */
171:                       while(SERCOM3_REGS->USART_INT.SERCOM_SYNCBUSY);
008A  54FB0000     MOVS R0, R0
172:           
173:                       setupStatus = true;
174:                   }
175:               }
176:           
177:               return setupStatus;
178:           }
0090  54FB     STRB R3, [R7, R3]
179:           
180:           bool SERCOM3_USART_Write( void *buffer, const size_t size )
181:           {
5F9C  2800B530     PUSH {R4, R5, LR}
182:               bool writeStatus      = false;
5FC2  E7FC2000     MOVS R0, #0
5FC4  2001E7FC     B.N .LVL34
183:               uint8_t *pu8Data      = (uint8_t*)buffer;
184:               uint32_t u32Length    = size;
185:           
186:               if(pu8Data != NULL)
5F9E  D00F2800     CMP R0, #0
5FA0  2900D00F     BEQ.N .LVL35
187:               {
188:                   /* Blocks while buffer is being transferred */
189:                   while(u32Length--)
5FA2  D00F2900     CMP R1, #0
5FA4  5D00F     BEQ.N .LVL37
5FA6  18410005     MOVS R5, R0
5FA8  4A081841     ADDS R1, R0, R1
5FBA  D1F742A9     CMP R1, R5
5FBC  2001D1F7     BNE.N .LVL30
190:                   {
191:                       /* Check if USART is ready for new data */
192:                       while((SERCOM3_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) != SERCOM_USART_INT_INTFLAG_DRE_Msk);
5FAA  24014A08     LDR R2, [PC, #32]
5FAC  7E132401     MOVS R4, #1
5FAE  42237E13     LDRB R3, [R2, #24]
5FB0  D0FC4223     TST R3, R4
5FB2  782BD0FC     BEQ.N .LVL30
193:           
194:                       /* Write data to USART module */
195:                       SERCOM3_REGS->USART_INT.SERCOM_DATA = *pu8Data++;
5FB4  8513782B     LDRB R3, [R5]
5FB6  35018513     STRH R3, [R2, #40]
5FB8  42A93501     ADDS R5, #1
196:                   }
197:           
198:                   writeStatus = true;
5FBE  BD302001     MOVS R0, #1
5FC6  E7FA2001     MOVS R0, #1
199:               }
200:           
201:               return writeStatus;
202:           }
5FC0  2000BD30     POP {R4, R5, PC}
5FC2  E7FC2000     MOVS R0, #0
5FC4  2001E7FC     B.N .LVL34
5FC6  E7FA2001     MOVS R0, #1
5FC8  46C0E7FA     B.N .LVL34
5FCA  100046C0     MOV R8, R8
5FCC  42001000     MOVS R0, R0
5FCE  23804200     TST R0, R0
203:           
204:           bool SERCOM3_USART_TransmitterIsReady( void )
205:           {
206:               bool transmitterStatus = false;
207:           
208:               if((SERCOM3_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk)
64A0  7E184B02     LDR R3, $d
64A2  23017E18     LDRB R0, [R3, #24]
209:               {
210:                   transmitterStatus = true;
211:               }
212:           
213:               return transmitterStatus;
64A4  40182301     MOVS R3, #1
64A6  47704018     ANDS R0, R3
214:           }
64A8  46C04770     BX LR
64AA  100046C0     MOV R8, R8
64AC  42001000     MOVS R0, R0
64AE  4B024200     TST R0, R0
215:           
216:           void SERCOM3_USART_WriteByte( int data )
217:           {
218:               /* Check if USART is ready for new data */
219:               while((SERCOM3_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) != SERCOM_USART_INT_INTFLAG_DRE_Msk);
0000  20007FF8     LDRB R0, [R7, #31]
0004  596D     LDR R5, [R5, R5]
220:           
221:               SERCOM3_REGS->USART_INT.SERCOM_DATA = data;
000A  653F0000     MOVS R0, R0
222:           }
0010  0000     MOVS R0, R0
223:           
224:           bool SERCOM3_USART_Read( void *buffer, const size_t size )
225:           {
5678  46CEB5F8     PUSH {R3, R4, R5, R6, R7, LR}
567A  464746CE     MOV LR, R9
567C  B5804647     MOV R7, R8
567E  4680B580     PUSH {R7, LR}
5680  F4680     MOV R8, R0
5682  2800000F     MOVS R7, R1
56AC  4C0E2600     MOVS R6, #0
226:               bool readStatus        = false;
56DE  E7F92000     MOVS R0, #0
227:               uint8_t *pu8Data       = (uint8_t*)buffer;
228:               uint8_t u8dummyData    = 0;
229:               uint32_t u32Length     = size;
230:               uint32_t processedSize = 0;
231:           
232:               if(pu8Data != NULL)
5684  D02A2800     CMP R0, #0
5686  4B16D02A     BEQ.N .LVL63
233:               {
234:                   /* Checks for error before receiving */
235:                   if(SERCOM3_USART_ErrorGet() != USART_ERROR_NONE)
5688  47984B16     LDR R3, $d
568A  28004798     BLX R3
568C  D00D2800     CMP R0, #0
568E  4B15D00D     BEQ.N 0x56AC
236:                   {
237:                       /* Clear all error flags */
238:                       SERCOM3_REGS->USART_INT.SERCOM_INTFLAG = SERCOM_USART_INT_INTFLAG_ERROR_Msk;
5690  22804B15     LDR R3, [PC, #84]
5692  761A2280     MOVS R2, #128
5694  3A01761A     STRB R2, [R3, #24]
239:           
240:                       /* Clear error statuses */
241:                       SERCOM3_REGS->USART_INT.SERCOM_STATUS = SERCOM_USART_INT_STATUS_Msk;
5696  835A3A01     SUBS R2, #1
5698  7E1B835A     STRH R2, [R3, #26]
242:           
243:                       /* Flush existing error bytes from the RX FIFO */
244:                       while((SERCOM3_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
569A  75B7E1B     LDRB R3, [R3, #24]
569C  D505075B     LSLS R3, R3, #29
569E  4B11D505     BPL.N 0x56AC
56A2  8D1A2104     MOVS R1, #4
56A6  420A7E1A     LDRB R2, [R3, #24]
56A8  D1FB420A     TST R2, R1
56AA  2600D1FB     BNE.N .LVL53
245:                       {
246:                           u8dummyData = SERCOM3_REGS->USART_INT.SERCOM_DATA;
56A0  21044B11     LDR R3, [PC, #68]
56A4  7E1A8D1A     LDRH R2, [R3, #40]
247:                       }
248:           
249:                       /* Ignore the warning */
250:                       (void)u8dummyData;
251:                   }
252:           
253:                   while(u32Length--)
56B6  D00942BE     CMP R6, R7
56B8  7E23D009     BEQ.N .LVL58
254:                   {
255:                       /* Check if USART has new data */
256:                       while((SERCOM3_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) != SERCOM_USART_INT_INTFLAG_RXC_Msk);
56AE  25044C0E     LDR R4, [PC, #56]
56B0  4B0C2504     MOVS R5, #4
56BA  422B7E23     LDRB R3, [R4, #24]
56BC  D0FC422B     TST R3, R5
56BE  8D23D0FC     BEQ.N 0x56BA
257:           
258:                       /* Read data from USART module */
259:                       *pu8Data++ = SERCOM3_REGS->USART_INT.SERCOM_DATA;
56C0  46428D23     LDRH R3, [R4, #40]
56C2  55934642     MOV R2, R8
56C4  36015593     STRB R3, [R2, R6]
260:                       processedSize++;
56C6  47C83601     ADDS R6, #1
261:           
262:                       if(SERCOM3_USART_ErrorGet() != USART_ERROR_NONE)
56B2  46994B0C     LDR R3, [PC, #48]
56B4  42BE4699     MOV R9, R3
56C8  280047C8     BLX R9
56CA  D0F32800     CMP R0, #0
56CC  1BF6D0F3     BEQ.N .LVL54
263:                       {
264:                           break;
265:                       }
266:                   }
267:           
268:                   if(size == processedSize)
56CE  42701BF6     SUBS R6, R6, R7
56D0  41704270     RSBS R6, R0, #0
56D2  B2C04170     ADCS R0, R6
56D4  BC0CB2C0     UXTB R0, R0
269:                   {
270:                       readStatus = true;
271:                   }
272:               }
273:           
274:               return readStatus;
275:           }
56D6  4690BC0C     POP {R2, R3}
56D8  46994690     MOV R8, R2
56DA  BDF84699     MOV R9, R3
56DC  2000BDF8     POP {R3, R4, R5, R6, R7, PC}
56DE  E7F92000     MOVS R0, #0
56E0  46C0E7F9     B.N .LVL60, .LVL61, .LVL62
56E2  645146C0     MOV R8, R8
56E4  6451     STR R1, [R2, #68]
56E6  10000000     MOVS R0, R0
56E8  42001000     MOVS R0, R0
56EA  46844200     TST R0, R0
276:           
277:           bool SERCOM3_USART_ReceiverIsReady( void )
278:           {
279:               bool receiverStatus = false;
280:           
281:               if((SERCOM3_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
64B0  7E184B02     LDR R3, $d
64B2  7407E18     LDRB R0, [R3, #24]
64B4  FC00740     LSLS R0, R0, #29
282:               {
283:                   receiverStatus = true;
284:               }
285:           
286:               return receiverStatus;
64B6  47700FC0     LSRS R0, R0, #31
287:           }
64B8  46C04770     BX LR
64BA  100046C0     MOV R8, R8
64BC  42001000     MOVS R0, R0
64BE  4A024200     TST R0, R0
288:           
289:           int SERCOM3_USART_ReadByte( void )
290:           {
291:               return SERCOM3_REGS->USART_INT.SERCOM_DATA;
0000  20007FF8     LDRB R0, [R7, #31]
292:           }
0006  653D0000     MOVS R0, R0
293:           
294:           USART_ERROR SERCOM3_USART_ErrorGet( void )
295:           {
296:               USART_ERROR errorStatus = USART_ERROR_NONE;
297:           
298:               errorStatus = SERCOM3_REGS->USART_INT.SERCOM_STATUS & (SERCOM_USART_INT_STATUS_PERR_Msk | SERCOM_USART_INT_STATUS_FERR_Msk | SERCOM_USART_INT_STATUS_BUFOVF_Msk);
6450  8B584B03     LDR R3, $d
6452  22078B58     LDRH R0, [R3, #26]
299:           
300:               /* Clear Errors */
301:               SERCOM3_REGS->USART_INT.SERCOM_STATUS = SERCOM_USART_INT_STATUS_PERR_Msk | SERCOM_USART_INT_STATUS_FERR_Msk | SERCOM_USART_INT_STATUS_BUFOVF_Msk;
6454  835A2207     MOVS R2, #7
6456  2307835A     STRH R2, [R3, #26]
302:           
303:               return errorStatus;
6458  40182307     MOVS R3, #7
645A  47704018     ANDS R0, R3
304:           }
645C  46C04770     BX LR
645E  100046C0     MOV R8, R8
6460  42001000     MOVS R0, R0
6462  2DB04200     TST R0, R0
305:           
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/port/plib_port.c
1:             /*******************************************************************************
2:               PORT PLIB
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 plib_port.c
9:             
10:              Summary:
11:                Interface definition of PORT PLIB
12:            
13:              Description:
14:                This file provides an interface to control and interact with PORT-I/O
15:                Pin controller module.
16:            
17:            *******************************************************************************/
18:            
19:            /*******************************************************************************
20:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
21:            *
22:            * Subject to your compliance with these terms, you may use Microchip software
23:            * and any derivatives exclusively with Microchip products. It is your
24:            * responsibility to comply with third party license terms applicable to your
25:            * use of third party software (including open source software) that may
26:            * accompany Microchip software.
27:            *
28:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:            * PARTICULAR PURPOSE.
32:            *
33:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:            *******************************************************************************/
41:            
42:            // *****************************************************************************
43:            // *****************************************************************************
44:            // Section: Included Files
45:            // *****************************************************************************
46:            // *****************************************************************************
47:            
48:            #include "plib_port.h"
49:            
50:            // *****************************************************************************
51:            // *****************************************************************************
52:            // Section: PORT Implementation
53:            // *****************************************************************************
54:            // *****************************************************************************
55:            
56:            // *****************************************************************************
57:            /* Function:
58:            
59:                void PORT_Initialize(void)
60:            
61:              Summary:
62:                Initializes the PORT Library.
63:            
64:              Description:
65:                This function initializes all ports and pins as configured in the
66:                MHC Pin Manager.
67:            
68:              Remarks:
69:                Refer plib_port.h file for more information.
70:            */
71:            
72:            void PORT_Initialize(void)
73:            {
5478  2382B510     PUSH {R4, LR}
74:               /************************** GROUP 0 Initialization *************************/
75:               PORT_REGS->GROUP[0].PORT_PINCFG[5] = 0x1;
547A  5DB2382     MOVS R3, #130
547C  220105DB     LSLS R3, R3, #23
547E  21452201     MOVS R2, #1
5480  545A2145     MOVS R1, #69
5482  3104545A     STRB R2, [R3, R1]
76:               PORT_REGS->GROUP[0].PORT_PINCFG[9] = 0x1;
5484  545A3104     ADDS R1, #4
5486  3101545A     STRB R2, [R3, R1]
77:               PORT_REGS->GROUP[0].PORT_PINCFG[10] = 0x1;
5488  545A3101     ADDS R1, #1
548A  3104545A     STRB R2, [R3, R1]
78:               PORT_REGS->GROUP[0].PORT_PINCFG[14] = 0x1;
548C  545A3104     ADDS R1, #4
548E  3101545A     STRB R2, [R3, R1]
79:               PORT_REGS->GROUP[0].PORT_PINCFG[15] = 0x1;
5490  545A3101     ADDS R1, #1
5492  3101545A     STRB R2, [R3, R1]
80:               PORT_REGS->GROUP[0].PORT_PINCFG[16] = 0x1;
5494  545A3101     ADDS R1, #1
5496  3102545A     STRB R2, [R3, R1]
81:               PORT_REGS->GROUP[0].PORT_PINCFG[18] = 0x1;
5498  545A3102     ADDS R1, #2
549A  3104545A     STRB R2, [R3, R1]
82:               PORT_REGS->GROUP[0].PORT_PINCFG[22] = 0x1;
549C  545A3104     ADDS R1, #4
549E  3101545A     STRB R2, [R3, R1]
83:               PORT_REGS->GROUP[0].PORT_PINCFG[23] = 0x1;
54A0  545A3101     ADDS R1, #1
54A2  2040545A     STRB R2, [R3, R1]
84:            
85:               PORT_REGS->GROUP[0].PORT_PMUX[2] = 0x40;
54A4  39252040     MOVS R0, #64
54A6  54583925     SUBS R1, #37
54A8  38305458     STRB R0, [R3, R1]
86:               PORT_REGS->GROUP[0].PORT_PMUX[4] = 0x10;
54AA  31023830     SUBS R0, #48
54AC  54583102     ADDS R1, #2
54AE  392F5458     STRB R0, [R3, R1]
87:               PORT_REGS->GROUP[0].PORT_PMUX[5] = 0x5;
54B0  3025392F     SUBS R1, #47
54B2  54193025     ADDS R0, #37
54B4  24555419     STRB R1, [R3, R0]
88:               PORT_REGS->GROUP[0].PORT_PMUX[7] = 0x55;
54B6  30022455     MOVS R4, #85
54B8  541C3002     ADDS R0, #2
54BA  3001541C     STRB R4, [R3, R0]
89:               PORT_REGS->GROUP[0].PORT_PMUX[8] = 0x5;
54BC  54193001     ADDS R0, #1
54BE  38165419     STRB R1, [R3, R0]
90:               PORT_REGS->GROUP[0].PORT_PMUX[11] = 0x22;
54C0  31363816     SUBS R0, #22
54C2  54583136     ADDS R1, #54
54C4  20C05458     STRB R0, [R3, R1]
91:               /************************** GROUP 1 Initialization *************************/
92:               PORT_REGS->GROUP[1].PORT_DIR = 0x3000;
54C6  18020C0     MOVS R0, #192
54C8  31450180     LSLS R0, R0, #6
54CA  50583145     ADDS R1, #69
54CC  31405058     STR R0, [R3, R1]
93:               PORT_REGS->GROUP[1].PORT_PINCFG[0] = 0x1;
54CE  545A3140     ADDS R1, #64
54D0  3108545A     STRB R2, [R3, R1]
94:               PORT_REGS->GROUP[1].PORT_PINCFG[8] = 0x1;
54D2  545A3108     ADDS R1, #8
54D4  3101545A     STRB R2, [R3, R1]
95:               PORT_REGS->GROUP[1].PORT_PINCFG[9] = 0x1;
54D6  545A3101     ADDS R1, #1
54D8  39C7545A     STRB R2, [R3, R1]
96:               PORT_REGS->GROUP[1].PORT_PINCFG[16] = 0x2;
54DA  20D039C7     SUBS R1, #199
54DC  541920D0     MOVS R0, #208
54DE  300E5419     STRB R1, [R3, R0]
97:               PORT_REGS->GROUP[1].PORT_PINCFG[30] = 0x1;
54E0  541A300E     ADDS R0, #14
54E2  3001541A     STRB R2, [R3, R0]
98:               PORT_REGS->GROUP[1].PORT_PINCFG[31] = 0x2;
54E4  54193001     ADDS R0, #1
54E6  31AE5419     STRB R1, [R3, R0]
99:            
100:              PORT_REGS->GROUP[1].PORT_PMUX[0] = 0x1;
54E8  545A31AE     ADDS R1, #174
54EA  399F545A     STRB R2, [R3, R1]
101:              PORT_REGS->GROUP[1].PORT_PMUX[4] = 0x11;
54EC  32B3399F     SUBS R1, #159
54EE  549932B3     ADDS R2, #179
54F0  390D5499     STRB R1, [R3, R2]
102:              PORT_REGS->GROUP[1].PORT_PMUX[15] = 0x4;
54F2  320B390D     SUBS R1, #13
54F4  5499320B     ADDS R2, #11
54F6  BD105499     STRB R1, [R3, R2]
103:           }
54F8  E7FEBD10     POP {R4, PC}
104:           
105:           // *****************************************************************************
106:           /* Function:
107:               uint32_t PORT_GroupRead(PORT_GROUP group)
108:           
109:             Summary:
110:               Read all the I/O pins in the specified port group.
111:           
112:             Description:
113:               The function reads the hardware pin state of all pins in the specified group
114:               and returns this as a 32 bit value. Each bit in the 32 bit value represent a
115:               pin. For example, bit 0 in group 0 will represent pin PA0. Bit 1 will
116:               represent PA1 and so on. The application should only consider the value of
117:               the port group pins which are implemented on the device.
118:           
119:             Remarks:
120:               Refer plib_port.h file for more information.
121:           */
122:           
123:           uint32_t PORT_GroupRead(PORT_GROUP group)
124:           {
125:               return (((port_group_registers_t*)group)->PORT_IN);
0000  20007FF8     LDRB R0, [R7, #31]
126:           }
0002  596D2000     MOVS R0, #0
127:           
128:           // *****************************************************************************
129:           /* Function:
130:               void PORT_GroupWrite(PORT_GROUP group, uint32_t mask, uint32_t value);
131:           
132:             Summary:
133:               Write value on the masked pins of the selected port group.
134:           
135:             Description:
136:               This function writes the value contained in the value parameter to the
137:               port group. Port group pins which are configured for output will be updated.
138:               The mask parameter provides additional control on the bits in the group to
139:               be affected. Setting a bit to 1 in the mask will cause the corresponding
140:               bit in the port group to be updated. Clearing a bit in the mask will cause
141:               that corresponding bit in the group to stay unaffected. For example,
142:               setting a mask value 0xFFFFFFFF will cause all bits in the port group
143:               to be updated. Setting a value 0x3 will only cause port group bit 0 and
144:               bit 1 to be updated.
145:           
146:               For port pins which are not configured for output and have the pull feature
147:               enabled, this function will affect pull value (pull up or pull down). A bit
148:               value of 1 will enable the pull up. A bit value of 0 will enable the pull
149:               down.
150:           
151:             Remarks:
152:               Refer plib_port.h file for more information.
153:           */
154:           
155:           void PORT_GroupWrite(PORT_GROUP group, uint32_t mask, uint32_t value)
156:           {
157:               /* Write the desired value */
158:               ((port_group_registers_t*)group)->PORT_OUT = (((port_group_registers_t*)group)->PORT_OUT & (~mask)) | (mask & value);
0000  20007FF8     LDRB R0, [R7, #31]
159:           }
000A  653F0000     MOVS R0, R0
160:           
161:           // *****************************************************************************
162:           /* Function:
163:               uint32_t PORT_GroupLatchRead(PORT_GROUP group)
164:           
165:             Summary:
166:               Read the data driven on all the I/O pins of the selected port group.
167:           
168:             Description:
169:               The function will return a 32-bit value representing the logic levels being
170:               driven on the output pins within the group. The function will not sample the
171:               actual hardware state of the output pin. Each bit in the 32-bit return value
172:               will represent one of the 32 port pins within the group. The application
173:               should only consider the value of the pins which are available on the
174:               device.
175:           
176:             Remarks:
177:               Refer plib_port.h file for more information.
178:           */
179:           
180:           uint32_t PORT_GroupLatchRead(PORT_GROUP group)
181:           {
182:               return (((port_group_registers_t*)group)->PORT_OUT);
0000  20007FF8     LDRB R0, [R7, #31]
183:           }
0002  596D2000     MOVS R0, #0
184:           
185:           // *****************************************************************************
186:           /* Function:
187:               void PORT_GroupSet(PORT_GROUP group, uint32_t mask)
188:           
189:             Summary:
190:               Set the selected IO pins of a group.
191:           
192:             Description:
193:               This function sets (drives a logic high) on the selected output pins of a
194:               group. The mask parameter control the pins to be updated. A mask bit
195:               position with a value 1 will cause that corresponding port pin to be set. A
196:               mask bit position with a value 0 will cause the corresponding port pin to
197:               stay un-affected.
198:           
199:             Remarks:
200:               Refer plib_port.h file for more information.
201:           */
202:           
203:           void PORT_GroupSet(PORT_GROUP group, uint32_t mask)
204:           {
205:               ((port_group_registers_t*)group)->PORT_OUTSET = mask;
0000  20007FF8     LDRB R0, [R7, #31]
206:           }
0002  596D2000     MOVS R0, #0
207:           
208:           // *****************************************************************************
209:           /* Function:
210:               void PORT_GroupClear(PORT_GROUP group, uint32_t mask)
211:           
212:             Summary:
213:               Clears the selected IO pins of a group.
214:           
215:             Description:
216:               This function clears (drives a logic 0) on the selected output pins of a
217:               group. The mask parameter control the pins to be updated. A mask bit
218:               position with a value 1 will cause that corresponding port pin to be clear.
219:               A mask bit position with a value 0 will cause the corresponding port pin to
220:               stay un-affected.
221:           
222:             Remarks:
223:               Refer plib_port.h file for more information.
224:           */
225:           
226:           void PORT_GroupClear(PORT_GROUP group, uint32_t mask)
227:           {
228:               ((port_group_registers_t*)group)->PORT_OUTCLR = mask;
0000  20007FF8     LDRB R0, [R7, #31]
229:           }
0002  596D2000     MOVS R0, #0
230:           
231:           // *****************************************************************************
232:           /* Function:
233:               void PORT_GroupToggle(PORT_GROUP group, uint32_t mask)
234:           
235:             Summary:
236:               Toggles the selected IO pins of a group.
237:           
238:             Description:
239:               This function toggles the selected output pins of a group. The mask
240:               parameter control the pins to be updated. A mask bit position with a value 1
241:               will cause that corresponding port pin to be toggled.  A mask bit position
242:               with a value 0 will cause the corresponding port pin to stay un-affected.
243:           
244:             Remarks:
245:               Refer plib_port.h file for more information.
246:           */
247:           
248:           void PORT_GroupToggle(PORT_GROUP group, uint32_t mask)
249:           {
250:               ((port_group_registers_t*)group)->PORT_OUTTGL = mask;
0000  20007FF8     LDRB R0, [R7, #31]
251:           }
0002  596D2000     MOVS R0, #0
252:           
253:           // *****************************************************************************
254:           /* Function:
255:               void PORT_GroupInputEnable(PORT_GROUP group, uint32_t mask)
256:           
257:             Summary:
258:               Confgiures the selected IO pins of a group as input.
259:           
260:             Description:
261:               This function configures the selected IO pins of a group as input. The pins
262:               to be configured as input are selected by setting the corresponding bits in
263:               the mask parameter to 1.
264:           
265:             Remarks:
266:               Refer plib_port.h file for more information.
267:           */
268:           
269:           void PORT_GroupInputEnable(PORT_GROUP group, uint32_t mask)
270:           {
271:               ((port_group_registers_t*)group)->PORT_DIRCLR = mask;
0000  20007FF8     LDRB R0, [R7, #31]
272:           }
0002  596D2000     MOVS R0, #0
273:           
274:           // *****************************************************************************
275:           /* Function:
276:               void PORT_GroupOutputEnable(PORT_GROUP group, uint32_t mask)
277:           
278:             Summary:
279:               Confgiures the selected IO pins of a group as output.
280:           
281:             Description:
282:               This function configures the selected IO pins of a group as output. The pins
283:               to be configured as output are selected by setting the corresponding bits in
284:               the mask parameter to 1.
285:           
286:             Remarks:
287:               Refer plib_port.h file for more information.
288:           */
289:           
290:           void PORT_GroupOutputEnable(PORT_GROUP group, uint32_t mask)
291:           {
292:              ((port_group_registers_t*)group)->PORT_DIRSET = mask;
0000  20007FF8     LDRB R0, [R7, #31]
293:           }
0002  596D2000     MOVS R0, #0
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/nvic/plib_nvic.c
1:             /*******************************************************************************
2:               NVIC PLIB Implementation
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 plib_nvic.c
9:             
10:              Summary:
11:                NVIC PLIB Source File
12:            
13:              Description:
14:                None
15:            
16:            *******************************************************************************/
17:            
18:            /*******************************************************************************
19:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:            *
21:            * Subject to your compliance with these terms, you may use Microchip software
22:            * and any derivatives exclusively with Microchip products. It is your
23:            * responsibility to comply with third party license terms applicable to your
24:            * use of third party software (including open source software) that may
25:            * accompany Microchip software.
26:            *
27:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:            * PARTICULAR PURPOSE.
31:            *
32:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:            *******************************************************************************/
40:            
41:            #include "device.h"
42:            #include "plib_nvic.h"
43:            
44:            
45:            // *****************************************************************************
46:            // *****************************************************************************
47:            // Section: NVIC Implementation
48:            // *****************************************************************************
49:            // *****************************************************************************
50:            
51:            void NVIC_Initialize( void )
52:            {
53:            
54:                /* Enable NVIC Controller */
55:                __DMB();
56:                __enable_irq();
57:            
58:                /* Enable the interrupt sources and configure the priorities as configured
59:                 * from within the "Interrupt Manager" of MHC. */
60:                NVIC_SetPriority(EIC_IRQn, 1);
61:                NVIC_EnableIRQ(EIC_IRQn);
62:                NVIC_SetPriority(ADC0_IRQn, 2);
63:                NVIC_EnableIRQ(ADC0_IRQn);
64:            
65:            
66:            
67:                return;
68:            }
5D44  46C04770     BX LR
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/evsys/plib_evsys.c
1:             /*******************************************************************************
2:               EVSYS Peripheral Library
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 plib_evsys.c
9:             
10:              Summary:
11:                EVSYS Source File
12:            
13:              Description:
14:                None
15:            
16:            *******************************************************************************/
17:            
18:            /*******************************************************************************
19:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:            *
21:            * Subject to your compliance with these terms, you may use Microchip software
22:            * and any derivatives exclusively with Microchip products. It is your
23:            * responsibility to comply with third party license terms applicable to your
24:            * use of third party software (including open source software) that may
25:            * accompany Microchip software.
26:            *
27:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:            * PARTICULAR PURPOSE.
31:            *
32:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:            *******************************************************************************/
40:            
41:            #include "plib_evsys.h"
42:            
43:            
44:            void EVSYS_Initialize( void )
45:            {	/*Event Channel User Configuration*/
46:            	EVSYS_REGS->EVSYS_USER[9] = EVSYS_USER_CHANNEL(0x2);
62C0  5DB2384     MOVS R3, #132
62C2  210205DB     LSLS R3, R3, #23
62C4  22A42102     MOVS R1, #2
62C6  509922A4     MOVS R2, #164
62C8  39015099     STR R1, [R3, R2]
47:            	EVSYS_REGS->EVSYS_USER[28] = EVSYS_USER_CHANNEL(0x1);
62CA  324C3901     SUBS R1, #1
62CC  5099324C     ADDS R2, #76
62CE  4A025099     STR R1, [R3, R2]
48:            
49:            	/* Event Channel 0 Configuration */
50:            	EVSYS_REGS->EVSYS_CHANNEL[0] = EVSYS_CHANNEL_EVGEN(35) | EVSYS_CHANNEL_PATH(2) | EVSYS_CHANNEL_EDGSEL(1) \
62D0  621A4A02     LDR R2, $d
62D2  3A13621A     STR R2, [R3, #32]
51:            									 ;
52:            	/* Event Channel 1 Configuration */
53:            	EVSYS_REGS->EVSYS_CHANNEL[1] = EVSYS_CHANNEL_EVGEN(16) | EVSYS_CHANNEL_PATH(2) | EVSYS_CHANNEL_EDGSEL(1) \
62D4  625A3A13     SUBS R2, #19
62D6  4770625A     STR R2, [R3, #36]
54:            									 ;
55:            
56:            }
62D8  46C04770     BX LR
62DA  62346C0     MOV R8, R8
62DC  0623     LSLS R3, R4, #24
62DE  B5700000     MOVS R0, R0
57:            
58:            
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/eic/plib_eic.c
1:             /*******************************************************************************
2:               External Interrupt Controller (EIC) PLIB
3:             
4:               Company
5:                 Microchip Technology Inc.
6:             
7:               File Name
8:                 plib_eic.c
9:             
10:              Summary
11:                Source for EIC peripheral library interface Implementation.
12:            
13:              Description
14:                This file defines the interface to the EIC peripheral library. This
15:                library provides access to and control of the associated peripheral
16:                instance.
17:            
18:              Remarks:
19:                None.
20:            
21:            *******************************************************************************/
22:            
23:            // DOM-IGNORE-BEGIN
24:            /*******************************************************************************
25:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
26:            *
27:            * Subject to your compliance with these terms, you may use Microchip software
28:            * and any derivatives exclusively with Microchip products. It is your
29:            * responsibility to comply with third party license terms applicable to your
30:            * use of third party software (including open source software) that may
31:            * accompany Microchip software.
32:            *
33:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
34:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
35:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
36:            * PARTICULAR PURPOSE.
37:            *
38:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
39:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
40:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
41:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
42:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
43:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
44:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:            *******************************************************************************/
46:            // DOM-IGNORE-END
47:            
48:            // *****************************************************************************
49:            // *****************************************************************************
50:            // Section: Included Files
51:            // *****************************************************************************
52:            // *****************************************************************************
53:            /* This section lists the other files that are included in this file.
54:            */
55:            
56:            #include "plib_eic.h"
57:            
58:            // *****************************************************************************
59:            // *****************************************************************************
60:            // Section: Global Data
61:            // *****************************************************************************
62:            // *****************************************************************************
63:            
64:            /* EIC Channel Callback object */
65:            EIC_CALLBACK_OBJ    eicCallbackObject[EXTINT_COUNT];
66:            
67:            
68:            void EIC_Initialize (void)
69:            {
52EC  4A1EB510     PUSH {R4, LR}
70:                /* Reset all registers in the EIC module to their initial state and
71:            	   EIC will be disabled. */
72:                EIC_REGS->EIC_CTRLA |= EIC_CTRLA_SWRST_Msk;
52EE  78134A1E     LDR R2, [PC, #120]
52F0  21017813     LDRB R3, [R2]
52F2  430B2101     MOVS R1, #1
52F4  7013430B     ORRS R3, R1
52F6  117013     STRB R3, [R2]
73:            
74:                while((EIC_REGS->EIC_SYNCBUSY & EIC_SYNCBUSY_SWRST_Msk) == EIC_SYNCBUSY_SWRST_Msk)
52F8  22010011     MOVS R1, R2
52FA  684B2201     MOVS R2, #1
52FC  421A684B     LDR R3, [R1, #4]
52FE  D1FC421A     TST R2, R3
5300  4919D1FC     BNE.N 0x52FC
75:                {
76:                    /* Wait for sync */
77:                }
78:            
79:                /* EIC is by default clocked by GCLK */
80:            
81:                /* NMI Control register */
82:            
83:                /* Interrupt sense type and filter control for EXTINT channels 0 to 7*/
84:                EIC_REGS->EIC_CONFIG[0] =  EIC_CONFIG_SENSE0_NONE  |
5302  23A04919     LDR R1, [PC, #100]
5304  DB23A0     MOVS R3, #160
5306  61CB00DB     LSLS R3, R3, #3
5308  23A061CB     STR R3, [R1, #28]
85:                                          EIC_CONFIG_SENSE1_NONE  |
86:                                          EIC_CONFIG_SENSE2_LOW  |
87:                                          EIC_CONFIG_SENSE3_NONE  |
88:                                          EIC_CONFIG_SENSE4_NONE  |
89:                                          EIC_CONFIG_SENSE5_NONE  |
90:                                          EIC_CONFIG_SENSE6_NONE  |
91:                                          EIC_CONFIG_SENSE7_NONE ;
92:            
93:                /* Interrupt sense type and filter control for EXTINT channels 8 to 15 */
94:                EIC_REGS->EIC_CONFIG[1] =  EIC_CONFIG_SENSE0_NONE  |
530A  5DB23A0     MOVS R3, #160
530C  620B05DB     LSLS R3, R3, #23
530E  2304620B     STR R3, [R1, #32]
95:                                          EIC_CONFIG_SENSE1_NONE  |
96:                                          EIC_CONFIG_SENSE2_NONE  |
97:                                          EIC_CONFIG_SENSE3_NONE  |
98:                                          EIC_CONFIG_SENSE4_NONE  |
99:                                          EIC_CONFIG_SENSE5_NONE  |
100:                                         EIC_CONFIG_SENSE6_NONE  |
101:                                         EIC_CONFIG_SENSE7_LOW ;
102:           
103:           
104:           
105:               /* Event Control Output enable */
106:               EIC_REGS->EIC_EVCTRL = 0x4;
5310  608B2304     MOVS R3, #4
5312  610B608B     STR R3, [R1, #8]
107:           
108:           
109:               /* External Interrupt enable*/
110:               EIC_REGS->EIC_INTENSET = 0x4;
5314  4B15610B     STR R3, [R1, #16]
111:           
112:               /* Callbacks for enabled interrupts */
113:               eicCallbackObject[0].eicPinNo = EIC_PIN_MAX;
5316  22104B15     LDR R3, [PC, #84]
5318  721A2210     MOVS R2, #16
531A  751A721A     STRB R2, [R3, #8]
114:               eicCallbackObject[1].eicPinNo = EIC_PIN_MAX;
531C  2402751A     STRB R2, [R3, #20]
115:               eicCallbackObject[2].eicPinNo = EIC_PIN_2;
531E  20202402     MOVS R4, #2
5320  541C2020     MOVS R0, #32
5322  300C541C     STRB R4, [R3, R0]
116:               eicCallbackObject[3].eicPinNo = EIC_PIN_MAX;
5324  541A300C     ADDS R0, #12
5326  300C541A     STRB R2, [R3, R0]
117:               eicCallbackObject[4].eicPinNo = EIC_PIN_MAX;
5328  541A300C     ADDS R0, #12
532A  300C541A     STRB R2, [R3, R0]
118:               eicCallbackObject[5].eicPinNo = EIC_PIN_MAX;
532C  541A300C     ADDS R0, #12
532E  300C541A     STRB R2, [R3, R0]
119:               eicCallbackObject[6].eicPinNo = EIC_PIN_MAX;
5330  541A300C     ADDS R0, #12
5332  300C541A     STRB R2, [R3, R0]
120:               eicCallbackObject[7].eicPinNo = EIC_PIN_MAX;
5334  541A300C     ADDS R0, #12
5336  300C541A     STRB R2, [R3, R0]
121:               eicCallbackObject[8].eicPinNo = EIC_PIN_MAX;
5338  541A300C     ADDS R0, #12
533A  300C541A     STRB R2, [R3, R0]
122:               eicCallbackObject[9].eicPinNo = EIC_PIN_MAX;
533C  541A300C     ADDS R0, #12
533E  300C541A     STRB R2, [R3, R0]
123:               eicCallbackObject[10].eicPinNo = EIC_PIN_MAX;
5340  541A300C     ADDS R0, #12
5342  300C541A     STRB R2, [R3, R0]
124:               eicCallbackObject[11].eicPinNo = EIC_PIN_MAX;
5344  541A300C     ADDS R0, #12
5346  300C541A     STRB R2, [R3, R0]
125:               eicCallbackObject[12].eicPinNo = EIC_PIN_MAX;
5348  541A300C     ADDS R0, #12
534A  300C541A     STRB R2, [R3, R0]
126:               eicCallbackObject[13].eicPinNo = EIC_PIN_MAX;
534C  541A300C     ADDS R0, #12
534E  300C541A     STRB R2, [R3, R0]
127:               eicCallbackObject[14].eicPinNo = EIC_PIN_MAX;
5350  541A300C     ADDS R0, #12
5352  300C541A     STRB R2, [R3, R0]
128:               eicCallbackObject[15].eicPinNo = EIC_PIN_MAX;
5354  541A300C     ADDS R0, #12
5356  780B541A     STRB R2, [R3, R0]
129:               /* Enable the EIC */
130:               EIC_REGS->EIC_CTRLA |= EIC_CTRLA_ENABLE_Msk;
5358  3A0E780B     LDRB R3, [R1]
535A  43133A0E     SUBS R2, #14
535C  700B4313     ORRS R3, R2
535E  684B700B     STRB R3, [R1]
131:           
132:               while((EIC_REGS->EIC_SYNCBUSY & EIC_SYNCBUSY_ENABLE_Msk) == EIC_SYNCBUSY_ENABLE_Msk)
5360  421A684B     LDR R3, [R1, #4]
5362  D1FC421A     TST R2, R3
5364  BD10D1FC     BNE.N 0x5360
133:               {
134:                   /* Wait for sync */
135:               }
136:           }
5366  2800BD10     POP {R4, PC}
5368  40002800     CMP R0, #0
536A  84000     ANDS R0, R0
536C  20000008     MOVS R0, R1
536E  B5F02000     MOVS R0, #0
137:           
138:           void EIC_InterruptEnable (EIC_PIN pin)
139:           {
140:               EIC_REGS->EIC_INTENSET = (1UL << pin);
0000  20007FF8     LDRB R0, [R7, #31]
141:           }
0008  653D     STR R5, [R7, #80]
142:           
143:           void EIC_InterruptDisable (EIC_PIN pin)
144:           {
145:               EIC_REGS->EIC_INTENCLR = (1UL << pin);
0000  20007FF8     LDRB R0, [R7, #31]
146:           }
0008  653D     STR R5, [R7, #80]
147:           
148:           void EIC_CallbackRegister(EIC_PIN pin, EIC_CALLBACK callback, uintptr_t context)
149:           {
6204  43B530     PUSH {R4, R5, LR}
150:               if (eicCallbackObject[pin].eicPinNo == pin)
6206  181B0043     LSLS R3, R0, #1
6208  9B181B     ADDS R3, R3, R0
620A  4C06009B     LSLS R3, R3, #2
620C  18E34C06     LDR R4, $d
620E  7A1B18E3     ADDS R3, R4, R3
6210  42837A1B     LDRB R3, [R3, #8]
6212  D0004283     CMP R3, R0
6214  BD30D000     BEQ.N .LVL4
151:               {
152:                   eicCallbackObject[pin].callback = callback;
6218  181D0043     LSLS R3, R0, #1
621A  AD181D     ADDS R5, R3, R0
621C  512900AD     LSLS R5, R5, #2
621E  19605129     STR R1, [R5, R4]
153:           
154:                   eicCallbackObject[pin].context  = context;
6220  60421960     ADDS R0, R4, R5
6222  E7F76042     STR R2, [R0, #4]
155:               }
156:           }
6216  43BD30     POP {R4, R5, PC}
6224  46C0E7F7     B.N .LVL3
6226  846C0     MOV R8, R8
6228  20000008     MOVS R0, R1
622A  B5102000     MOVS R0, #0
157:           
158:           void EIC_InterruptHandler(void)
159:           {
5BF4  46C6B5F0     PUSH {R4, R5, R6, R7, LR}
5BF6  B50046C6     MOV LR, R8
5BF8  4D0EB500     PUSH {LR}
5BFA  24004D0E     LDR R5, [PC, #56]
5BFC  4F0E2400     MOVS R4, #0
160:               uint8_t currentChannel = 0;
161:               uint32_t eicIntFlagStatus = 0;
162:           
163:               /* Find any triggered channels, run associated callback handlers */
164:               for (currentChannel = 0; currentChannel < EXTINT_COUNT; currentChannel++)
5C0C  D00E2C10     CMP R4, #16
5C0E  7A2AD00E     BEQ.N .LVL14
165:               {
166:                   /* Verify if the EXTINT x Interrupt Pin is enabled */
167:                   if ((eicCallbackObject[currentChannel].eicPinNo == currentChannel))
5C10  B2E37A2A     LDRB R2, [R5, #8]
5C12  429AB2E3     UXTB R3, R4
5C14  D1F7429A     CMP R2, R3
5C16  697BD1F7     BNE.N .LVL8
168:                   {
169:                       /* Read the interrupt flag status */
170:                       eicIntFlagStatus = EIC_REGS->EIC_INTFLAG & (1UL << currentChannel);
5BFE  23014F0E     LDR R7, [PC, #56]
5C00  46982301     MOVS R3, #1
5C02  E0044698     MOV R8, R3
5C04  617EE004     B.N .LVL10
5C18  4646697B     LDR R3, [R7, #20]
5C1A  40A64646     MOV R6, R8
5C1C  421E40A6     LSLS R6, R4
171:           
172:                       if (eicIntFlagStatus)
5C1E  D0F2421E     TST R6, R3
5C20  682BD0F2     BEQ.N .LVL8
173:                       {
174:                           /* Find any associated callback entries in the callback table */
175:                           if ((eicCallbackObject[currentChannel].callback != NULL))
5C22  2B00682B     LDR R3, [R5]
5C24  D0EE2B00     CMP R3, #0
5C26  6868D0EE     BEQ.N .LVL7
176:                           {
177:                               eicCallbackObject[currentChannel].callback(eicCallbackObject[currentChannel].context);
5C28  47986868     LDR R0, [R5, #4]
5C2A  E7EB4798     BLX R3
5C2C  BC04E7EB     B.N .LVL7
178:                           }
179:           
180:                           /* Clear interrupt flag */
181:                           EIC_REGS->EIC_INTFLAG = (1UL << currentChannel);
5C06  3401617E     STR R6, [R7, #20]
5C08  350C3401     ADDS R4, #1
5C0A  2C10350C     ADDS R5, #12
182:                       }
183:                   }
184:               }
185:           }
5C2E  4690BC04     POP {R2}
5C30  BDF04690     MOV R8, R2
5C32  8BDF0     POP {R4, R5, R6, R7, PC}
5C34  20000008     MOVS R0, R1
5C36  28002000     MOVS R0, #0
5C38  40002800     CMP R0, #0
5C3A  B5304000     ANDS R0, R0
186:           
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/clock/plib_clock.c
1:             /*******************************************************************************
2:              CLOCK PLIB
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 plib_clock.c
9:             
10:              Summary:
11:                CLOCK PLIB Implementation File.
12:            
13:              Description:
14:                None
15:            
16:            *******************************************************************************/
17:            
18:            /*******************************************************************************
19:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:            *
21:            * Subject to your compliance with these terms, you may use Microchip software
22:            * and any derivatives exclusively with Microchip products. It is your
23:            * responsibility to comply with third party license terms applicable to your
24:            * use of third party software (including open source software) that may
25:            * accompany Microchip software.
26:            *
27:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:            * PARTICULAR PURPOSE.
31:            *
32:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:            *******************************************************************************/
40:            
41:            #include "plib_clock.h"
42:            #include "device.h"
43:            
44:            
45:            
46:            static void OSCCTRL_Initialize(void)
47:            {
48:                uint32_t calibValue = (uint32_t)(((*(uint64_t*)0x806020) >> 19 ) & 0x3fffff);
45F6  685A4B39     LDR R3, [PC, #228]
49:                OSCCTRL_REGS->OSCCTRL_CAL48M = calibValue;
4606  63934A36     LDR R2, [PC, #216]
50:            
51:            
52:                /* Selection of the Division Value */
53:                OSCCTRL_REGS->OSCCTRL_OSC48MDIV = OSCCTRL_OSC48MDIV_DIV(0);
460A  75532300     MOVS R3, #0
54:            
55:                while((OSCCTRL_REGS->OSCCTRL_OSC48MSYNCBUSY & OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV_Msk) == OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV_Msk)
460E  22040011     MOVS R1, R2
56:                {
57:                    /* Waiting for the synchronization */
58:                }
59:            
60:                while((OSCCTRL_REGS->OSCCTRL_STATUS & OSCCTRL_STATUS_OSC48MRDY_Msk) != OSCCTRL_STATUS_OSC48MRDY_Msk)
4618  22104931     LDR R1, [PC, #196]
461A  68CB2210     MOVS R2, #16
461C  421A68CB     LDR R3, [R1, #12]
461E  D0FC421A     TST R2, R3
4620  4B30D0FC     BEQ.N 0x461C
61:                {
62:                    /* Waiting for the OSC48M Ready state */
63:                }
64:            }
65:            
66:            static void OSC32KCTRL_Initialize(void)
67:            {
68:            	OSC32KCTRL_REGS->OSC32KCTRL_OSC32K = 0x0;
4622  22004B30     LDR R3, [PC, #192]
69:            
70:            	OSC32KCTRL_REGS->OSC32KCTRL_RTCCTRL = OSC32KCTRL_RTCCTRL_RTCSEL(0);
4628  4A2F611A     STR R2, [R3, #16]
71:            }
72:            
73:            
74:            
75:            static void GCLK0_Initialize(void)
76:            {
77:                GCLK_REGS->GCLK_GENCTRL[0] = GCLK_GENCTRL_DIV(1) | GCLK_GENCTRL_SRC(6) | GCLK_GENCTRL_GENEN_Msk;
462A  4B2F4A2F     LDR R2, [PC, #188]
78:            
79:                while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL0_Msk) == GCLK_SYNCBUSY_GENCTRL0_Msk)
4630  22040019     MOVS R1, R3
4632  684B2204     MOVS R2, #4
4634  421A684B     LDR R3, [R1, #4]
4636  D1FC421A     TST R2, R3
4638  2140D1FC     BNE.N 0x4634
80:                {
81:                    /* wait for the Generator 0 synchronization */
82:                }
83:            }
84:            
85:            void CLOCK_Initialize (void)
86:            {
87:                /* NVM Wait States */
88:                NVMCTRL_REGS->NVMCTRL_CTRLB |= NVMCTRL_CTRLB_RWS(NVMCTRL_CTRLB_RWS_DUAL_Val);
45EC  68534A3A     LDR R2, $d
45EE  21046853     LDR R3, [R2, #4]
45F0  430B2104     MOVS R1, #4
45F2  6053430B     ORRS R3, R1
45F4  4B396053     STR R3, [R2, #4]
89:            
90:                /* Function to Initialize the Oscillators */
91:                OSCCTRL_Initialize();
92:            
93:                /* Function to Initialize the 32KHz Oscillators */
94:                OSC32KCTRL_Initialize();
95:            
96:               GCLK0_Initialize();
97:            
98:            
99:            
100:           	/* Selection of the Generator and write Lock for EIC */
101:               GCLK_REGS->GCLK_PCHCTRL[2] = GCLK_PCHCTRL_GEN(0x0)  | GCLK_PCHCTRL_CHEN_Msk;
463A  23882140     MOVS R1, #64
463C  4A2B2388     MOVS R3, #136
463E  50D14A2B     LDR R2, [PC, #172]
4640  1050D1     STR R1, [R2, R3]
102:           
103:               while ((GCLK_REGS->GCLK_PCHCTRL[2] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
4642  31480010     MOVS R0, R2
4644  22403148     ADDS R1, #72
4646  58432240     MOVS R2, #64
4648  421A5843     LDR R3, [R0, R1]
464A  D0FC421A     TST R2, R3
464C  2140D0FC     BEQ.N 0x4648
104:               {
105:                   /* Wait for synchronization */
106:               }
107:           	/* Selection of the Generator and write Lock for EVSYS_0 */
108:               GCLK_REGS->GCLK_PCHCTRL[6] = GCLK_PCHCTRL_GEN(0x0)  | GCLK_PCHCTRL_CHEN_Msk;
464E  23982140     MOVS R1, #64
4650  4A262398     MOVS R3, #152
4652  50D14A26     LDR R2, [PC, #152]
4654  1050D1     STR R1, [R2, R3]
109:           
110:               while ((GCLK_REGS->GCLK_PCHCTRL[6] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
4656  31580010     MOVS R0, R2
4658  22403158     ADDS R1, #88
465A  58432240     MOVS R2, #64
465C  421A5843     LDR R3, [R0, R1]
465E  D0FC421A     TST R2, R3
4660  2140D0FC     BEQ.N 0x465C
111:               {
112:                   /* Wait for synchronization */
113:               }
114:           	/* Selection of the Generator and write Lock for EVSYS_1 */
115:               GCLK_REGS->GCLK_PCHCTRL[7] = GCLK_PCHCTRL_GEN(0x0)  | GCLK_PCHCTRL_CHEN_Msk;
4662  239C2140     MOVS R1, #64
4664  4A21239C     MOVS R3, #156
4666  50D14A21     LDR R2, [PC, #132]
4668  1050D1     STR R1, [R2, R3]
116:           
117:               while ((GCLK_REGS->GCLK_PCHCTRL[7] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
466A  315C0010     MOVS R0, R2
466C  2240315C     ADDS R1, #92
466E  58432240     MOVS R2, #64
4670  421A5843     LDR R3, [R0, R1]
4672  D0FC421A     TST R2, R3
4674  2140D0FC     BEQ.N 0x4670
118:               {
119:                   /* Wait for synchronization */
120:               }
121:           	/* Selection of the Generator and write Lock for SERCOM3_CORE */
122:               GCLK_REGS->GCLK_PCHCTRL[22] = GCLK_PCHCTRL_GEN(0x0)  | GCLK_PCHCTRL_CHEN_Msk;
4676  23D82140     MOVS R1, #64
4678  4A1C23D8     MOVS R3, #216
467A  50D14A1C     LDR R2, [PC, #112]
467C  1050D1     STR R1, [R2, R3]
123:           
124:               while ((GCLK_REGS->GCLK_PCHCTRL[22] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
467E  31980010     MOVS R0, R2
4680  22403198     ADDS R1, #152
4682  58432240     MOVS R2, #64
4684  421A5843     LDR R3, [R0, R1]
4686  D0FC421A     TST R2, R3
4688  2140D0FC     BEQ.N 0x4684
125:               {
126:                   /* Wait for synchronization */
127:               }
128:           	/* Selection of the Generator and write Lock for TCC0 TCC1 */
129:               GCLK_REGS->GCLK_PCHCTRL[28] = GCLK_PCHCTRL_GEN(0x0)  | GCLK_PCHCTRL_CHEN_Msk;
468A  23F02140     MOVS R1, #64
468C  4A1723F0     MOVS R3, #240
468E  50D14A17     LDR R2, [PC, #92]
4690  1050D1     STR R1, [R2, R3]
130:           
131:               while ((GCLK_REGS->GCLK_PCHCTRL[28] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
4692  31B00010     MOVS R0, R2
4694  224031B0     ADDS R1, #176
4696  58432240     MOVS R2, #64
4698  421A5843     LDR R3, [R0, R1]
469A  D0FC421A     TST R2, R3
469C  2140D0FC     BEQ.N 0x4698
132:               {
133:                   /* Wait for synchronization */
134:               }
135:           	/* Selection of the Generator and write Lock for ADC0 */
136:               GCLK_REGS->GCLK_PCHCTRL[33] = GCLK_PCHCTRL_GEN(0x0)  | GCLK_PCHCTRL_CHEN_Msk;
469E  23822140     MOVS R1, #64
46A0  5B2382     MOVS R3, #130
46A2  4A11005B     LSLS R3, R3, #1
46A4  50D14A11     LDR R2, [PC, #68]
46A6  1050D1     STR R1, [R2, R3]
137:           
138:               while ((GCLK_REGS->GCLK_PCHCTRL[33] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
46A8  190010     MOVS R0, R2
46AA  22400019     MOVS R1, R3
46AC  58432240     MOVS R2, #64
46AE  421A5843     LDR R3, [R0, R1]
46B0  D0FC421A     TST R2, R3
46B2  2140D0FC     BEQ.N 0x46AE
139:               {
140:                   /* Wait for synchronization */
141:               }
142:           	/* Selection of the Generator and write Lock for ADC1 */
143:               GCLK_REGS->GCLK_PCHCTRL[34] = GCLK_PCHCTRL_GEN(0x0)  | GCLK_PCHCTRL_CHEN_Msk;
46B4  23842140     MOVS R1, #64
46B6  5B2384     MOVS R3, #132
46B8  4A0C005B     LSLS R3, R3, #1
46BA  50D14A0C     LDR R2, [PC, #48]
46BC  1050D1     STR R1, [R2, R3]
144:           
145:               while ((GCLK_REGS->GCLK_PCHCTRL[34] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
46BE  190010     MOVS R0, R2
46C0  22400019     MOVS R1, R3
46C2  58432240     MOVS R2, #64
46C4  421A5843     LDR R3, [R0, R1]
46C6  D0FC421A     TST R2, R3
46C8  4B09D0FC     BEQ.N 0x46C4
146:               {
147:                   /* Wait for synchronization */
148:               }
149:           
150:               /* Configure the AHB Bridge Clocks */
151:               MCLK_REGS->MCLK_AHBMASK = 0x1cff;
46CA  4A094B09     LDR R3, [PC, #36]
46CC  611A4A09     LDR R2, [PC, #36]
46CE  4A09611A     STR R2, [R3, #16]
152:           
153:               /* Configure the APBC Bridge Clocks */
154:               MCLK_REGS->MCLK_APBCMASK = 0x60211;
46D0  61DA4A09     LDR R2, [PC, #36]
46D2  477061DA     STR R2, [R3, #28]
155:           
156:           }
46D4  46C04770     BX LR
46D6  400046C0     MOV R8, R8
46D8  41004000     ANDS R0, R0
46DA  60204100     ASRS R0, R0
46DC  806020     STR R0, [R4]
46DE  10000080     LSLS R0, R0, #2
46E0  40001000     MOVS R0, R0
46E2  14004000     ANDS R0, R0
46E4  40001400     ASRS R0, R0, #16
46E6  1064000     ANDS R0, R0
46E8  10106     LSLS R6, R0, #4
46EA  1C000001     MOVS R1, R0
46EC  40001C00     ADDS R0, #0
46EE  8004000     ANDS R0, R0
46F0  40000800     MOVS R0, R0
46F2  1CFF4000     ANDS R0, R0
46F4  1CFF     ADDS R7, #3
46F6  2110000     MOVS R0, R0
46F8  60211     LSLS R1, R2, #8
46FA  B5F00006     MOVS R6, R0
157:           
158:           
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/adc/plib_adc1.c
1:             /*******************************************************************************
2:               Analog-to-Digital Converter(ADC1) PLIB
3:             
4:               Company
5:                 Microchip Technology Inc.
6:             
7:               File Name
8:                 plib_adc1.c
9:             
10:              Summary
11:                ADC1 PLIB Implementation File.
12:            
13:              Description
14:                This file defines the interface to the ADC peripheral library. This
15:                library provides access to and control of the associated peripheral
16:                instance.
17:            
18:              Remarks:
19:                None.
20:            
21:            *******************************************************************************/
22:            
23:            // DOM-IGNORE-BEGIN
24:            /*******************************************************************************
25:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
26:            *
27:            * Subject to your compliance with these terms, you may use Microchip software
28:            * and any derivatives exclusively with Microchip products. It is your
29:            * responsibility to comply with third party license terms applicable to your
30:            * use of third party software (including open source software) that may
31:            * accompany Microchip software.
32:            *
33:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
34:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
35:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
36:            * PARTICULAR PURPOSE.
37:            *
38:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
39:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
40:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
41:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
42:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
43:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
44:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:            *******************************************************************************/
46:            // DOM-IGNORE-END
47:            
48:            // *****************************************************************************
49:            // *****************************************************************************
50:            // Section: Included Files
51:            // *****************************************************************************
52:            // *****************************************************************************
53:            /* This section lists the other files that are included in this file.
54:            */
55:            
56:            #include "plib_adc1.h"
57:            
58:            // *****************************************************************************
59:            // *****************************************************************************
60:            // Section: Global Data
61:            // *****************************************************************************
62:            // *****************************************************************************
63:            
64:            #define ADC1_LINEARITY_POS  (6)
65:            #define ADC1_LINEARITY_Msk   (0x7 << ADC1_LINEARITY_POS)
66:            
67:            #define ADC1_BIASCAL_POS  (9)
68:            #define ADC1_BIASCAL_Msk   (0x7 << ADC1_BIASCAL_POS)
69:            
70:            
71:            // *****************************************************************************
72:            // *****************************************************************************
73:            // Section: ADC1 Implementation
74:            // *****************************************************************************
75:            // *****************************************************************************
76:            
77:            // *****************************************************************************
78:            /* Initialize ADC module */
79:            void ADC1_Initialize( void )
80:            {
81:                /* Reset ADC */
82:                ADC1_REGS->ADC_CTRLA = ADC_CTRLA_SWRST_Msk;
5A78  4B0F2201     MOVS R2, #1
5A7A  701A4B0F     LDR R3, [PC, #60]
5A7C  19701A     STRB R2, [R3]
83:            
84:                while((ADC1_REGS->ADC_SYNCBUSY & ADC_SYNCBUSY_SWRST_Msk) == ADC_SYNCBUSY_SWRST_Msk)
5A7E  8C0B0019     MOVS R1, R3
5A80  42138C0B     LDRH R3, [R1, #32]
5A82  D1FC4213     TST R3, R2
5A84  4B0DD1FC     BNE.N 0x5A80
85:                {
86:                    /* Wait for Synchronization */
87:                }
88:            
89:                /* Write linearity calibration in BIASREFBUF and bias calibration in BIASCOMP */
90:                ADC1_REGS->ADC_CALIB = (uint32_t)(ADC_CALIB_BIASREFBUF(((*(uint64_t*)OTP5_ADDR) & ADC1_LINEARITY_Msk))) \
5A8E  859A4B0A     LDR R3, [PC, #40]
5A90  2220859A     STRH R2, [R3, #44]
91:                    | ADC_CALIB_BIASCOMP((((*(uint64_t*)OTP5_ADDR) & ADC1_BIASCAL_Msk) >> ADC1_BIASCAL_POS));
5A86  681A4B0D     LDR R3, [PC, #52]
5A88  512681A     LDR R2, [R3]
5A8A  F520512     LSLS R2, R2, #20
5A8C  4B0A0F52     LSRS R2, R2, #29
92:            
93:                ADC1_REGS->ADC_CTRLA = ADC_CTRLA_SLAVEEN_Msk;
5A92  701A2220     MOVS R2, #32
5A94  3A1C701A     STRB R2, [R3]
94:                /* Sampling length */
95:                ADC1_REGS->ADC_SAMPCTRL = ADC_SAMPCTRL_SAMPLEN(4U);
5A96  735A3A1C     SUBS R2, #28
5A98  3201735A     STRB R2, [R3, #13]
96:            
97:                /* reference */
98:                ADC1_REGS->ADC_REFCTRL = ADC_REFCTRL_REFSEL_INTVCC2;
5A9A  709A3201     ADDS R2, #1
5A9C  4A08709A     STRB R2, [R3, #2]
99:            
100:               /* positive and negative input pins */
101:               ADC1_REGS->ADC_INPUTCTRL = ADC_POSINPUT_AIN4 | ADC_NEGINPUT_GND;
5A9E  811A4A08     LDR R2, [PC, #32]
5AA0  2200811A     STRH R2, [R3, #8]
102:           
103:               /* Resolution & Operation Mode */
104:               ADC1_REGS->ADC_CTRLC = ADC_CTRLC_RESSEL_12BIT | ADC_CTRLC_WINMODE(0) ;
5AA2  815A2200     MOVS R2, #0
5AA4  2207815A     STRH R2, [R3, #10]
105:           
106:           
107:               /* Clear all interrupt flags */
108:               ADC1_REGS->ADC_INTFLAG = ADC_INTFLAG_Msk;
5AA6  719A2207     MOVS R2, #7
5AA8  1A719A     STRB R2, [R3, #6]
109:           
110:               while(ADC1_REGS->ADC_SYNCBUSY)
5AAA  8C13001A     MOVS R2, R3
5AAC  B29B8C13     LDRH R3, [R2, #32]
5AAE  2B00B29B     UXTH R3, R3
5AB0  D1FB2B00     CMP R3, #0
5AB2  4770D1FB     BNE.N 0x5AAC
111:               {
112:                   /* Wait for Synchronization */
113:               }
114:           }
5AB4  46C04770     BX LR
5AB6  480046C0     MOV R8, R8
5AB8  42004800     LDR R0, [PC]
5ABA  60204200     TST R0, R0
5ABC  806020     STR R0, [R4]
5ABE  18040080     LSLS R0, R0, #2
5AC0  1804     ADDS R4, R0, R0
5AC2  B5100000     MOVS R0, R0
115:           
116:           /* Enable ADC module */
117:           void ADC1_Enable( void )
118:           {
119:               ADC1_REGS->ADC_CTRLA |= ADC_CTRLA_ENABLE_Msk;
0000  20007FF8     LDRB R0, [R7, #31]
120:               while(ADC1_REGS->ADC_SYNCBUSY)
000A  653F0000     MOVS R0, R0
121:               {
122:                   /* Wait for Synchronization */
123:               }
124:           }
0012  0000     MOVS R0, R0
125:           
126:           /* Disable ADC module */
127:           void ADC1_Disable( void )
128:           {
129:               ADC1_REGS->ADC_CTRLA &= ~ADC_CTRLA_ENABLE_Msk;
0000  20007FF8     LDRB R0, [R7, #31]
130:               while(ADC1_REGS->ADC_SYNCBUSY)
000A  653F0000     MOVS R0, R0
131:               {
132:                   /* Wait for Synchronization */
133:               }
134:           }
0012  0000     MOVS R0, R0
135:           
136:           /* Configure channel input */
137:           void ADC1_ChannelSelect( ADC_POSINPUT positiveInput, ADC_NEGINPUT negativeInput )
138:           {
139:               /* Configure pin scan mode and positive and negative input pins */
140:               ADC1_REGS->ADC_INPUTCTRL = positiveInput | negativeInput;
63D8  4B044301     ORRS R1, R0
63DA  81194B04     LDR R3, [PC, #16]
63DC  198119     STRH R1, [R3, #8]
141:           
142:               while((ADC1_REGS->ADC_SYNCBUSY & ADC_SYNCBUSY_INPUTCTRL_Msk) == ADC_SYNCBUSY_INPUTCTRL_Msk)
63DE  22040019     MOVS R1, R3
63E0  8C0B2204     MOVS R2, #4
63E2  42138C0B     LDRH R3, [R1, #32]
63E4  D1FC4213     TST R3, R2
63E6  4770D1FC     BNE.N 0x63E2
143:               {
144:                   /* Wait for Synchronization */
145:               }
146:           }
63E8  46C04770     BX LR
63EA  480046C0     MOV R8, R8
63EC  42004800     LDR R0, [PC]
63EE  4B044200     TST R0, R0
147:           
148:           /* Start the ADC conversion by SW */
149:           void ADC1_ConversionStart( void )
150:           {
151:               /* Start conversion */
152:               ADC1_REGS->ADC_SWTRIG |= ADC_SWTRIG_START_Msk;
0000  20007FF8     LDRB R0, [R7, #31]
153:           
154:               while((ADC1_REGS->ADC_SYNCBUSY & ADC_SYNCBUSY_SWTRIG_Msk) == ADC_SYNCBUSY_SWTRIG_Msk)
000A  653F0000     MOVS R0, R0
0010  0000     MOVS R0, R0
155:               {
156:                   /* Wait for Synchronization */
157:               }
158:           }
0016  0000     MOVS R0, R0
159:           
160:           /* Check whether auto sequence conversion is done */
161:           bool ADC1_ConversionSequenceIsFinished(void)
162:           {
163:               bool seq_status = false;
164:               if ((ADC1_REGS->ADC_SEQSTATUS & ADC_SEQSTATUS_SEQBUSY_Msk) != ADC_SEQSTATUS_SEQBUSY_Msk)
0000  20007FF8     LDRB R0, [R7, #31]
165:               {
166:                   seq_status = true;
167:               }
168:               return seq_status;
0008  653D     STR R5, [R7, #80]
169:           }
000A  653F0000     MOVS R0, R0
170:           
171:           
172:           /* Read the conversion result */
173:           uint16_t ADC1_ConversionResultGet( void )
174:           {
175:               return (uint16_t)ADC1_REGS->ADC_RESULT;
64F8  8C984B01     LDR R3, $d
64FA  B2808C98     LDRH R0, [R3, #36]
64FC  4770B280     UXTH R0, R0
176:           }
64FE  48004770     BX LR
6500  42004800     LDR R0, [PC]
6502  B5104200     TST R0, R0
177:           
178:           /* Check whether result is ready */
179:           bool ADC1_ConversionStatusGet( void )
180:           {
181:               return (bool)((ADC1_REGS->ADC_INTFLAG & ADC_INTFLAG_RESRDY_Msk) == ADC_INTFLAG_RESRDY_Msk);
0000  20007FF8     LDRB R0, [R7, #31]
182:           }
0008  653D     STR R5, [R7, #80]
183:           
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/peripheral/adc/plib_adc0.c
1:             /*******************************************************************************
2:               Analog-to-Digital Converter(ADC0) PLIB
3:             
4:               Company
5:                 Microchip Technology Inc.
6:             
7:               File Name
8:                 plib_adc0.c
9:             
10:              Summary
11:                ADC0 PLIB Implementation File.
12:            
13:              Description
14:                This file defines the interface to the ADC peripheral library. This
15:                library provides access to and control of the associated peripheral
16:                instance.
17:            
18:              Remarks:
19:                None.
20:            
21:            *******************************************************************************/
22:            
23:            // DOM-IGNORE-BEGIN
24:            /*******************************************************************************
25:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
26:            *
27:            * Subject to your compliance with these terms, you may use Microchip software
28:            * and any derivatives exclusively with Microchip products. It is your
29:            * responsibility to comply with third party license terms applicable to your
30:            * use of third party software (including open source software) that may
31:            * accompany Microchip software.
32:            *
33:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
34:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
35:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
36:            * PARTICULAR PURPOSE.
37:            *
38:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
39:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
40:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
41:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
42:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
43:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
44:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:            *******************************************************************************/
46:            // DOM-IGNORE-END
47:            
48:            // *****************************************************************************
49:            // *****************************************************************************
50:            // Section: Included Files
51:            // *****************************************************************************
52:            // *****************************************************************************
53:            /* This section lists the other files that are included in this file.
54:            */
55:            
56:            #include "plib_adc0.h"
57:            
58:            // *****************************************************************************
59:            // *****************************************************************************
60:            // Section: Global Data
61:            // *****************************************************************************
62:            // *****************************************************************************
63:            ADC_CALLBACK_OBJ ADC0_CallbackObject;
64:            
65:            #define ADC0_LINEARITY_POS  (0)
66:            #define ADC0_LINEARITY_Msk   (0x7 << ADC0_LINEARITY_POS)
67:            
68:            #define ADC0_BIASCAL_POS  (3)
69:            #define ADC0_BIASCAL_Msk   (0x7 << ADC0_BIASCAL_POS)
70:            
71:            
72:            // *****************************************************************************
73:            // *****************************************************************************
74:            // Section: ADC0 Implementation
75:            // *****************************************************************************
76:            // *****************************************************************************
77:            
78:            // *****************************************************************************
79:            /* Initialize ADC module */
80:            void ADC0_Initialize( void )
81:            {
82:                /* Reset ADC */
83:                ADC0_REGS->ADC_CTRLA = ADC_CTRLA_SWRST_Msk;
59CC  4B132201     MOVS R2, #1
59CE  701A4B13     LDR R3, [PC, #76]
59D0  19701A     STRB R2, [R3]
84:            
85:                while((ADC0_REGS->ADC_SYNCBUSY & ADC_SYNCBUSY_SWRST_Msk) == ADC_SYNCBUSY_SWRST_Msk)
59D2  8C0B0019     MOVS R1, R3
59D4  42138C0B     LDRH R3, [R1, #32]
59D6  D1FC4213     TST R3, R2
59D8  4B11D1FC     BNE.N 0x59D4
86:                {
87:                    /* Wait for Synchronization */
88:                }
89:            
90:                /* Write linearity calibration in BIASREFBUF and bias calibration in BIASCOMP */
91:                ADC0_REGS->ADC_CALIB = (uint32_t)(ADC_CALIB_BIASREFBUF(((*(uint64_t*)OTP5_ADDR) & ADC0_LINEARITY_Msk))) \
59DA  681B4B11     LDR R3, [PC, #68]
59DC  21A681B     LDR R3, [R3]
59DE  21E0021A     LSLS R2, R3, #8
59E0  C921E0     MOVS R1, #224
59E2  400A00C9     LSLS R1, R1, #3
59E4  69B400A     ANDS R2, R1
59EC  859A4B0B     LDR R3, $d
59EE  2201859A     STRH R2, [R3, #44]
92:                    | ADC_CALIB_BIASCOMP((((*(uint64_t*)OTP5_ADDR) & ADC0_BIASCAL_Msk) >> ADC0_BIASCAL_POS));
59E6  F5B069B     LSLS R3, R3, #26
59E8  431A0F5B     LSRS R3, R3, #29
59EA  4B0B431A     ORRS R2, R3
93:            
94:                /* prescaler */
95:                ADC0_REGS->ADC_CTRLB = ADC_CTRLB_PRESCALER_DIV4;
59F0  705A2201     MOVS R2, #1
59F2  2104705A     STRB R2, [R3, #1]
96:                /* Sampling length */
97:                ADC0_REGS->ADC_SAMPCTRL = ADC_SAMPCTRL_SAMPLEN(4U);
59F4  73592104     MOVS R1, #4
59F6  31017359     STRB R1, [R3, #13]
98:            
99:                /* reference */
100:               ADC0_REGS->ADC_REFCTRL = ADC_REFCTRL_REFSEL_INTVCC2;
59F8  70993101     ADDS R1, #1
59FA  49097099     STRB R1, [R3, #2]
101:           
102:               /* positive and negative input pins */
103:               ADC0_REGS->ADC_INPUTCTRL = ADC_POSINPUT_AIN3 | ADC_NEGINPUT_GND;
59FC  81194909     LDR R1, [PC, #36]
59FE  21008119     STRH R1, [R3, #8]
104:           
105:               /* Resolution & Operation Mode */
106:               ADC0_REGS->ADC_CTRLC = ADC_CTRLC_RESSEL_12BIT | ADC_CTRLC_WINMODE(0) ;
5A00  81592100     MOVS R1, #0
5A02  21078159     STRH R1, [R3, #10]
107:           
108:           
109:               /* Clear all interrupt flags */
110:               ADC0_REGS->ADC_INTFLAG = ADC_INTFLAG_Msk;
5A04  71992107     MOVS R1, #7
5A06  715A7199     STRB R1, [R3, #6]
111:               /* Enable interrupts */
112:               ADC0_REGS->ADC_INTENSET = ADC_INTENSET_RESRDY_Msk;
5A08  3201715A     STRB R2, [R3, #5]
113:               /* Events configuration  */
114:               ADC0_REGS->ADC_EVCTRL = ADC_EVCTRL_STARTEI_Msk;
5A0A  70DA3201     ADDS R2, #1
5A0C  1A70DA     STRB R2, [R3, #3]
115:           
116:               while(ADC0_REGS->ADC_SYNCBUSY)
5A0E  8C13001A     MOVS R2, R3
5A10  B29B8C13     LDRH R3, [R2, #32]
5A12  2B00B29B     UXTH R3, R3
5A14  D1FB2B00     CMP R3, #0
5A16  4770D1FB     BNE.N 0x5A10
117:               {
118:                   /* Wait for Synchronization */
119:               }
120:           }
5A18  46C04770     BX LR
5A1A  440046C0     MOV R8, R8
5A1C  42004400     ADD R0, R0
5A1E  60204200     TST R0, R0
5A20  806020     STR R0, [R4]
5A22  18030080     LSLS R0, R0, #2
5A24  1803     ADDS R3, R0, R0
5A26  B5100000     MOVS R0, R0
121:           
122:           /* Enable ADC module */
123:           void ADC0_Enable( void )
124:           {
125:               ADC0_REGS->ADC_CTRLA |= ADC_CTRLA_ENABLE_Msk;
6390  78134A04     LDR R2, $d
6392  21027813     LDRB R3, [R2]
6394  430B2102     MOVS R1, #2
6396  7013430B     ORRS R3, R1
6398  8C137013     STRB R3, [R2]
126:               while(ADC0_REGS->ADC_SYNCBUSY)
639A  B29B8C13     LDRH R3, [R2, #32]
639C  2B00B29B     UXTH R3, R3
639E  D1FB2B00     CMP R3, #0
63A0  4770D1FB     BNE.N 0x639A
127:               {
128:                   /* Wait for Synchronization */
129:               }
130:           }
63A2  44004770     BX LR
63A4  42004400     ADD R0, R0
63A6  4A044200     TST R0, R0
131:           
132:           /* Disable ADC module */
133:           void ADC0_Disable( void )
134:           {
135:               ADC0_REGS->ADC_CTRLA &= ~ADC_CTRLA_ENABLE_Msk;
63A8  78134A04     LDR R2, $d
63AA  21027813     LDRB R3, [R2]
63AC  438B2102     MOVS R1, #2
63AE  7013438B     BICS R3, R1
63B0  8C137013     STRB R3, [R2]
136:               while(ADC0_REGS->ADC_SYNCBUSY)
63B2  B29B8C13     LDRH R3, [R2, #32]
63B4  2B00B29B     UXTH R3, R3
63B6  D1FB2B00     CMP R3, #0
63B8  4770D1FB     BNE.N 0x63B2
137:               {
138:                   /* Wait for Synchronization */
139:               }
140:           }
63BA  44004770     BX LR
63BC  42004400     ADD R0, R0
63BE  43014200     TST R0, R0
141:           
142:           /* Configure channel input */
143:           void ADC0_ChannelSelect( ADC_POSINPUT positiveInput, ADC_NEGINPUT negativeInput )
144:           {
145:               /* Configure pin scan mode and positive and negative input pins */
146:               ADC0_REGS->ADC_INPUTCTRL = positiveInput | negativeInput;
63C0  4B044301     ORRS R1, R0
63C2  81194B04     LDR R3, [PC, #16]
63C4  198119     STRH R1, [R3, #8]
147:           
148:               while((ADC0_REGS->ADC_SYNCBUSY & ADC_SYNCBUSY_INPUTCTRL_Msk) == ADC_SYNCBUSY_INPUTCTRL_Msk)
63C6  22040019     MOVS R1, R3
63C8  8C0B2204     MOVS R2, #4
63CA  42138C0B     LDRH R3, [R1, #32]
63CC  D1FC4213     TST R3, R2
63CE  4770D1FC     BNE.N 0x63CA
149:               {
150:                   /* Wait for Synchronization */
151:               }
152:           }
63D0  46C04770     BX LR
63D2  440046C0     MOV R8, R8
63D4  42004400     ADD R0, R0
63D6  43014200     TST R0, R0
153:           
154:           /* Start the ADC conversion by SW */
155:           void ADC0_ConversionStart( void )
156:           {
157:               /* Start conversion */
158:               ADC0_REGS->ADC_SWTRIG |= ADC_SWTRIG_START_Msk;
0000  20007FF8     LDRB R0, [R7, #31]
159:           
160:               while((ADC0_REGS->ADC_SYNCBUSY & ADC_SYNCBUSY_SWTRIG_Msk) == ADC_SYNCBUSY_SWTRIG_Msk)
000A  653F0000     MOVS R0, R0
0010  0000     MOVS R0, R0
161:               {
162:                   /* Wait for Synchronization */
163:               }
164:           }
0016  0000     MOVS R0, R0
165:           
166:           /* Check whether auto sequence conversion is done */
167:           bool ADC0_ConversionSequenceIsFinished(void)
168:           {
169:               bool seq_status = false;
170:               if ((ADC0_REGS->ADC_SEQSTATUS & ADC_SEQSTATUS_SEQBUSY_Msk) != ADC_SEQSTATUS_SEQBUSY_Msk)
0000  20007FF8     LDRB R0, [R7, #31]
171:               {
172:                   seq_status = true;
173:               }
174:               return seq_status;
0008  653D     STR R5, [R7, #80]
175:           }
000A  653F0000     MOVS R0, R0
176:           
177:           
178:           /* Read the conversion result */
179:           uint16_t ADC0_ConversionResultGet( void )
180:           {
181:               return (uint16_t)ADC0_REGS->ADC_RESULT;
64E0  8C984B01     LDR R3, $d
64E2  B2808C98     LDRH R0, [R3, #36]
64E4  4770B280     UXTH R0, R0
182:           }
64E6  44004770     BX LR
64E8  42004400     ADD R0, R0
64EA  4B014200     TST R0, R0
183:           
184:           /* Register callback function */
185:           void ADC0_CallbackRegister( ADC_CALLBACK callback, uintptr_t context )
186:           {
187:               ADC0_CallbackObject.callback = callback;
64EC  60184B01     LDR R3, $d
64EE  60596018     STR R0, [R3]
188:           
189:               ADC0_CallbackObject.context = context;
64F0  47706059     STR R1, [R3, #4]
190:           }
64F2  4770     BX LR
64F4  20000000     MOVS R0, R0
64F6  4B012000     MOVS R0, #0
191:           
192:           
193:           void ADC0_InterruptHandler( void )
194:           {
60FC  B083B500     PUSH {LR}
60FE  4A07B083     SUB SP, #12
195:               volatile ADC_STATUS status;
196:               status = ADC0_REGS->ADC_INTFLAG;
6100  79934A07     LDR R2, $d
6102  B2DB7993     LDRB R3, [R2, #6]
6104  9301B2DB     UXTB R3, R3
6106  23079301     STR R3, [SP, #4]
197:               /* Clear interrupt flag */
198:               ADC0_REGS->ADC_INTFLAG = ADC_INTFLAG_Msk;
6108  71932307     MOVS R3, #7
610A  4B057193     STRB R3, [R2, #6]
199:               if (ADC0_CallbackObject.callback != NULL)
610C  681B4B05     LDR R3, [PC, #20]
610E  2B00681B     LDR R3, [R3]
6110  D0032B00     CMP R3, #0
6112  9801D003     BEQ.N 0x611C
200:               {
201:                   ADC0_CallbackObject.callback(status, ADC0_CallbackObject.context);
6114  4A039801     LDR R0, [SP, #4]
6116  68514A03     LDR R2, [PC, #12]
6118  47986851     LDR R1, [R2, #4]
611A  B0034798     BLX R3
202:               }
203:           }
611C  BD00B003     ADD SP, #12
611E  4400BD00     POP {PC}
6120  42004400     ADD R0, R0
6122  4200     TST R0, R0
6124  20000000     MOVS R0, R0
6126  B5102000     MOVS R0, #0
204:           
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/interrupts.c
1:             /*******************************************************************************
2:              System Interrupts File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 interrupt.c
9:             
10:              Summary:
11:                Interrupt vectors mapping
12:            
13:              Description:
14:                This file maps all the interrupt vectors to their corresponding
15:                implementations. If a particular module interrupt is used, then its ISR
16:                definition can be found in corresponding PLIB source file. If a module
17:                interrupt is not used, then its ISR implementation is mapped to dummy
18:                handler.
19:             *******************************************************************************/
20:            
21:            // DOM-IGNORE-BEGIN
22:            /*******************************************************************************
23:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
24:            *
25:            * Subject to your compliance with these terms, you may use Microchip software
26:            * and any derivatives exclusively with Microchip products. It is your
27:            * responsibility to comply with third party license terms applicable to your
28:            * use of third party software (including open source software) that may
29:            * accompany Microchip software.
30:            *
31:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
32:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
33:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
34:            * PARTICULAR PURPOSE.
35:            *
36:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:             *******************************************************************************/
44:            // DOM-IGNORE-END
45:            
46:            // *****************************************************************************
47:            // *****************************************************************************
48:            // Section: Included Files
49:            // *****************************************************************************
50:            // *****************************************************************************
51:            
52:            #include "definitions.h"
53:            
54:            // *****************************************************************************
55:            // *****************************************************************************
56:            // Section: System Interrupt Vector Functions
57:            // *****************************************************************************
58:            // *****************************************************************************
59:            
60:            extern uint32_t _stack;
61:            
62:            /* Brief default interrupt handler for unused IRQs.*/
63:            void __attribute__((optimize("-O1"),section(".text.Dummy_Handler"),long_call))Dummy_Handler(void)
64:            {
54FA  364CE7FE     B.N Dummy_Handler
65:                while (1)
66:                {
67:                }
68:            }
69:            /* Device vectors list dummy definition*/
70:            void Reset_Handler              ( void ) __attribute__((weak, alias("Dummy_Handler")));
71:            void NonMaskableInt_Handler     ( void ) __attribute__((weak, alias("Dummy_Handler")));
72:            void HardFault_Handler          ( void ) __attribute__((weak, alias("Dummy_Handler")));
73:            void SVCall_Handler             ( void ) __attribute__((weak, alias("Dummy_Handler")));
74:            void PendSV_Handler             ( void ) __attribute__((weak, alias("Dummy_Handler")));
75:            void SysTick_Handler            ( void ) __attribute__((weak, alias("Dummy_Handler")));
76:            void SYSTEM_Handler             ( void ) __attribute__((weak, alias("Dummy_Handler")));
77:            void WDT_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
78:            void RTC_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
79:            void EIC_InterruptHandler       ( void ) __attribute__((weak, alias("Dummy_Handler")));
80:            void FREQM_Handler              ( void ) __attribute__((weak, alias("Dummy_Handler")));
81:            void TSENS_Handler              ( void ) __attribute__((weak, alias("Dummy_Handler")));
82:            void NVMCTRL_Handler            ( void ) __attribute__((weak, alias("Dummy_Handler")));
83:            void DMAC_Handler               ( void ) __attribute__((weak, alias("Dummy_Handler")));
84:            void EVSYS_Handler              ( void ) __attribute__((weak, alias("Dummy_Handler")));
85:            void SERCOM0_Handler            ( void ) __attribute__((weak, alias("Dummy_Handler")));
86:            void SERCOM1_Handler            ( void ) __attribute__((weak, alias("Dummy_Handler")));
87:            void SERCOM2_Handler            ( void ) __attribute__((weak, alias("Dummy_Handler")));
88:            void SERCOM3_Handler            ( void ) __attribute__((weak, alias("Dummy_Handler")));
89:            void SERCOM4_Handler            ( void ) __attribute__((weak, alias("Dummy_Handler")));
90:            void SERCOM5_Handler            ( void ) __attribute__((weak, alias("Dummy_Handler")));
91:            void CAN0_Handler               ( void ) __attribute__((weak, alias("Dummy_Handler")));
92:            void CAN1_Handler               ( void ) __attribute__((weak, alias("Dummy_Handler")));
93:            void TCC0_Handler               ( void ) __attribute__((weak, alias("Dummy_Handler")));
94:            void TCC1_Handler               ( void ) __attribute__((weak, alias("Dummy_Handler")));
95:            void TCC2_Handler               ( void ) __attribute__((weak, alias("Dummy_Handler")));
96:            void TC0_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
97:            void TC1_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
98:            void TC2_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
99:            void TC3_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
100:           void TC4_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
101:           void ADC0_InterruptHandler      ( void ) __attribute__((weak, alias("Dummy_Handler")));
102:           void ADC1_Handler               ( void ) __attribute__((weak, alias("Dummy_Handler")));
103:           void AC_Handler                 ( void ) __attribute__((weak, alias("Dummy_Handler")));
104:           void DAC_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
105:           void SDADC_Handler              ( void ) __attribute__((weak, alias("Dummy_Handler")));
106:           void PTC_Handler                ( void ) __attribute__((weak, alias("Dummy_Handler")));
107:           
108:           
109:           
110:           /* Mutiple handlers for vector */
111:           
112:           
113:           
114:           __attribute__ ((section(".vectors")))
115:           const DeviceVectors exception_table=
116:           {
117:               /* Configure Initial Stack Pointer, using linker-generated symbols */
118:               .pvStack = (void*) (&_stack),
119:           
120:               .pfnReset_Handler              = ( void * ) Reset_Handler,
121:               .pfnNonMaskableInt_Handler     = ( void * ) NonMaskableInt_Handler,
122:               .pfnHardFault_Handler          = ( void * ) HardFault_Handler,
123:               .pfnSVCall_Handler             = ( void * ) SVCall_Handler,
124:               .pfnPendSV_Handler             = ( void * ) PendSV_Handler,
125:               .pfnSysTick_Handler            = ( void * ) SysTick_Handler,
126:               .pfnSYSTEM_Handler             = ( void * ) SYSTEM_Handler,
127:               .pfnWDT_Handler                = ( void * ) WDT_Handler,
128:               .pfnRTC_Handler                = ( void * ) RTC_Handler,
129:               .pfnEIC_Handler                = ( void * ) EIC_InterruptHandler,
130:               .pfnFREQM_Handler              = ( void * ) FREQM_Handler,
131:               .pfnTSENS_Handler              = ( void * ) TSENS_Handler,
132:               .pfnNVMCTRL_Handler            = ( void * ) NVMCTRL_Handler,
133:               .pfnDMAC_Handler               = ( void * ) DMAC_Handler,
134:               .pfnEVSYS_Handler              = ( void * ) EVSYS_Handler,
135:               .pfnSERCOM0_Handler            = ( void * ) SERCOM0_Handler,
136:               .pfnSERCOM1_Handler            = ( void * ) SERCOM1_Handler,
137:               .pfnSERCOM2_Handler            = ( void * ) SERCOM2_Handler,
138:               .pfnSERCOM3_Handler            = ( void * ) SERCOM3_Handler,
139:               .pfnSERCOM4_Handler            = ( void * ) SERCOM4_Handler,
140:               .pfnSERCOM5_Handler            = ( void * ) SERCOM5_Handler,
141:               .pfnCAN0_Handler               = ( void * ) CAN0_Handler,
142:               .pfnCAN1_Handler               = ( void * ) CAN1_Handler,
143:               .pfnTCC0_Handler               = ( void * ) TCC0_Handler,
144:               .pfnTCC1_Handler               = ( void * ) TCC1_Handler,
145:               .pfnTCC2_Handler               = ( void * ) TCC2_Handler,
146:               .pfnTC0_Handler                = ( void * ) TC0_Handler,
147:               .pfnTC1_Handler                = ( void * ) TC1_Handler,
148:               .pfnTC2_Handler                = ( void * ) TC2_Handler,
149:               .pfnTC3_Handler                = ( void * ) TC3_Handler,
150:               .pfnTC4_Handler                = ( void * ) TC4_Handler,
151:               .pfnADC0_Handler               = ( void * ) ADC0_InterruptHandler,
152:               .pfnADC1_Handler               = ( void * ) ADC1_Handler,
153:               .pfnAC_Handler                 = ( void * ) AC_Handler,
154:               .pfnDAC_Handler                = ( void * ) DAC_Handler,
155:               .pfnSDADC_Handler              = ( void * ) SDADC_Handler,
156:               .pfnPTC_Handler                = ( void * ) PTC_Handler,
157:           
158:           
159:           };
160:           
161:           
162:           /*******************************************************************************
163:            End of File
164:           */
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/initialization.c
1:             /*******************************************************************************
2:               System Initialization File
3:             
4:               File Name:
5:                 initialization.c
6:             
7:               Summary:
8:                 This file contains source code necessary to initialize the system.
9:             
10:              Description:
11:                This file contains source code necessary to initialize the system.  It
12:                implements the "SYS_Initialize" function, defines the configuration bits,
13:                and allocates any necessary global system resources,
14:             *******************************************************************************/
15:            
16:            // DOM-IGNORE-BEGIN
17:            /*******************************************************************************
18:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
19:            *
20:            * Subject to your compliance with these terms, you may use Microchip software
21:            * and any derivatives exclusively with Microchip products. It is your
22:            * responsibility to comply with third party license terms applicable to your
23:            * use of third party software (including open source software) that may
24:            * accompany Microchip software.
25:            *
26:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
27:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
28:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
29:            * PARTICULAR PURPOSE.
30:            *
31:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
32:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
33:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
34:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
35:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
36:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
37:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
38:             *******************************************************************************/
39:            // DOM-IGNORE-END
40:            
41:            // *****************************************************************************
42:            // *****************************************************************************
43:            // Section: Included Files
44:            // *****************************************************************************
45:            // *****************************************************************************
46:            #include "definitions.h"
47:            #include "device.h"
48:            
49:            
50:            // ****************************************************************************
51:            // ****************************************************************************
52:            // Section: Configuration Bits
53:            // ****************************************************************************
54:            // ****************************************************************************
55:            
56:            
57:            // *****************************************************************************
58:            // *****************************************************************************
59:            // Section: Driver Initialization Data
60:            // *****************************************************************************
61:            // *****************************************************************************
62:            
63:            
64:            // *****************************************************************************
65:            // *****************************************************************************
66:            // Section: System Data
67:            // *****************************************************************************
68:            // *****************************************************************************
69:            // *****************************************************************************
70:            // *****************************************************************************
71:            // Section: Library/Stack Initialization Data
72:            // *****************************************************************************
73:            // *****************************************************************************
74:            
75:            
76:            // *****************************************************************************
77:            // *****************************************************************************
78:            // Section: System Initialization
79:            // *****************************************************************************
80:            // *****************************************************************************
81:            
82:            
83:            /*******************************************************************************
84:              Function:
85:                void SYS_Initialize ( void *data )
86:            
87:              Summary:
88:                Initializes the board, services, drivers, application and other modules.
89:            
90:              Remarks:
91:             */
92:            
93:            void SYS_Initialize ( void* data )
94:            {
5AC4  4B09B510     PUSH {R4, LR}
95:                PORT_Initialize();
5AC6  47984B09     LDR R3, [PC, #36]
5AC8  4B094798     BLX R3
96:            
97:                CLOCK_Initialize();
5ACA  47984B09     LDR R3, [PC, #36]
5ACC  4B094798     BLX R3
98:            
99:            
100:           
101:               SERCOM3_USART_Initialize();
5ACE  47984B09     LDR R3, [PC, #36]
5AD0  4B094798     BLX R3
102:           
103:               EVSYS_Initialize();
5AD2  47984B09     LDR R3, [PC, #36]
5AD4  4B094798     BLX R3
104:           
105:               TCC0_PWMInitialize();
5AD6  47984B09     LDR R3, [PC, #36]
5AD8  4B094798     BLX R3
106:           
107:               ADC0_Initialize();
5ADA  47984B09     LDR R3, [PC, #36]
5ADC  4B094798     BLX R3
108:               ADC1_Initialize();
5ADE  47984B09     LDR R3, [PC, #36]
5AE0  4B094798     BLX R3
109:               EIC_Initialize();
5AE2  47984B09     LDR R3, [PC, #36]
5AE4  4B094798     BLX R3
110:           
111:           
112:               NVIC_Initialize();
5AE6  47984B09     LDR R3, [PC, #36]
5AE8  BD104798     BLX R3
113:           
114:           
115:           
116:           
117:           }
5AEA  5479BD10     POP {R4, PC}
5AEC  5479     STRB R1, [R7, R1]
5AEE  45ED0000     MOVS R0, R0
5AF0  45ED     CMP SP, SP
5AF2  5E4D0000     MOVS R0, R0
5AF4  5E4D     LDRSH R5, [R1, R1]
5AF6  62C10000     MOVS R0, R0
5AF8  62C1     STR R1, [R0, #44]
5AFA  590D0000     MOVS R0, R0
5AFC  590D     LDR R5, [R1, R4]
5AFE  59CD0000     MOVS R0, R0
5B00  59CD     LDR R5, [R1, R7]
5B02  5A790000     MOVS R0, R0
5B04  5A79     LDRH R1, [R7, R1]
5B06  52ED0000     MOVS R0, R0
5B08  52ED     STRH R5, [R5, R3]
5B0A  5D110000     MOVS R0, R0
5B0C  5D11     LDRB R1, [R2, R4]
5B0E  47700000     MOVS R0, R0
118:           
119:           
120:           /*******************************************************************************
121:            End of File
122:           */
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/config/mclv2_sam_c21_pim/exceptions.c
1:             /*******************************************************************************
2:               System Exceptions File
3:             
4:               File Name:
5:                 exceptions.c
6:             
7:               Summary:
8:                 This file contains a function which overrides the default _weak_ exception
9:                 handlers provided by the interrupt.c file.
10:            
11:              Description:
12:                This file redefines the default _weak_  exception handler with a more debug
13:                friendly one. If an unexpected exception occurs the code will stop in a
14:                while(1) loop.
15:             *******************************************************************************/
16:            
17:            // DOM-IGNORE-BEGIN
18:            /*******************************************************************************
19:            * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:            *
21:            * Subject to your compliance with these terms, you may use Microchip software
22:            * and any derivatives exclusively with Microchip products. It is your
23:            * responsibility to comply with third party license terms applicable to your
24:            * use of third party software (including open source software) that may
25:            * accompany Microchip software.
26:            *
27:            * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:            * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:            * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:            * PARTICULAR PURPOSE.
31:            *
32:            * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:            * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:            * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:            * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:            * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:            * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:            * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:            *******************************************************************************/
40:            // DOM-IGNORE-END
41:            
42:            // *****************************************************************************
43:            // *****************************************************************************
44:            // Section: Included Files
45:            // *****************************************************************************
46:            // *****************************************************************************
47:            #include "definitions.h"
48:            
49:            // *****************************************************************************
50:            // *****************************************************************************
51:            // Section: Exception Handling Routine
52:            // *****************************************************************************
53:            // *****************************************************************************
54:            
55:            /* Brief default interrupt handlers for core IRQs.*/
56:            
57:            void NonMaskableInt_Handler(void)
58:            {
653C  E7FEE7FE     B.N NonMaskableInt_Handler
59:            #if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
60:                __builtin_software_breakpoint();
61:            #endif
62:                while (1)
63:                {
64:                }
65:            }
66:            
67:            void HardFault_Handler(void)
68:            {
653E  FFFFE7FE     B.N HardFault_Handler
69:            #if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
70:               __builtin_software_breakpoint();
71:            #endif
72:               while (1)
73:               {
74:               }
75:            }
76:            
77:            /*******************************************************************************
78:             End of File
79:             */
80:            
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/X2CScopeCommunication.c  -
1:             /*
2:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
3:              * All rights reserved.
4:              */
5:             /*
6:              * This file is licensed according to the BSD 3-clause license as follows:
7:              * 
8:              * Redistribution and use in source and binary forms, with or without
9:              * modification, are permitted provided that the following conditions are met:
10:             *     * Redistributions of source code must retain the above copyright
11:             *       notice, this list of conditions and the following disclaimer.
12:             *     * Redistributions in binary form must reproduce the above copyright
13:             *       notice, this list of conditions and the following disclaimer in the
14:             *       documentation and/or other materials provided with the distribution.
15:             *     * Neither the name of the "Linz Center of Mechatronics GmbH" and "LCM" nor
16:             *       the names of its contributors may be used to endorse or promote products
17:             *       derived from this software without specific prior written permission.
18:             * 
19:             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
20:             * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
21:             * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
22:             * IN NO EVENT SHALL "Linz Center of Mechatronics GmbH" BE LIABLE FOR ANY
23:             * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
24:             * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
25:             * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
26:             * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
27:             * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
28:             * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
29:             */
30:            /*
31:             * This file is part of X2C. http://www.mechatronic-simulation.org/
32:             */
33:            
34:            #include "X2CScopeCommunication.h"
35:            #include "stdbool.h"
36:            #include "definitions.h"
37:            
38:            void sendSerial(uint8_t data)
39:            {
633C  B083B500     PUSH {LR}
633E  466BB083     SUB SP, #12
6340  71D8466B     MOV R3, SP
6342  330771D8     STRB R0, [R3, #7]
6344  21013307     ADDS R3, #7
40:                SERCOM3_USART_Write(&data,1);
6346  182101     MOVS R1, #1
6348  4B020018     MOVS R0, R3
634A  47984B02     LDR R3, [PC, #8]
634C  B0034798     BLX R3
41:            }
634E  BD00B003     ADD SP, #12
6350  46C0BD00     POP {PC}
6352  5F9D46C0     MOV R8, R8
6354  5F9D     LDRSH R5, [R3, R6]
6356  28000000     MOVS R0, R0
42:            
43:            uint8_t receiveSerial()
44:            {
6254  B083B500     PUSH {LR}
6256  2101B083     SUB SP, #12
45:                uint8_t data;
46:                bool status = false;
47:                status = SERCOM3_USART_Read(&data, 1);
6258  466B2101     MOVS R1, #1
625A  1DD8466B     MOV R3, SP
625C  4B051DD8     ADDS R0, R3, #7
625E  47984B05     LDR R3, [PC, #20]
6260  23004798     BLX R3
48:                if(status == true)
6264  D0022800     CMP R0, #0
6266  466BD002     BEQ.N 0x626E
49:                {
50:                  return data;  
6268  3307466B     MOV R3, SP
626A  781B3307     ADDS R3, #7
626C  18781B     LDRB R3, [R3]
51:                }
52:                else
53:                {
54:                  return (uint8_t)(0);
6262  28002300     MOVS R3, #0
55:                }
56:            }
626E  B0030018     MOVS R0, R3
6270  BD00B003     ADD SP, #12
6272  5679BD00     POP {PC}
6274  5679     LDRSB R1, [R7, R1]
6276  22000000     MOVS R0, R0
57:            
58:            uint8_t isReceiveDataAvailable()
59:            {
6504  4B01B510     PUSH {R4, LR}
60:                return (SERCOM3_USART_ReceiverIsReady());
6506  47984B01     LDR R3, [PC, #4]
6508  BD104798     BLX R3
61:            
62:            }
650A  64B1BD10     POP {R4, PC}
650C  64B1     STR R1, [R6, #72]
650E  B5100000     MOVS R0, R0
63:            
64:            uint8_t isSendReady()
65:            {
6510  4B01B510     PUSH {R4, LR}
66:                return (SERCOM3_USART_TransmitterIsReady());
6512  47984B01     LDR R3, [PC, #4]
6514  BD104798     BLX R3
67:            }
6516  64A1BD10     POP {R4, PC}
6518  64A1     STR R1, [R4, #72]
651A  4B010000     MOVS R0, R0
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/src/X2CScope.c  --------------
1:             /*
2:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
3:              * All rights reserved.
4:              */
5:             /*
6:              * This file is licensed according to the BSD 3-clause license as follows:
7:              * 
8:              * Redistribution and use in source and binary forms, with or without
9:              * modification, are permitted provided that the following conditions are met:
10:             *     * Redistributions of source code must retain the above copyright
11:             *       notice, this list of conditions and the following disclaimer.
12:             *     * Redistributions in binary form must reproduce the above copyright
13:             *       notice, this list of conditions and the following disclaimer in the
14:             *       documentation and/or other materials provided with the distribution.
15:             *     * Neither the name of the "Linz Center of Mechatronics GmbH" and "LCM" nor
16:             *       the names of its contributors may be used to endorse or promote products
17:             *       derived from this software without specific prior written permission.
18:             * 
19:             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
20:             * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
21:             * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
22:             * IN NO EVENT SHALL "Linz Center of Mechatronics GmbH" BE LIABLE FOR ANY
23:             * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
24:             * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
25:             * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
26:             * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
27:             * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
28:             * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
29:             */
30:            /*
31:             * This file is part of X2C. http://www.mechatronic-simulation.org/
32:             */
33:            #include "X2CScopeCommunication.h"
34:            #include "X2CScope.h"
35:            
36:            void X2CScope_Init(void)
37:            {
6128  4B04B510     PUSH {R4, LR}
38:                X2CScope_HookUARTFunctions(sendSerial, receiveSerial, isReceiveDataAvailable, isSendReady);
612A  4A044B04     LDR R3, [PC, #16]
612C  49054A04     LDR R2, [PC, #16]
612E  48054905     LDR R1, [PC, #20]
6130  4C064805     LDR R0, [PC, #20]
6132  47A04C06     LDR R4, [PC, #24]
6134  4B0647A0     BLX R4
39:                X2CScope_Initialise();
6136  47984B06     LDR R3, [PC, #24]
6138  BD104798     BLX R3
40:            }
613A  6511BD10     POP {R4, PC}
613C  6511     STR R1, [R2, #80]
613E  65050000     MOVS R0, R0
6140  6505     STR R5, [R0, #80]
6142  62550000     MOVS R0, R0
6144  6255     STR R5, [R2, #36]
6146  633D0000     MOVS R0, R0
6148  633D     STR R5, [R7, #48]
614A  44A10000     MOVS R0, R0
614C  44A1     ADD R9, R4
614E  43E50000     MOVS R0, R0
6150  43E5     MVNS R5, R4
6152  4B070000     MOVS R0, R0
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/mclv2_sam_c21_pim.X/./src/packs/CMSIS/CMSIS/Core/Include/core_cm0plus.h
5D2A  601A2208     MOVS R2, #8
5D3E  4922280     MOVS R2, #128
5D16  20C04B0C     LDR R3, [PC, #48]
5D2E  581A3018     ADDS R0, #24
---  C:/harmony/harmony3/motor_control/apps/pmsm_foc_rolo_sam_c21/firmware/mclv2_sam_c21_pim.X/./src/packs/CMSIS/CMSIS/Core/Include/cmsis_gcc.h
5D14  4B0CB662     CPSIE I
5D10  8F5FF3BF     DMB SY
5D12  B6628F5F     LDRH R7, [R3, #58]
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/X2CScopeWrapper.c
1:             #include "X2CScopeWrapper.h"
2:             
3:             void X2CScope_Initialise() {
43E4  F001B570     PUSH {R4, R5, R6, LR}
4:                  //X2C
5:                 initTableStruct();
43E6  FBB9F001     BL initTableStruct
43E8  4D1DFBB9     UDIV SP, R9, SP
6:                 initSerialGeneric(&interface);
43EA  2E4D1D     LDR R5, [PC, #116]
43EC  3610002E     MOVS R6, R5
43EE  303610     ADDS R6, #16
43F0  F0010030     MOVS R0, R6
43F2  FB97F001     BL initSerialGeneric
43F4  29FB97     SDIV R0, R7, R9
7:                 initLNet(&protocol, bufferLNet, LNET_BUFFERSIZE, LNET_NODEID);
43F6  31280029     MOVS R1, R5
43F8  4C1A3128     ADDS R1, #40
43FA  34284C1A     LDR R4, [PC, #104]
43FC  23013428     ADDS R4, #40
43FE  22FF2301     MOVS R3, #1
4400  2022FF     MOVS R2, #255
4402  F7FE0020     MOVS R0, R4
4404  F8A2F7FE     BL initLNet
4406  20F8A2     STRH.W R0, [R2, #32]
8:                 initServiceTable((tProtocol*)&protocol);
4408  F7FD0020     MOVS R0, R4
440A  FEA3F7FD     BL initServiceTable
440C  20FEA3     CDP2 P0, #10, CR0, CR3, CR0, {1}
9:                 addCoreServices((tProtocol*)&protocol);
440E  F7FD0020     MOVS R0, R4
4410  FEAEF7FD     BL addCoreServices
4412  20FEAE     CDP2 P0, #10, CR0, CR14, CR0, {1}
10:                addBlockServices((tProtocol*)&protocol);
4414  F7FE0020     MOVS R0, R4
4416  FECDF7FE     BL addBlockServices
4418  20FECD     CDP2 P0, #12, CR0, CR13, CR0, {1}
11:                addExtendedBlockServices((tProtocol*)&protocol);
441A  F7FE0020     MOVS R0, R4
441C  FED8F7FE     BL addExtendedBlockServices
441E  20FED8     CDP2 P0, #13, CR0, CR8, CR0, {1}
12:                addTableStructProtocol((tProtocol*)&protocol);
4420  F0010020     MOVS R0, R4
4422  FBAFF001     BL addTableStructProtocol
4424  31FBAF     UMULL R0, R0, PC, R1
13:                linkSerial((tProtocol*)&protocol, &interface);
4426  200031     MOVS R1, R6
4428  F0010020     MOVS R0, R4
442A  FB95F001     BL linkSerial
442C  4C0EFB95     SDIV R12, R5, LR
14:                TableStruct->DSPState = PRG_LOADED_STATE;
442E  23014C0E     LDR R4, [PC, #56]
4430  68222301     MOVS R3, #1
4432  73136822     LDR R2, [R4]
4434  21017313     STRB R3, [R2, #12]
15:            
16:                initVersionInfo(TableStruct, (uint16)0x0001);
4436  102101     MOVS R1, #1
4438  F0020010     MOVS R0, R2
443A  F875F002     BL initVersionInfo
17:                TableStruct->TFncTable = blockFunctionTable;
443E  4A0A6823     LDR R3, [R4]
4440  605A4A0A     LDR R2, [PC, #40]
4442  4A0A605A     STR R2, [R3, #4]
18:                TableStruct->TParamTable = parameterIdTable;
4444  601A4A0A     LDR R2, [PC, #40]
4446  4B0A601A     STR R2, [R3]
19:                
20:                initSerial(&interface);
21:                
22:                X2C_Init();
4458  FF52F001     BL X2C_Init
445A  BD70FF52     MRC2 P13, #2, R11, CR2, CR0, {3}
23:            }
445C  46C0BD70     POP {R4, R5, R6, PC}
445E  267046C0     MOV R8, R8
4460  20002670     MOVS R6, #112
4462  27702000     MOVS R0, #0
4464  20002770     MOVS R7, #112
4466  29042000     MOVS R0, #0
4468  20002904     CMP R1, #4
446A  5D602000     MOVS R0, #0
446C  5D60     LDRB R0, [R4, R5]
446E  5D500000     MOVS R0, R0
4470  5D50     LDRB R0, [R2, R5]
4472  43A50000     MOVS R0, R0
4474  43A5     BICS R5, R4
4476  43B50000     MOVS R0, R0
4478  43B5     BICS R5, R6
447A  43C50000     MOVS R0, R0
447C  43C5     MVNS R5, R0
447E  43D50000     MOVS R0, R0
4480  43D5     MVNS R5, R2
4482  B5100000     MOVS R0, R0
24:            
25:            void X2CScope_Communicate() {
4484  4B03B510     PUSH {R4, LR}
26:                 protocol.pCommunicate((tProtocol*)&protocol);
4486  184B03     LDR R3, [PC, #12]
4488  30280018     MOVS R0, R3
448A  6A9B3028     ADDS R0, #40
448C  47986A9B     LDR R3, [R3, #40]
448E  BD104798     BLX R3
27:            }
4490  46C0BD10     POP {R4, PC}
4492  277046C0     MOV R8, R8
4494  20002770     MOVS R7, #112
4496  B5102000     MOVS R0, #0
28:            
29:            void X2CScope_Update() {
4498  F001B510     PUSH {R4, LR}
30:                X2C_Update();
449A  FF39F001     BL X2C_Update
449C  BD10FF39     MRC2 P13, #1, R11, CR9, CR0, {0}
31:            }
449E  B510BD10     POP {R4, PC}
32:            
33:            static void (*sendSerialFcn)(uint8_t);
34:            static uint8_t (*receiveSerialFcn)();
35:            static uint8_t (*isReceiveDataAvailableFcn)();
36:            static uint8_t (*isSendReadyFcn)();
37:            
38:            void X2CScope_HookUARTFunctions(void (*sendSerialFcnPntr)(uint8_t), uint8_t (*receiveSerialFcnPntr)(), 
39:                    uint8_t (*isReceiveDataAvailableFcnPntr)(), uint8_t (*isSendReadyFcnPntr)()) {
44A0  4C03B510     PUSH {R4, LR}
40:                sendSerialFcn = sendSerialFcnPntr;
44A2  60204C03     LDR R4, [PC, #12]
44A4  60616020     STR R0, [R4]
41:                receiveSerialFcn = receiveSerialFcnPntr;
44A6  60A26061     STR R1, [R4, #4]
42:                isReceiveDataAvailableFcn = isReceiveDataAvailableFcnPntr;
44A8  60E360A2     STR R2, [R4, #8]
43:                isSendReadyFcn = isSendReadyFcnPntr;
44AA  BD1060E3     STR R3, [R4, #12]
44:            }
44AC  46C0BD10     POP {R4, PC}
44AE  267046C0     MOV R8, R8
44B0  20002670     MOVS R6, #112
44B2  4B042000     MOVS R0, #0
45:            
46:            void sendSerialWrapper(tSerial* serial, uint8 data) {
43A4  4B02B510     PUSH {R4, LR}
47:                sendSerialFcn((uint8_t) data);
43A6  681B4B02     LDR R3, [PC, #8]
43A8  8681B     LDR R3, [R3]
43AA  47980008     MOVS R0, R1
43AC  BD104798     BLX R3
48:            }
43AE  2670BD10     POP {R4, PC}
43B0  20002670     MOVS R6, #112
43B2  B5102000     MOVS R0, #0
49:            
50:            uint8_t receiveSerialWrapper(tSerial* serial) {
43B4  4B02B510     PUSH {R4, LR}
51:                return (uint8) receiveSerialFcn();
43B6  685B4B02     LDR R3, [PC, #8]
43B8  4798685B     LDR R3, [R3, #4]
43BA  BD104798     BLX R3
52:            }
43BC  46C0BD10     POP {R4, PC}
43BE  267046C0     MOV R8, R8
43C0  20002670     MOVS R6, #112
43C2  B5102000     MOVS R0, #0
53:            
54:            uint8_t isReceiveDataAvailableWrapper(tSerial* serial) {
43C4  4B02B510     PUSH {R4, LR}
55:                return (uint8) isReceiveDataAvailableFcn();
43C6  689B4B02     LDR R3, [PC, #8]
43C8  4798689B     LDR R3, [R3, #8]
43CA  BD104798     BLX R3
56:            }
43CC  46C0BD10     POP {R4, PC}
43CE  267046C0     MOV R8, R8
43D0  20002670     MOVS R6, #112
43D2  B5102000     MOVS R0, #0
57:            
58:            uint8_t isSendReadyWrapper(tSerial* serial) {
43D4  4B02B510     PUSH {R4, LR}
59:                return (uint8) isSendReadyFcn();
43D6  68DB4B02     LDR R3, [PC, #8]
43D8  479868DB     LDR R3, [R3, #12]
43DA  BD104798     BLX R3
60:            }
43DC  46C0BD10     POP {R4, PC}
43DE  267046C0     MOV R8, R8
43E0  20002670     MOVS R6, #112
43E2  B5702000     MOVS R0, #0
61:            
62:            void initSerial(tSerial* serial)
63:            {
64:                serial->send = (void (*)(tInterface*, uint8))sendSerialWrapper;
4448  612B4B0A     LDR R3, [PC, #40]
44B4  60034B04     LDR R3, $d
44B6  4B046003     STR R3, [R0]
65:                serial->receive = (uint8 (*)(tInterface*))receiveSerialWrapper;
444C  616B4B0A     LDR R3, [PC, #40]
44B8  60434B04     LDR R3, [PC, #16]
44BA  4B046043     STR R3, [R0, #4]
66:                serial->isReceiveDataAvailable = (uint8 (*)(tInterface*))isReceiveDataAvailableWrapper;
4450  61AB4B0A     LDR R3, [PC, #40]
44BC  60834B04     LDR R3, [PC, #16]
44BE  4B046083     STR R3, [R0, #8]
67:                serial->isSendReady = (uint8 (*)(tInterface*))isSendReadyWrapper;
4454  61EB4B0A     LDR R3, [PC, #40]
44C0  60C34B04     LDR R3, [PC, #16]
44C2  477060C3     STR R3, [R0, #12]
68:            }
44C4  46C04770     BX LR
44C6  43A546C0     MOV R8, R8
44C8  43A5     BICS R5, R4
44CA  43B50000     MOVS R0, R0
44CC  43B5     BICS R5, R6
44CE  43C50000     MOVS R0, R0
44D0  43C5     MVNS R5, R0
44D2  43D50000     MOVS R0, R0
44D4  43D5     MVNS R5, R2
44D6  22000000     MOVS R0, R0
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/X2C.c
1:             /* This file is derived from am X2C generated file, modified for use with the X2CScope Plugin */
2:             /* This file is part of X2C. http://www.mechatronic-simulation.org/                                                   */
3:             
4:             #include "X2C.h"
5:             
6:             /**********************************************************************************************************************/
7:             /**                                              Global Variables Block                                              **/
8:             /**********************************************************************************************************************/
9:             SCOPE_MAIN                    TScope;
10:            
11:            /* Block function table                                                                                               */
12:            #define END_BLOCKFUNCTIONS { (uint16)0, (void (*)(void*))0, (void (*)(void*))0, \
13:                (uint8 (*)(void*, uint8[]))0, (uint8 (*)(void*, uint8[], uint8))0, (void* (*)(void*, uint16))0 }
14:            
15:            const tBlockFunctions blockFunctionTable[] = {
16:                FUNCTIONS,
17:                END_BLOCKFUNCTIONS
18:            };
19:            
20:            /* Parameter identifier table                                                                                         */
21:            #define END_PARAMETERTABLE { (uint16)0, (void*)0 }
22:            
23:            const tParameterTable parameterIdTable[] = {
24:                PARAMETER_TABLE,
25:                END_PARAMETERTABLE
26:            };
27:            
28:            
29:            void X2C_Init()
30:            {
6300  4802B510     PUSH {R4, LR}
31:                Scope_Main_Init(&TScope);
6302  F7FA4802     LDR R0, [PC, #8]
6304  F8E3F7FA     BL Scope_Main_Init
32:            }
6308  46C0BD10     POP {R4, PC}
630A  1D046C0     MOV R8, R8
630C  200001D0     LSLS R0, R2, #7
630E  B5102000     MOVS R0, #0
33:            
34:            void X2C_Update(void)
35:            {
6310  4802B510     PUSH {R4, LR}
36:                Scope_Main_Update(&TScope);
6312  F7FA4802     LDR R0, [PC, #8]
6314  F91AF7FA     BL Scope_Main_Update
6316  BD10F91A     LDRSB.W R11, [R10, #-16]!
37:            }
6318  46C0BD10     POP {R4, PC}
631A  1D046C0     MOV R8, R8
631C  200001D0     LSLS R0, R2, #7
631E  4A052000     MOVS R0, #0
38:            
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/VersionInfo.c
1:             /*
2:              * Initializes application version & -date.
3:              *
4:              * $LastChangedRevision: 380 $
5:              *
6:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
7:              * All rights reserved.
8:              */
9:             #include "VersionInfo.h"
10:            
11:            const struct {
12:            	uint8 date[11];
13:            	uint8 time[8];
14:            } compilationDate = { __DATE__, __TIME__ };
15:            
16:            void initVersionInfo(volatile tTableStruct* tblStruct, uint16 appVersion)
17:            {
18:            	tblStruct->framePrgVersion = appVersion;
6528  4B018401     STRH R1, [R0, #32]
19:            	tblStruct->framePrgCompDateTime = (uint8*)&compilationDate;
652A  62434B01     LDR R3, [PC, #4]
652C  47706243     STR R3, [R0, #36]
20:            }
652E  648C4770     BX LR
6530  648C     STR R4, [R1, #72]
6532  47700000     MOVS R0, R0
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/TableStruct.c
1:             /*
2:              * Table structure type definition and -functions.
3:              *
4:              * $LastChangedRevision: 443 $
5:              *
6:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
7:              * All rights reserved.
8:              */
9:             #include "TableStruct.h"
10:            
11:            #if defined(__COMPILER_CODEWARRIOR_ECLIPSE__)
12:            #pragma push
13:            #pragma section sdata_type ".ptrTableStruct" ".ptrTableStruct"
14:            extern volatile tTableStruct *TableStruct;
15:            #pragma pop
16:            #else
17:            extern volatile tTableStruct* TableStruct;
18:            #endif
19:            
20:            /* init tablestruct */
21:            void initTableStruct(void)
22:            {
23:            	uint8 i;
24:            
25:            	TableStruct->TParamTable = (tParameterTable*)0;
5B5C  68114A08     LDR R2, $d
5B5E  23006811     LDR R1, [R2]
5B60  600B2300     MOVS R3, #0
5B62  6812600B     STR R3, [R1]
26:            	TableStruct->TFncTable = (tBlockFunctions*)0;
5B64  60536812     LDR R2, [R2]
5B66  60936053     STR R3, [R2, #4]
27:            	TableStruct->TLimitSaveFncTable = (tLimitSaveFunctionTable*)0;
5B68  73136093     STR R3, [R2, #8]
28:            
29:            	TableStruct->DSPState = MONITOR_STATE;
5B6A  81D37313     STRB R3, [R2, #12]
30:            	TableStruct->eventType = (uint16)0x0000;
5B6C  611381D3     STRH R3, [R2, #14]
31:            	TableStruct->eventId = (uint32)0x00000000;
5B6E  82936113     STR R3, [R2, #16]
32:            
33:            	TableStruct->protocolCount = (uint16)0;
5B70  61938293     STRH R3, [R2, #20]
34:            	for (i = 0; i < MAX_PROTOCOLS; i++)
35:            	{
36:            		TableStruct->protocols[i] = (tProtocol*)0;
5B72  61D36193     STR R3, [R2, #24]
5B74  841361D3     STR R3, [R2, #28]
37:            	}
38:            
39:            	TableStruct->framePrgVersion = (uint16)0x0000;
5B76  62538413     STRH R3, [R2, #32]
40:            	TableStruct->framePrgCompDateTime = (uint8*)0;
5B78  62936253     STR R3, [R2, #36]
41:            
42:            	TableStruct->piScope = (SCOPE_MAIN*)0;
5B7A  62D36293     STR R3, [R2, #40]
43:            	TableStruct->dynamicCodeData = (tDynamicCodeData*)0;
5B7C  477062D3     STR R3, [R2, #44]
44:            }
5B7E  29044770     BX LR
5B80  20002904     CMP R1, #4
5B82  4B072000     MOVS R0, #0
45:            
46:            
47:            /* add tProtocol to TableStruct */
48:            void addTableStructProtocol(tProtocol* linkProtocol)
49:            {
50:            	if (TableStruct->protocolCount < MAX_PROTOCOLS)
5B84  681A4B07     LDR R3, $d
5B86  8A93681A     LDR R2, [R3]
5B88  B29B8A93     LDRH R3, [R2, #20]
5B8A  2B01B29B     UXTH R3, R3
5B8C  D9002B01     CMP R3, #1
5B8E  4770D900     BLS.N 0x5B92
51:            	{
52:            		TableStruct->protocols[TableStruct->protocolCount++] = linkProtocol;
5B92  B29B8A93     LDRH R3, [R2, #20]
5B94  1C59B29B     UXTH R3, R3
5B96  B2891C59     ADDS R1, R3, #1
5B98  8291B289     UXTH R1, R1
5B9A  33068291     STRH R1, [R2, #20]
5B9C  9B3306     ADDS R3, #6
5B9E  5098009B     LSLS R3, R3, #2
5BA0  E7F55098     STR R0, [R3, R2]
53:            	}
54:            }
5B90  8A934770     BX LR
5BA2  2904E7F5     B.N 0x5B90
5BA4  20002904     CMP R1, #4
5BA6  B5702000     MOVS R0, #0
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/Services.c
1:             /*
2:              * $LastChangedRevision: 12 $
3:              * $LastChangedDate:: 2017-03-01 18:11:38 +0100#$
4:              *
5:              * This file is part of X2C. http://www.mechatronic-simulation.org/
6:              *
7:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
8:              * All rights reserved.
9:              */
10:            #include "Services.h"
11:            
12:            /* monitor program version */
13:            #define DEVINFO_MONITOR_VERSION ((uint16)0x0005)
14:            
15:            #if defined(__GENERIC_TI_C28X__)
16:            #define DEVINFO_PROCESSOR_ID ((uint16)0x8110)
17:            #elif defined(__GENERIC_MICROCHIP_DSPIC__)
18:            #define DEVINFO_PROCESSOR_ID ((uint16)0x8210)
19:            #elif defined(__GENERIC_MICROCHIP_PIC32__)
20:            #define DEVINFO_PROCESSOR_ID ((uint16)0x8220)
21:            #elif defined(__GENERIC_MICROCHIP_PIC24__)
22:            #define DEVINFO_PROCESSOR_ID ((uint16)0x8230)
23:            #elif defined(__GENERIC_ARM_ARMV7__)
24:            #define DEVINFO_PROCESSOR_ID ((uint16)0x8310)
25:            #elif defined(__GENERIC_ARM_ARMV6__)
26:            #define DEVINFO_PROCESSOR_ID ((uint16)0x8320)
27:            #elif defined(__GENERIC_X86__)
28:            #define DEVINFO_PROCESSOR_ID ((uint16)0x8410)
29:            #elif defined(__GENERIC_X64__)
30:            #define DEVINFO_PROCESSOR_ID ((uint16)0x8420)
31:            
32:            /* TMS320F240x */
33:            #elif defined(__TMS320F2401__)
34:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0111)
35:            #elif defined(__TMS320F2402__)
36:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0112)
37:            #elif defined(__TMS320F2403__)
38:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0113)
39:            #elif defined(__TMS320F2406__)
40:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0114)
41:            #elif defined(__TMS320F2407__)
42:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0115)
43:            
44:            /* TMS320F280x */
45:            #elif defined(__TMS320F2801__)
46:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0121)
47:            #elif defined(__TMS320F2802__)
48:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0122)
49:            #elif defined(__TMS320F2806__)
50:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0123)
51:            #elif defined(__TMS320F2808__)
52:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0124)
53:            #elif defined(__TMS320F2809__)
54:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0125)
55:            
56:            /* TMS320F281x */
57:            #elif defined(__TMS320F2810__)
58:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0131)
59:            #elif defined(__TMS320F2811__)
60:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0132)
61:            #elif defined(__TMS320F2812__)
62:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0133)
63:            
64:            /* TMS320F2833x */
65:            #elif defined(__TMS320F28332__)
66:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0141)
67:            #elif defined(__TMS320F28334__)
68:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0142)
69:            #elif defined(__TMS320F28335__)
70:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0143)
71:            
72:            /* TMS320F2803x */
73:            #elif defined(__TMS320F28035__)
74:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0151)
75:            #elif defined(__TMS320F28034__)
76:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0152)
77:            
78:            /* TMS320F2806x */
79:            #elif defined(__TMS320F28069__)
80:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0161)
81:            
82:            /* TM4C */
83:            #elif defined(__TM4C123GH6__)
84:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0171)
85:            #elif defined(__TM4C123BE6__)
86:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0172)
87:            
88:            /* TMS320F2802x */
89:            #elif defined(__TMS320F28027__)
90:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0181)
91:            
92:            /* DSPIC33F */
93:            #elif defined(__DSPIC33FJ256MC710__)
94:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0221)
95:            #elif defined(__DSPIC33FJ128MC706__)
96:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0222)
97:            #elif defined(__DSPIC33FJ128MC506__)
98:            #define DEVINFO_PROCESSOR_ID ((uint16)0x0223)
99:            #elif defined(__DSPIC33FJ64GS610__)
100:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0224)
101:           #elif defined(__DSPIC33FJ64GS406__)
102:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0225)
103:           #elif defined(__DSPIC33FJ12GP202__)
104:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0226)
105:           #elif defined(__DSPIC33FJ128MC802__)
106:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0228)
107:           
108:           /* dsPIC33E */
109:           #elif defined(__DSPIC33EP256MC506__)
110:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0231)
111:           #elif defined(__DSPIC33EP128GP502__)
112:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0232)
113:           #elif defined(__DSPIC33EP32GP502__)
114:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0233)
115:           #elif defined(__DSPIC33EP256GP502__)
116:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0234)
117:           #elif defined(__DSPIC33EP256MC502__)
118:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0235)
119:           #elif defined(__DSPIC33EP128MC202__)
120:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0236)
121:           #elif defined(__DSPIC33EP128GM604__)
122:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0237)
123:           
124:           /* PIC32MZ */
125:           #elif defined(__PIC32MZ2048EC__)
126:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0241)
127:           
128:           /* PIC32MX */
129:           #elif defined(__PIC32MX170F256__)
130:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0251)
131:           
132:           /* STM32F103xx */
133:           #elif defined(__STM32F103VB__)
134:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0311)
135:           #elif defined(__STM32F103T6__)
136:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0312)
137:           #elif defined(__STM32F103V8__)
138:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0313)
139:           #elif defined(__STM32F103T4__)
140:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0314)
141:           #elif defined(__STM32F103ZC__)
142:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0315)
143:           
144:           /* STM32F101 */
145:           #elif defined(__STM32F101C4__)
146:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0321)
147:           #elif defined(__STM32F101C6__)
148:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0322)
149:           
150:           /* STM32F100 */
151:           #elif defined(__STM32F100C6__)
152:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0331)
153:           
154:           /* STM32F4 */
155:           #elif defined(__STM32F407ZG__)
156:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0341)
157:           #elif defined(__STM32F407ZE__)
158:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0342)
159:           #elif defined(__STM32F407VG__)
160:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0343)
161:           
162:           /* STM32F0 */
163:           #elif defined(__STM32F051R8__)
164:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0351)
165:           #elif defined(__STM32F051C8__)
166:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0352)
167:           
168:           #elif defined(__STM32F303RE__)
169:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0361)
170:           #elif defined(__STM32F303RB__)
171:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0362)
172:           
173:           /* MC56F8xxx */
174:           #elif defined(__MC56F8XXX__)
175:           /* mc56f8345 -> dsp id = 0x411 */
176:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0411)
177:           #elif defined(__MPC5643L__)
178:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0421)
179:           
180:           #elif defined(__RX62T__) || defined(__R5F562TA__)
181:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0511)
182:           #elif defined(__RX62G__) || defined(__R5F562GA__)
183:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0512)
184:           
185:           #elif defined(__KECONTROL__)
186:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0611)
187:           
188:           #elif defined(__XMC4800F144K2048__)
189:           #define DEVINFO_PROCESSOR_ID ((uint16)0x0711)
190:           
191:           #else
192:           #error PROCESSOR TYPE NOT DEFINED
193:           #endif
194:           
195:           /* service table definition */
196:           static tSERVICE_Table serviceTable;
197:           
198:           #if defined(__COMPILER_CODEWARRIOR_ECLIPSE__)
199:           #pragma push
200:           #pragma section sdata_type ".ptrTableStruct" ".ptrTableStruct"
201:           extern volatile tTableStruct *TableStruct;
202:           #pragma pop
203:           #else
204:           extern volatile tTableStruct* TableStruct;
205:           #endif
206:           
207:           /* private prototypes */
208:           static void getDeviceInfo(tProtocol* protocol);
209:           static void getTargetState(tProtocol* protocol);
210:           static void setTargetState(tProtocol* protocol);
211:           static void loadParameter(tProtocol* protocol);
212:           static void saveParameter(tProtocol* protocol);
213:           static void* getBlockAddress(const tParameterTable* paramTable, uint16 paramId, uint8* error);
214:           
215:           /* send service not available error */
216:           void sendSvNotAvailable(tProtocol* protocol)
217:           {
1D00  2302B510     PUSH {R4, LR}
218:           	protocol->ucFRAMESize = 2;
1D02  72032302     MOVS R3, #2
1D04  331F7203     STRB R3, [R0, #8]
219:           	protocol->ucFRAMEData[1] = ERRORServiceNotAvail;
1D06  68C2331F     ADDS R3, #31
1D08  705368C2     LDR R2, [R0, #12]
1D0A  68437053     STRB R3, [R2, #1]
220:           	protocol->pSnd_Enable((struct tProtocol*)protocol);
1D0C  47986843     LDR R3, [R0, #4]
1D0E  BD104798     BLX R3
221:           }
1D10  B510BD10     POP {R4, PC}
222:           
223:           /* send error */
224:           void sendError(tProtocol* protocol, uint8 ucErrorNr)
225:           {
1DE6  2302B510     PUSH {R4, LR}
226:           	protocol->ucFRAMESize = 2;
1DE8  72032302     MOVS R3, #2
1DEA  68C37203     STRB R3, [R0, #8]
227:           	protocol->ucFRAMEData[1] = ucErrorNr;
1DEC  705968C3     LDR R3, [R0, #12]
1DEE  68437059     STRB R1, [R3, #1]
228:           	protocol->pSnd_Enable((struct tProtocol*)protocol);
1DF0  47986843     LDR R3, [R0, #4]
1DF2  BD104798     BLX R3
229:           }
1DF4  B5F0BD10     POP {R4, PC}
230:           
231:           /*
232:            * Returns target device information.
233:            */
234:           static void getDeviceInfo(tProtocol* protocol)
235:           {
1FD0  7A43B510     PUSH {R4, LR}
236:           	uint8 i;
237:           	uint32 tableStructAddr;
238:           
239:           	/* check frame buffer length */
240:           	if (protocol->ucMaxCommSize < 46)
1FD2  2B2D7A43     LDRB R3, [R0, #9]
1FD4  D8002B2D     CMP R3, #45
1FD6  E0AED800     BHI.N 0x1FDA
1FD8  232EE0AE     B.N 0x2138
241:           	{
242:           		sendError(protocol, ERRORSizeTooLarge);
2138  F7FF2115     MOVS R1, #21
213A  FE54F7FF     BL sendError
213C  E7FAFE54     MRC2 P7, #2, LR, CR4, CR10, {7}
243:           		return;
213E  2322E7FA     B.N .LVL87
2140  322D2322     MOVS R3, #34
244:           	}
245:           
246:           	protocol->ucFRAMESize = 46;
1FDA  7203232E     MOVS R3, #46
1FDC  23007203     STRB R3, [R0, #8]
247:           	protocol->ucFRAMEData[1] = ERRORSuccess;
1FDE  68C22300     MOVS R3, #0
1FE0  705368C2     LDR R2, [R0, #12]
1FE2  22057053     STRB R3, [R2, #1]
248:           
249:           	/* monitor program version */
250:           	protocol->ucFRAMEData[2] = (uint8)(DEVINFO_MONITOR_VERSION & 0x00FF);
1FE4  68C12205     MOVS R2, #5
1FE6  708A68C1     LDR R1, [R0, #12]
1FE8  68C2708A     STRB R2, [R1, #2]
251:           	protocol->ucFRAMEData[3] = (uint8)(DEVINFO_MONITOR_VERSION >> 8);
1FEA  70D368C2     LDR R2, [R0, #12]
1FEC  4B5870D3     STRB R3, [R2, #3]
252:           
253:           	/* frame program version */
254:           	protocol->ucFRAMEData[4] = \
255:           			(uint8)(TableStruct->framePrgVersion & (uint16)0x00FF);
1FEE  681B4B58     LDR R3, [PC, #352]
1FF0  8C1A681B     LDR R3, [R3]
1FF2  68C18C1A     LDRH R2, [R3, #32]
1FF4  710A68C1     LDR R1, [R0, #12]
1FF6  8C1A710A     STRB R2, [R1, #4]
256:           	protocol->ucFRAMEData[5] = (uint8)(TableStruct->framePrgVersion >> 8);
1FF8  A128C1A     LDRH R2, [R3, #32]
1FFA  68C10A12     LSRS R2, R2, #8
1FFC  714A68C1     LDR R1, [R0, #12]
1FFE  7A42714A     STRB R2, [R1, #5]
257:           
258:           	/* max comm size */
259:           	protocol->ucFRAMEData[6] = protocol->ucMaxCommSize;
2000  68C17A42     LDRB R2, [R0, #9]
2002  718A68C1     LDR R1, [R0, #12]
2004  2220718A     STRB R2, [R1, #6]
260:           
261:           	protocol->ucFRAMEData[7] = (uint8)(DEVINFO_PROCESSOR_ID & 0x00FF);
2006  68C12220     MOVS R2, #32
2008  71CA68C1     LDR R1, [R0, #12]
200A  218271CA     STRB R2, [R1, #7]
262:           	protocol->ucFRAMEData[8] = (uint8)(DEVINFO_PROCESSOR_ID >> 8);
200C  68C42182     MOVS R1, #130
200E  722168C4     LDR R4, [R0, #12]
2010  39387221     STRB R1, [R4, #8]
263:           
264:           	/* monitor program compilation date as ASCII string */
265:           	/* 9 ... 11 -> first 3 letters of month (e.g. Oct, Dec) */
266:           	/* 12 ... 13 -> day as DD */
267:           	/* 14 ... 17 -> year as YYYY */
268:           	protocol->ucFRAMEData[9] = __DATE__[0];
2012  68C43938     SUBS R1, #56
2014  726168C4     LDR R4, [R0, #12]
2016  31177261     STRB R1, [R4, #9]
269:           	protocol->ucFRAMEData[10] = __DATE__[1];
2018  68C43117     ADDS R1, #23
201A  72A168C4     LDR R4, [R0, #12]
201C  310D72A1     STRB R1, [R4, #10]
270:           	protocol->ucFRAMEData[11] = __DATE__[2];
201E  68C4310D     ADDS R1, #13
2020  72E168C4     LDR R4, [R0, #12]
2022  68C172E1     STRB R1, [R4, #11]
271:           	protocol->ucFRAMEData[12] = __DATE__[4];
2024  730A68C1     LDR R1, [R0, #12]
2026  3213730A     STRB R2, [R1, #12]
272:           	protocol->ucFRAMEData[13] = __DATE__[5];
2028  68C13213     ADDS R2, #19
202A  734A68C1     LDR R1, [R0, #12]
202C  3A01734A     STRB R2, [R1, #13]
273:           	protocol->ucFRAMEData[14] = __DATE__[7];
202E  68C13A01     SUBS R2, #1
2030  738A68C1     LDR R1, [R0, #12]
2032  3A02738A     STRB R2, [R1, #14]
274:           	protocol->ucFRAMEData[15] = __DATE__[8];
2034  68C13A02     SUBS R2, #2
2036  73CA68C1     LDR R1, [R0, #12]
2038  213173CA     STRB R2, [R1, #15]
275:           	protocol->ucFRAMEData[16] = __DATE__[9];
203A  68C42131     MOVS R1, #49
203C  742168C4     LDR R4, [R0, #12]
203E  31087421     STRB R1, [R4, #16]
276:           	protocol->ucFRAMEData[17] = __DATE__[10];
2040  68C43108     ADDS R1, #8
2042  746168C4     LDR R4, [R0, #12]
2044  68C17461     STRB R1, [R4, #17]
277:           
278:           	/* monitor program compilation time as ASCII string */
279:           	/* 18 ... 19 -> hour as HH */
280:           	/* 20 ... 21 -> minute as MM */
281:           	protocol->ucFRAMEData[18] = __TIME__[0];
2046  748A68C1     LDR R1, [R0, #12]
2048  68C1748A     STRB R2, [R1, #18]
282:           	protocol->ucFRAMEData[19] = __TIME__[1];
204A  74CA68C1     LDR R1, [R0, #12]
204C  320474CA     STRB R2, [R1, #19]
283:           	protocol->ucFRAMEData[20] = __TIME__[3];
204E  68C13204     ADDS R2, #4
2050  750A68C1     LDR R1, [R0, #12]
2052  3204750A     STRB R2, [R1, #20]
284:           	protocol->ucFRAMEData[21] = __TIME__[4];
2054  68C13204     ADDS R2, #4
2056  754A68C1     LDR R1, [R0, #12]
2058  6A5A754A     STRB R2, [R1, #21]
285:           
286:           	if (TableStruct->framePrgCompDateTime == 0)
205A  2A006A5A     LDR R2, [R3, #36]
205C  D1002A00     CMP R2, #0
205E  E06ED100     BNE.N 0x2062
2060  6A5AE06E     B.N 0x2140
287:           	{
288:           		i = 12;
289:           		do
290:           		{
291:           			protocol->ucFRAMEData[22+i] = '-';
2142  68C1322D     ADDS R2, #45
2144  54CA68C1     LDR R1, [R0, #12]
2146  3B0154CA     STRB R2, [R1, R3]
2148  2B153B01     SUBS R3, #1
292:           		} while (i-- > 0);
214A  D1FA2B15     CMP R3, #21
214C  E7BFD1FA     BNE.N 0x2144
214E  2904E7BF     B.N 0x20D0
2150  20002904     CMP R1, #4
2152  4B042000     MOVS R0, #0
293:           	}
294:           	else
295:           	{
296:           		/* frame program compilation date as ASCII string */
297:           		/* 22 ... 24 -> first 3 letters of month (e.g. Oct, Dec) */
298:           		/* 25 ... 26 -> day as DD */
299:           		/* 27 ... 30 -> year as YYYY */
300:           		/* frame program compilation time as ASCII string */
301:           		/* 31 ... 32 -> hour as HH */
302:           		/* 23 ... 24 -> minute as MM */
303:           		protocol->ucFRAMEData[22] = TableStruct->framePrgCompDateTime[0];
2062  78126A5A     LDR R2, [R3, #36]
2064  68C17812     LDRB R2, [R2]
2066  758A68C1     LDR R1, [R0, #12]
2068  6A5A758A     STRB R2, [R1, #22]
304:           		protocol->ucFRAMEData[23] = TableStruct->framePrgCompDateTime[1];
206A  78526A5A     LDR R2, [R3, #36]
206C  68C17852     LDRB R2, [R2, #1]
206E  75CA68C1     LDR R1, [R0, #12]
2070  6A5A75CA     STRB R2, [R1, #23]
305:           		protocol->ucFRAMEData[24] = TableStruct->framePrgCompDateTime[2];
2072  78926A5A     LDR R2, [R3, #36]
2074  68C17892     LDRB R2, [R2, #2]
2076  760A68C1     LDR R1, [R0, #12]
2078  6A5A760A     STRB R2, [R1, #24]
306:           		protocol->ucFRAMEData[25] = TableStruct->framePrgCompDateTime[4];
207A  79126A5A     LDR R2, [R3, #36]
207C  68C17912     LDRB R2, [R2, #4]
207E  764A68C1     LDR R1, [R0, #12]
2080  6A5A764A     STRB R2, [R1, #25]
307:           		protocol->ucFRAMEData[26] = TableStruct->framePrgCompDateTime[5];
2082  79526A5A     LDR R2, [R3, #36]
2084  68C17952     LDRB R2, [R2, #5]
2086  768A68C1     LDR R1, [R0, #12]
2088  6A5A768A     STRB R2, [R1, #26]
308:           		protocol->ucFRAMEData[27] = TableStruct->framePrgCompDateTime[7];
208A  79D26A5A     LDR R2, [R3, #36]
208C  68C179D2     LDRB R2, [R2, #7]
208E  76CA68C1     LDR R1, [R0, #12]
2090  6A5A76CA     STRB R2, [R1, #27]
309:           		protocol->ucFRAMEData[28] = TableStruct->framePrgCompDateTime[8];
2092  7A126A5A     LDR R2, [R3, #36]
2094  68C17A12     LDRB R2, [R2, #8]
2096  770A68C1     LDR R1, [R0, #12]
2098  6A5A770A     STRB R2, [R1, #28]
310:           		protocol->ucFRAMEData[29] = TableStruct->framePrgCompDateTime[9];
209A  7A526A5A     LDR R2, [R3, #36]
209C  68C17A52     LDRB R2, [R2, #9]
209E  774A68C1     LDR R1, [R0, #12]
20A0  6A5A774A     STRB R2, [R1, #29]
311:           		protocol->ucFRAMEData[30] = TableStruct->framePrgCompDateTime[10];
20A2  7A926A5A     LDR R2, [R3, #36]
20A4  68C17A92     LDRB R2, [R2, #10]
20A6  778A68C1     LDR R1, [R0, #12]
20A8  6A5A778A     STRB R2, [R1, #30]
312:           		protocol->ucFRAMEData[31] = TableStruct->framePrgCompDateTime[11];
20AA  7AD26A5A     LDR R2, [R3, #36]
20AC  68C17AD2     LDRB R2, [R2, #11]
20AE  77CA68C1     LDR R1, [R0, #12]
20B0  6A5A77CA     STRB R2, [R1, #31]
313:           		protocol->ucFRAMEData[32] = TableStruct->framePrgCompDateTime[12];
20B2  7B116A5A     LDR R2, [R3, #36]
20B4  22207B11     LDRB R1, [R2, #12]
20B6  68C42220     MOVS R2, #32
20B8  54A168C4     LDR R4, [R0, #12]
20BA  6A5A54A1     STRB R1, [R4, R2]
314:           		protocol->ucFRAMEData[33] = TableStruct->framePrgCompDateTime[14];
20BC  7B916A5A     LDR R2, [R3, #36]
20BE  22217B91     LDRB R1, [R2, #14]
20C0  68C42221     MOVS R2, #33
20C2  54A168C4     LDR R4, [R0, #12]
20C4  6A5B54A1     STRB R1, [R4, R2]
315:           		protocol->ucFRAMEData[34] = TableStruct->framePrgCompDateTime[15];
20C6  7BDA6A5B     LDR R3, [R3, #36]
20C8  23227BDA     LDRB R2, [R3, #15]
20CA  68C12322     MOVS R3, #34
20CC  54CA68C1     LDR R1, [R0, #12]
20CE  4B1F54CA     STRB R2, [R1, R3]
316:           	}
317:           
318:           	protocol->ucFRAMEData[35] = (uint8)(TableStruct->DSPState & 0x00FF);
20D0  681B4B1F     LDR R3, $d
20D2  7B19681B     LDR R3, [R3]
20D4  22237B19     LDRB R1, [R3, #12]
20D6  68C42223     MOVS R2, #35
20D8  54A168C4     LDR R4, [R0, #12]
20DA  89D954A1     STRB R1, [R4, R2]
319:           	protocol->ucFRAMEData[36] = (uint8)(TableStruct->eventType & 0x00FF);
20DC  320189D9     LDRH R1, [R3, #14]
20DE  68C43201     ADDS R2, #1
20E0  54A168C4     LDR R4, [R0, #12]
20E2  89DA54A1     STRB R1, [R4, R2]
320:           	protocol->ucFRAMEData[37] = (uint8)(TableStruct->eventType >> 8);
20E4  A1289DA     LDRH R2, [R3, #14]
20E6  21250A12     LSRS R2, R2, #8
20E8  68C42125     MOVS R1, #37
20EA  546268C4     LDR R4, [R0, #12]
20EC  69195462     STRB R2, [R4, R1]
321:           	protocol->ucFRAMEData[38] = (uint8)(TableStruct->eventId & 0x00FF);
20EE  22266919     LDR R1, [R3, #16]
20F0  68C42226     MOVS R2, #38
20F2  54A168C4     LDR R4, [R0, #12]
20F4  691A54A1     STRB R1, [R4, R2]
322:           	protocol->ucFRAMEData[39] = (uint8)(TableStruct->eventId >> 8);
20F6  A12691A     LDR R2, [R3, #16]
20F8  21270A12     LSRS R2, R2, #8
20FA  68C42127     MOVS R1, #39
20FC  546268C4     LDR R4, [R0, #12]
20FE  691A5462     STRB R2, [R4, R1]
323:           	protocol->ucFRAMEData[40] = (uint8)(TableStruct->eventId >> 16);
2100  C12691A     LDR R2, [R3, #16]
2102  31010C12     LSRS R2, R2, #16
2104  68C43101     ADDS R1, #1
2106  546268C4     LDR R4, [R0, #12]
2108  691A5462     STRB R2, [R4, R1]
324:           	protocol->ucFRAMEData[41] = (uint8)(TableStruct->eventId >> 24);
210A  E12691A     LDR R2, [R3, #16]
210C  31010E12     LSRS R2, R2, #24
210E  68C43101     ADDS R1, #1
2110  546268C4     LDR R4, [R0, #12]
2112  222A5462     STRB R2, [R4, R1]
325:           
326:           	tableStructAddr = (uint32)TableStruct;
327:           	protocol->ucFRAMEData[42] = (uint8)(tableStructAddr & 0xFF);
2114  68C1222A     MOVS R2, #42
2116  548B68C1     LDR R1, [R0, #12]
2118  A19548B     STRB R3, [R1, R2]
328:           	protocol->ucFRAMEData[43] = (uint8)((tableStructAddr >> 8) & 0xFF);
211A  32010A19     LSRS R1, R3, #8
211C  68C43201     ADDS R2, #1
211E  54A168C4     LDR R4, [R0, #12]
2120  C1954A1     STRB R1, [R4, R2]
329:           	protocol->ucFRAMEData[44] = (uint8)((tableStructAddr >> 16) & 0xFF);
2122  32010C19     LSRS R1, R3, #16
2124  68C43201     ADDS R2, #1
2126  54A168C4     LDR R4, [R0, #12]
2128  E1B54A1     STRB R1, [R4, R2]
330:           	protocol->ucFRAMEData[45] = (uint8)((tableStructAddr >> 24) & 0xFF);
212A  32010E1B     LSRS R3, R3, #24
212C  68C13201     ADDS R2, #1
212E  548B68C1     LDR R1, [R0, #12]
2130  6843548B     STRB R3, [R1, R2]
331:           
332:           	protocol->pSnd_Enable((struct tProtocol*)protocol);
2132  47986843     LDR R3, [R0, #4]
2134  BD104798     BLX R3
333:           }
2136  2115BD10     POP {R4, PC}
2138  F7FF2115     MOVS R1, #21
213A  FE54F7FF     BL sendError
213C  E7FAFE54     MRC2 P7, #2, LR, CR4, CR10, {7}
213E  2322E7FA     B.N .LVL87
2140  322D2322     MOVS R3, #34
2142  68C1322D     ADDS R2, #45
2144  54CA68C1     LDR R1, [R0, #12]
2146  3B0154CA     STRB R2, [R1, R3]
2148  2B153B01     SUBS R3, #1
214A  D1FA2B15     CMP R3, #21
214C  E7BFD1FA     BNE.N 0x2144
214E  2904E7BF     B.N 0x20D0
2150  20002904     CMP R1, #4
2152  4B042000     MOVS R0, #0
334:           
335:           /*
336:            * Saves block data by parameter identifier.
337:            */
338:           static void saveParameter(tProtocol* protocol)
339:           {
1EA8  B083B5F0     PUSH {R4, R5, R6, R7, LR}
1EAA  4B083     SUB SP, #12
1EAC  68C20004     MOVS R4, R0
340:           	uint16 blockId, paramId;
341:           	uint16 i;
342:           	uint8 error;
343:           	void* blockAddr;
344:           
345:           	/* get parameter id from frame */
346:           	paramId = (uint16)((protocol->ucFRAMEData[2]<<8) + protocol->ucFRAMEData[1]);
1EAE  789368C2     LDR R2, [R0, #12]
1EB0  21B7893     LDRB R3, [R2, #2]
1EB2  7856021B     LSLS R3, R3, #8
1EB4  18F67856     LDRB R6, [R2, #1]
1EB6  B2B618F6     ADDS R6, R6, R3
1EB8  4B44B2B6     UXTH R6, R6
347:           
348:           	blockAddr = getBlockAddress(TableStruct->TParamTable, paramId, &error);
1EBA  681B4B44     LDR R3, [PC, #272]
1EBC  6818681B     LDR R3, [R3]
1EBE  466B6818     LDR R0, [R3]
1EC0  1DDD466B     MOV R3, SP
1EC2  2A1DDD     ADDS R5, R3, #7
1EC4  31002A     MOVS R2, R5
1EC6  F7FF0031     MOVS R1, R6
1EC8  FF6CF7FF     BL .LFE6, .LFB9
1ECA  7829FF6C     CDP2 P8, #6, CR7, CR12, CR9, {1}
349:           	if (error != ERRORSuccess)
1ECC  29007829     LDRB R1, [R5]
1ECE  D1402900     CMP R1, #0
1ED0  4B3ED140     BNE.N 0x1E54
350:           	{
351:           		sendError(protocol, error);
1F54  F7FF0020     MOVS R0, R4
1F56  FF46F7FF     BL sendError
1F58  B003FF46     CDP2 P0, #4, CR11, CR6, CR3, {0}
352:           		return;
353:           	}
354:           
355:           
356:           	/* try to execute limit-save function if limit-save function table is initialized */
357:           	if (TableStruct->TLimitSaveFncTable != 0)
1ED2  68194B3E     LDR R3, [PC, #248]
1ED4  688B6819     LDR R1, [R3]
1ED6  2B00688B     LDR R3, [R1, #8]
1ED8  D0172B00     CMP R3, #0
1EDA  688BD017     BEQ.N 0x1F0C
358:           	{
359:           		/* look if parameter id has limit function */
360:           		i = 0;
361:           		while ((paramId != (TableStruct->TLimitSaveFncTable)[i].uiParID) && \
1EDC  881B688B     LDR R3, [R1, #8]
1EDE  42B3881B     LDRH R3, [R3]
1EE0  D03C42B3     CMP R3, R6
1EE2  688BD03C     BEQ.N 0x1F5E
1EE6  2B00881B     LDRH R3, [R3]
1EE8  D03A2B00     CMP R3, #0
1EEA  2300D03A     BEQ.N 0x1F62
1EEC  33012300     MOVS R3, #0
1EF2  DD688A     LDR R2, [R1, #8]
1EF4  5B5200DD     LSLS R5, R3, #3
1EF6  42B25B52     LDRH R2, [R2, R5]
1EF8  D00342B2     CMP R2, R6
1EFA  688AD003     BEQ.N 0x1F04
1EFE  2A005B52     LDRH R2, [R2, R5]
1F00  D1F42A00     CMP R2, #0
1F02  688BD1F4     BNE.N 0x1EEE
1F5E  E7D02500     MOVS R5, #0
1F60  2500E7D0     B.N 0x1F04
1F62  E7CE2500     MOVS R5, #0
1F64  688BE7CE     B.N 0x1F04
362:           				((TableStruct->TLimitSaveFncTable)[i].uiParID != 0))
1EE4  881B688B     LDR R3, [R1, #8]
1EFC  5B52688A     LDR R2, [R1, #8]
363:           		{
364:           			i++;
1EEE  B29B3301     ADDS R3, #1
1EF0  688AB29B     UXTH R3, R3
365:           		}
366:           
367:           		if ((TableStruct->TLimitSaveFncTable)[i].uiParID != 0)
1F04  5B5B688B     LDR R3, [R1, #8]
1F06  2B005B5B     LDRH R3, [R3, R5]
1F08  D12C2B00     CMP R3, #0
1F0A  684BD12C     BNE.N 0x1F66
368:           		{
369:           			/* if limit-save function fails -> send error */
370:           			if ((TableStruct->TLimitSaveFncTable)[i].pFLimitSave(blockAddr, protocol->ucFRAMEData+3, protocol->ucFRAMESize-3) != 0)
1F66  7A22688B     LDR R3, [R1, #8]
1F68  3A037A22     LDRB R2, [R4, #8]
1F6A  B2D23A03     SUBS R2, #3
1F6C  68E1B2D2     UXTB R2, R2
1F6E  310368E1     LDR R1, [R4, #12]
1F70  195D3103     ADDS R1, #3
1F72  686B195D     ADDS R5, R3, R5
1F74  4798686B     LDR R3, [R5, #4]
1F76  28004798     BLX R3
1F78  D0EE2800     CMP R0, #0
1F7A  2142D0EE     BEQ.N .LVL67
371:           			{
372:           				sendError(protocol, ERRORParLimit);
1F7C  202142     MOVS R1, #66
1F7E  F7FF0020     MOVS R0, R4
1F80  FF31F7FF     BL sendError
1F82  E7E9FF31     CDP2 P7, #3, CR14, CR1, CR9, {7}
1F84  2144E7E9     B.N .LVL67
373:           			}
374:           			return;
375:           		}
376:           	}
377:           
378:           	if (TableStruct->TFncTable == 0)
1F0C  2B00684B     LDR R3, [R1, #4]
1F0E  D0392B00     CMP R3, #0
1F10  8807D039     BEQ.N 0x1F86
379:           	{
380:           		sendError(protocol, SvErrorFncTableNotInit);
1F86  202144     MOVS R1, #68
1F88  F7FF0020     MOVS R0, R4
1F8A  FF2CF7FF     BL sendError
1F8C  E7E4FF2C     CDP2 P7, #2, CR14, CR12, CR4, {7}
381:           		return;
1F8E  2600E7E4     B.N .LVL67
382:           	}
383:           
384:           	/* get block identifier */
385:           	blockId = *(uint16*)blockAddr;
1F12  684B8807     LDRH R7, [R0]
386:           
387:           	i = 0;
388:           	while ((blockId != (TableStruct->TFncTable)[i].iBlockID) && ((TableStruct->TFncTable)[i].iBlockID != 0))
1F14  881B684B     LDR R3, [R1, #4]
1F16  42BB881B     LDRH R3, [R3]
1F18  D03942BB     CMP R3, R7
1F1A  684BD039     BEQ.N 0x1F90
1F1C  881B684B     LDR R3, [R1, #4]
1F1E  2B00881B     LDRH R3, [R3]
1F20  D0372B00     CMP R3, #0
1F22  2200D037     BEQ.N 0x1F94
1F24  32012200     MOVS R2, #0
1F2A  53684D     LDR R5, [R1, #4]
1F2C  189B0053     LSLS R3, R2, #1
1F2E  DB189B     ADDS R3, R3, R2
1F30  1E00DB     LSLS R3, R3, #3
1F32  5AED001E     MOVS R6, R3
1F34  42BD5AED     LDRH R5, [R5, R3]
1F36  D00342BD     CMP R5, R7
1F38  684DD003     BEQ.N 0x1F42
1F3A  5AEB684D     LDR R5, [R1, #4]
1F3C  2B005AEB     LDRH R3, [R5, R3]
1F3E  D1F12B00     CMP R3, #0
1F40  684BD1F1     BNE.N 0x1F26
1F90  E7D62600     MOVS R6, #0
1F92  2600E7D6     B.N 0x1F42
1F94  E7D42600     MOVS R6, #0
1F96  684BE7D4     B.N 0x1F42
389:           	{
390:           		i++;
1F26  B2923201     ADDS R2, #1
1F28  684DB292     UXTH R2, R2
391:           	}
392:           	/* check if Block ID can be found in function table */
393:           	if ((TableStruct->TFncTable)[i].iBlockID == 0)
1F42  5B9B684B     LDR R3, [R1, #4]
1F44  2B005B9B     LDRH R3, [R3, R6]
1F46  D1262B00     CMP R3, #0
1F48  2141D126     BNE.N 0x1F98
394:           	{
395:           		sendError(protocol, ERRORBlkID);
1F4A  202141     MOVS R1, #65
1F4C  F7FF0020     MOVS R0, R4
1F4E  FF4AF7FF     BL sendError
1F50  E002FF4A     CDP2 P0, #4, CR14, CR10, CR2, {0}
396:           		return;
1F52  20E002     B.N .LVL67
397:           	}
398:           
399:           	/* if default save function fails -> send error */
400:           	if ((TableStruct->TFncTable)[i].pFSave(blockAddr, protocol->ucFRAMEData+3, protocol->ucFRAMESize-3))
1F98  7A22684B     LDR R3, [R1, #4]
1F9A  3A037A22     LDRB R2, [R4, #8]
1F9C  B2D23A03     SUBS R2, #3
1F9E  68E1B2D2     UXTB R2, R2
1FA0  310368E1     LDR R1, [R4, #12]
1FA2  199E3103     ADDS R1, #3
1FA4  6933199E     ADDS R6, R3, R6
1FA6  47986933     LDR R3, [R6, #16]
1FA8  28004798     BLX R3
1FAA  D0042800     CMP R0, #0
1FAC  2114D004     BEQ.N 0x1FB8
401:           	{
402:           		sendError(protocol, ERRORFormat);
1FAE  202114     MOVS R1, #20
1FB0  F7FF0020     MOVS R0, R4
1FB2  FF18F7FF     BL sendError
1FB4  E7D0FF18     MRC2 P7, #0, LR, CR8, CR0, {6}
403:           		return;
1FB6  2302E7D0     B.N .LVL67
404:           	}
405:           
406:           	protocol->ucFRAMESize = 2;
1FB8  72232302     MOVS R3, #2
1FBA  23007223     STRB R3, [R4, #8]
407:           	protocol->ucFRAMEData[1] = ERRORSuccess;
1FBC  68E22300     MOVS R3, #0
1FBE  705368E2     LDR R2, [R4, #12]
1FC0  68637053     STRB R3, [R2, #1]
408:           	protocol->pSnd_Enable((struct tProtocol*)protocol);
1FC2  206863     LDR R3, [R4, #4]
1FC4  47980020     MOVS R0, R4
1FC6  E7C74798     BLX R3
1FC8  46C0E7C7     B.N .LVL67
1FCA  290446C0     MOV R8, R8
1FCC  20002904     CMP R1, #4
1FCE  B5102000     MOVS R0, #0
409:           }
1F5A  BDF0B003     ADD SP, #12
1F5C  2500BDF0     POP {R4, R5, R6, R7, PC}
1F5E  E7D02500     MOVS R5, #0
1F60  2500E7D0     B.N 0x1F04
1F62  E7CE2500     MOVS R5, #0
1F64  688BE7CE     B.N 0x1F04
1F66  7A22688B     LDR R3, [R1, #8]
1F68  3A037A22     LDRB R2, [R4, #8]
1F6A  B2D23A03     SUBS R2, #3
1F6C  68E1B2D2     UXTB R2, R2
1F6E  310368E1     LDR R1, [R4, #12]
1F70  195D3103     ADDS R1, #3
1F72  686B195D     ADDS R5, R3, R5
1F74  4798686B     LDR R3, [R5, #4]
1F76  28004798     BLX R3
1F78  D0EE2800     CMP R0, #0
1F7A  2142D0EE     BEQ.N .LVL67
1F7C  202142     MOVS R1, #66
1F7E  F7FF0020     MOVS R0, R4
1F80  FF31F7FF     BL sendError
1F82  E7E9FF31     CDP2 P7, #3, CR14, CR1, CR9, {7}
1F84  2144E7E9     B.N .LVL67
1F86  202144     MOVS R1, #68
1F88  F7FF0020     MOVS R0, R4
1F8A  FF2CF7FF     BL sendError
1F8C  E7E4FF2C     CDP2 P7, #2, CR14, CR12, CR4, {7}
1F8E  2600E7E4     B.N .LVL67
1F90  E7D62600     MOVS R6, #0
1F92  2600E7D6     B.N 0x1F42
1F94  E7D42600     MOVS R6, #0
1F96  684BE7D4     B.N 0x1F42
1F98  7A22684B     LDR R3, [R1, #4]
1F9A  3A037A22     LDRB R2, [R4, #8]
1F9C  B2D23A03     SUBS R2, #3
1F9E  68E1B2D2     UXTB R2, R2
1FA0  310368E1     LDR R1, [R4, #12]
1FA2  199E3103     ADDS R1, #3
1FA4  6933199E     ADDS R6, R3, R6
1FA6  47986933     LDR R3, [R6, #16]
1FA8  28004798     BLX R3
1FAA  D0042800     CMP R0, #0
1FAC  2114D004     BEQ.N 0x1FB8
1FAE  202114     MOVS R1, #20
1FB0  F7FF0020     MOVS R0, R4
1FB2  FF18F7FF     BL sendError
1FB4  E7D0FF18     MRC2 P7, #0, LR, CR8, CR0, {6}
1FB6  2302E7D0     B.N .LVL67
1FB8  72232302     MOVS R3, #2
1FBA  23007223     STRB R3, [R4, #8]
1FBC  68E22300     MOVS R3, #0
1FBE  705368E2     LDR R2, [R4, #12]
1FC0  68637053     STRB R3, [R2, #1]
1FC2  206863     LDR R3, [R4, #4]
1FC4  47980020     MOVS R0, R4
1FC6  E7C74798     BLX R3
1FC8  46C0E7C7     B.N .LVL67
1FCA  290446C0     MOV R8, R8
1FCC  20002904     CMP R1, #4
1FCE  B5102000     MOVS R0, #0
410:           
411:           
412:           /*
413:            * Loads block data by parameter identifier.
414:            */
415:           static void loadParameter(tProtocol* protocol)
416:           {
1DF6  B083B5F0     PUSH {R4, R5, R6, R7, LR}
1DF8  4B083     SUB SP, #12
1DFA  68C20004     MOVS R4, R0
417:           	void* blockAddr;
418:           	uint16 blockId, paramId;
419:           	uint16 i;
420:           	uint8 error;
421:           
422:           	/* get parameter id from frame */
423:           	paramId = (uint16)((protocol->ucFRAMEData[2]<<8) + protocol->ucFRAMEData[1]);
1DFC  4B2968C2     LDR R2, [R0, #12]
1E08  21B7893     LDRB R3, [R2, #2]
1E0A  7851021B     LSLS R3, R3, #8
1E0C  18C97851     LDRB R1, [R2, #1]
1E0E  B28918C9     ADDS R1, R1, R3
424:           
425:           	/* look for parameter identifier in parameter table */
426:           	blockAddr = getBlockAddress(TableStruct->TParamTable, paramId, &error);
1DFE  681B4B29     LDR R3, [PC, #164]
1E00  6818681B     LDR R3, [R3]
1E02  466B6818     LDR R0, [R3]
1E04  1DDD466B     MOV R3, SP
1E06  78931DDD     ADDS R5, R3, #7
1E10  2AB289     UXTH R1, R1
1E12  F7FF002A     MOVS R2, R5
1E14  FFC6F7FF     BL .LFE6, .LFB9
1E16  7829FFC6     CDP2 P8, #12, CR7, CR6, CR9, {1}
427:           	if (error != ERRORSuccess)
1E18  29007829     LDRB R1, [R5]
1E1A  D1262900     CMP R1, #0
1E1C  4B21D126     BNE.N 0x1E6C
428:           	{
429:           		sendError(protocol, error);
1E6C  F7FF0020     MOVS R0, R4
1E6E  FFBAF7FF     BL sendError
1E70  E7F9FFBA     MRC2 P7, #5, LR, CR10, CR9, {7}
430:           		return;
1E72  2144E7F9     B.N .LVL37
431:           	}
432:           
433:           	/* returns error if function table is not initialized */
434:           	if (TableStruct->TFncTable == 0)
1E1E  68194B21     LDR R3, [PC, #132]
1E20  684B6819     LDR R1, [R3]
1E22  2B00684B     LDR R3, [R1, #4]
1E24  D0252B00     CMP R3, #0
1E26  8807D025     BEQ.N 0x1E74
435:           	{
436:           		sendError(protocol, SvErrorFncTableNotInit);
1E74  202144     MOVS R1, #68
1E76  F7FF0020     MOVS R0, R4
1E78  FFB5F7FF     BL sendError
1E7A  E7F4FFB5     MRC2 P7, #5, LR, CR5, CR4, {7}
437:           		return;
1E7C  2600E7F4     B.N .LVL37
438:           	}
439:           
440:           	blockId = *(uint16*)blockAddr;
1E28  684B8807     LDRH R7, [R0]
441:           
442:           	i = 0;
443:           	while ((blockId != (TableStruct->TFncTable)[i].iBlockID) && ((TableStruct->TFncTable)[i].iBlockID != 0))
1E2A  881B684B     LDR R3, [R1, #4]
1E2C  42BB881B     LDRH R3, [R3]
1E2E  D02542BB     CMP R3, R7
1E30  684BD025     BEQ.N 0x1E7E
1E32  881B684B     LDR R3, [R1, #4]
1E34  2B00881B     LDRH R3, [R3]
1E36  D0232B00     CMP R3, #0
1E38  2200D023     BEQ.N 0x1E82
1E3A  32012200     MOVS R2, #0
1E40  53684D     LDR R5, [R1, #4]
1E42  189B0053     LSLS R3, R2, #1
1E44  DB189B     ADDS R3, R3, R2
1E46  1E00DB     LSLS R3, R3, #3
1E48  5AED001E     MOVS R6, R3
1E4A  42BD5AED     LDRH R5, [R5, R3]
1E4C  D00342BD     CMP R5, R7
1E4E  684DD003     BEQ.N 0x1E58
1E50  5AEB684D     LDR R5, [R1, #4]
1E52  2B005AEB     LDRH R3, [R5, R3]
1E54  D1F12B00     CMP R3, #0
1E56  684BD1F1     BNE.N 0x1E3C
1E7E  E7EA2600     MOVS R6, #0
1E80  2600E7EA     B.N 0x1E58
1E82  E7E82600     MOVS R6, #0
1E84  684BE7E8     B.N 0x1E58
444:           	{
445:           		i++;
1E3C  B2923201     ADDS R2, #1
1E3E  684DB292     UXTH R2, R2
446:           	}
447:           	/* check if Block ID can be found in function table */
448:           	if (((tBlockFunctions*)(TableStruct->TFncTable))[i].iBlockID == 0)
1E58  5B9B684B     LDR R3, [R1, #4]
1E5A  2B005B9B     LDRH R3, [R3, R6]
1E5C  D1122B00     CMP R3, #0
1E5E  2141D112     BNE.N 0x1E86
449:           	{
450:           		sendError(protocol, ERRORBlkID);
1E60  202141     MOVS R1, #65
1E62  F7FF0020     MOVS R0, R4
1E64  FFBFF7FF     BL sendError
1E66  B003FFBF     CDP2 P0, #11, CR11, CR15, CR3, {0}
451:           		return;
452:           	}
453:           
454:           	protocol->ucFRAMESize = (TableStruct->TFncTable)[i].pFLoad(blockAddr, protocol->ucFRAMEData+2) + 2;
1E86  68E2684B     LDR R3, [R1, #4]
1E88  1C9168E2     LDR R2, [R4, #12]
1E8A  199E1C91     ADDS R1, R2, #2
1E8C  68F3199E     ADDS R6, R3, R6
1E8E  479868F3     LDR R3, [R6, #12]
1E90  30024798     BLX R3
1E92  72203002     ADDS R0, #2
1E94  23007220     STRB R0, [R4, #8]
455:           	protocol->ucFRAMEData[1] = ERRORSuccess;
1E96  68E22300     MOVS R3, #0
1E98  705368E2     LDR R2, [R4, #12]
1E9A  68637053     STRB R3, [R2, #1]
456:           	protocol->pSnd_Enable((struct tProtocol*)protocol);
1E9C  206863     LDR R3, [R4, #4]
1E9E  47980020     MOVS R0, R4
1EA0  E7E14798     BLX R3
1EA2  2904E7E1     B.N .LVL37
1EA4  20002904     CMP R1, #4
1EA6  B5F02000     MOVS R0, #0
457:           }
1E68  BDF0B003     ADD SP, #12
1E6A  20BDF0     POP {R4, R5, R6, R7, PC}
1E6C  F7FF0020     MOVS R0, R4
1E6E  FFBAF7FF     BL sendError
1E70  E7F9FFBA     MRC2 P7, #5, LR, CR10, CR9, {7}
1E72  2144E7F9     B.N .LVL37
1E74  202144     MOVS R1, #68
1E76  F7FF0020     MOVS R0, R4
1E78  FFB5F7FF     BL sendError
1E7A  E7F4FFB5     MRC2 P7, #5, LR, CR5, CR4, {7}
1E7C  2600E7F4     B.N .LVL37
1E7E  E7EA2600     MOVS R6, #0
1E80  2600E7EA     B.N 0x1E58
1E82  E7E82600     MOVS R6, #0
1E84  684BE7E8     B.N 0x1E58
1E86  68E2684B     LDR R3, [R1, #4]
1E88  1C9168E2     LDR R2, [R4, #12]
1E8A  199E1C91     ADDS R1, R2, #2
1E8C  68F3199E     ADDS R6, R3, R6
1E8E  479868F3     LDR R3, [R6, #12]
1E90  30024798     BLX R3
1E92  72203002     ADDS R0, #2
1E94  23007220     STRB R0, [R4, #8]
1E96  68E22300     MOVS R3, #0
1E98  705368E2     LDR R2, [R4, #12]
1E9A  68637053     STRB R3, [R2, #1]
1E9C  206863     LDR R3, [R4, #4]
1E9E  47980020     MOVS R0, R4
1EA0  E7E14798     BLX R3
1EA2  2904E7E1     B.N .LVL37
1EA4  20002904     CMP R1, #4
1EA6  B5F02000     MOVS R0, #0
458:           
459:           /*
460:            * Sets target state.
461:            */
462:           static void setTargetState(tProtocol* protocol)
463:           {
1D12  68C3B510     PUSH {R4, LR}
464:           	uint8 error = ERRORSuccess;
1D42  E7F22300     MOVS R3, #0
1D4E  E7EC2300     MOVS R3, #0
1D5A  E7E62300     MOVS R3, #0
1D66  E7E02300     MOVS R3, #0
1D72  E7DA2300     MOVS R3, #0
465:           
466:           	switch (protocol->ucFRAMEData[1])
1D14  785B68C3     LDR R3, [R0, #12]
1D16  2B05785B     LDRB R3, [R3, #1]
1D18  D82C2B05     CMP R3, #5
1D1A  9AD82C     BHI.N 0x1D76
1D1C  4917009A     LSLS R2, R3, #2
1D1E  588A4917     LDR R1, [PC, #92]
1D20  4697588A     LDR R2, [R1, R2]
1D22  4A164697     MOV PC, R2
467:           	{
468:           	case 0:
469:           		TableStruct->DSPState = MONITOR_STATE;
1D24  68124A16     LDR R2, [PC, #88]
1D26  21006812     LDR R2, [R2]
1D28  73112100     MOVS R1, #0
1D2A  68C27311     STRB R1, [R2, #12]
470:           		break;
471:           	case 1:
472:           		TableStruct->DSPState = PRG_LOADED_STATE;
1D3A  681B4B11     LDR R3, [PC, #68]
1D3C  2201681B     LDR R3, [R3]
1D3E  731A2201     MOVS R2, #1
1D40  2300731A     STRB R2, [R3, #12]
473:           		break;
1D44  4B0EE7F2     B.N 0x1D2C
474:           	case 2:
475:           		TableStruct->DSPState = IDLE_STATE;
1D46  681B4B0E     LDR R3, [PC, #56]
1D48  2202681B     LDR R3, [R3]
1D4A  731A2202     MOVS R2, #2
1D4C  2300731A     STRB R2, [R3, #12]
476:           		break;
1D50  4B0BE7EC     B.N 0x1D2C
477:           	case 3:
478:           		TableStruct->DSPState = INIT_STATE;
1D52  681B4B0B     LDR R3, [PC, #44]
1D54  2203681B     LDR R3, [R3]
1D56  731A2203     MOVS R2, #3
1D58  2300731A     STRB R2, [R3, #12]
479:           		break;
1D5C  4B08E7E6     B.N 0x1D2C
480:           	case 4:
481:           		TableStruct->DSPState = RUN_STATE_POWER_OFF;
1D5E  681B4B08     LDR R3, [PC, #32]
1D60  2204681B     LDR R3, [R3]
1D62  731A2204     MOVS R2, #4
1D64  2300731A     STRB R2, [R3, #12]
482:           		break;
1D68  4B05E7E0     B.N 0x1D2C
483:           	case 5:
484:           		TableStruct->DSPState = RUN_STATE_POWER_ON;
1D6A  681B4B05     LDR R3, [PC, #20]
1D6C  2205681B     LDR R3, [R3]
1D6E  731A2205     MOVS R2, #5
1D70  2300731A     STRB R2, [R3, #12]
485:           		break;
1D74  2322E7DA     B.N 0x1D2C
486:           	default:
487:           		error = SvErrorInvalidDspState;
1D76  E7D82322     MOVS R3, #34
1D78  46C0E7D8     B.N 0x1D2C
1D7A  642046C0     MOV R8, R8
1D7C  6420     STR R0, [R4, #64]
1D7E  29040000     MOVS R0, R0
1D80  20002904     CMP R1, #4
1D82  B5102000     MOVS R0, #0
488:           		break;
489:           	}
490:           
491:           	protocol->ucFRAMEData[1] = error;
1D2C  705368C2     LDR R2, [R0, #12]
1D2E  23027053     STRB R3, [R2, #1]
492:           	protocol->ucFRAMESize = (uint8)2;
1D30  72032302     MOVS R3, #2
1D32  68437203     STRB R3, [R0, #8]
493:           	protocol->pSnd_Enable((struct tProtocol*)protocol);
1D34  47986843     LDR R3, [R0, #4]
1D36  BD104798     BLX R3
494:           }
1D38  4B11BD10     POP {R4, PC}
1D3A  681B4B11     LDR R3, [PC, #68]
1D3C  2201681B     LDR R3, [R3]
1D3E  731A2201     MOVS R2, #1
1D40  2300731A     STRB R2, [R3, #12]
1D42  E7F22300     MOVS R3, #0
1D44  4B0EE7F2     B.N 0x1D2C
1D46  681B4B0E     LDR R3, [PC, #56]
1D48  2202681B     LDR R3, [R3]
1D4A  731A2202     MOVS R2, #2
1D4C  2300731A     STRB R2, [R3, #12]
1D4E  E7EC2300     MOVS R3, #0
1D50  4B0BE7EC     B.N 0x1D2C
1D52  681B4B0B     LDR R3, [PC, #44]
1D54  2203681B     LDR R3, [R3]
1D56  731A2203     MOVS R2, #3
1D58  2300731A     STRB R2, [R3, #12]
1D5A  E7E62300     MOVS R3, #0
1D5C  4B08E7E6     B.N 0x1D2C
1D5E  681B4B08     LDR R3, [PC, #32]
1D60  2204681B     LDR R3, [R3]
1D62  731A2204     MOVS R2, #4
1D64  2300731A     STRB R2, [R3, #12]
1D66  E7E02300     MOVS R3, #0
1D68  4B05E7E0     B.N 0x1D2C
1D6A  681B4B05     LDR R3, [PC, #20]
1D6C  2205681B     LDR R3, [R3]
1D6E  731A2205     MOVS R2, #5
1D70  2300731A     STRB R2, [R3, #12]
1D72  E7DA2300     MOVS R3, #0
1D74  2322E7DA     B.N 0x1D2C
1D76  E7D82322     MOVS R3, #34
1D78  46C0E7D8     B.N 0x1D2C
1D7A  642046C0     MOV R8, R8
1D7C  6420     STR R0, [R4, #64]
1D7E  29040000     MOVS R0, R0
1D80  20002904     CMP R1, #4
1D82  B5102000     MOVS R0, #0
495:           
496:           /*
497:            * Returns target state.
498:            */
499:           static void getTargetState(tProtocol* protocol)
500:           {
1D84  2300B510     PUSH {R4, LR}
501:           	protocol->ucFRAMEData[1] = ERRORSuccess;
1D86  68C22300     MOVS R3, #0
1D88  705368C2     LDR R2, [R0, #12]
1D8A  4B047053     STRB R3, [R2, #1]
502:           	protocol->ucFRAMEData[2] = (uint8)(TableStruct->DSPState & 0xFF);
1D8C  681B4B04     LDR R3, $d
1D8E  7B1B681B     LDR R3, [R3]
1D90  68C27B1B     LDRB R3, [R3, #12]
1D92  709368C2     LDR R2, [R0, #12]
1D94  23037093     STRB R3, [R2, #2]
503:           	protocol->ucFRAMESize = (uint8)3;
1D96  72032303     MOVS R3, #3
1D98  68437203     STRB R3, [R0, #8]
504:           	protocol->pSnd_Enable((struct tProtocol*)protocol);
1D9A  47986843     LDR R3, [R0, #4]
1D9C  BD104798     BLX R3
505:           }
1D9E  2904BD10     POP {R4, PC}
1DA0  20002904     CMP R1, #4
1DA2  B5302000     MOVS R0, #0
506:           
507:           
508:           /*
509:            * Initializes service table.
510:            */
511:           void initServiceTable(tProtocol* protocol)
512:           {
2154  194B04     LDR R3, $d
2156  316C0019     MOVS R1, R3
2158  4A04316C     ADDS R1, #108
513:           	uint16 i;
514:           
515:           	for (i = 0; i <= MAX_SERVICE_ID; i++)
215E  D1FC428B     CMP R3, R1
2160  4B01D1FC     BNE.N 0x215C
516:           	{
517:           		serviceTable[i] = sendSvNotAvailable;
215A  C3044A04     LDR R2, [PC, #16]
215C  428BC304     STMIA R3!, {R2}
518:           	}
519:           
520:           	/* adds service table pointer to protocol structure */
521:           	protocol->pServiceTable = (void*)serviceTable;
2162  61034B01     LDR R3, [PC, #4]
2164  47706103     STR R3, [R0, #16]
522:           }
2166  27B84770     BX LR
2168  200027B8     MOVS R7, #184
216A  1D012000     MOVS R0, #0
216C  1D01     ADDS R1, R0, #4
216E  69030000     MOVS R0, R0
523:           
524:           /*
525:            * Adds core services to service table.
526:            */
527:           void addCoreServices(tProtocol* protocol)
528:           {
529:           	tSERVICEFunction* svTable = (tSERVICEFunction*)protocol->pServiceTable;
2170  4A056903     LDR R3, [R0, #16]
530:           	svTable[SV_ID_SVDEVICEINFO] = getDeviceInfo;
2172  601A4A05     LDR R2, [PC, #20]
2174  4A05601A     STR R2, [R3]
531:           	svTable[SV_ID_GETTARGETSTATE] = getTargetState;
2176  605A4A05     LDR R2, [PC, #20]
2178  4A05605A     STR R2, [R3, #4]
532:           	svTable[SV_ID_SETTARGETSTATE] = setTargetState;
217A  609A4A05     LDR R2, [PC, #20]
217C  4A05609A     STR R2, [R3, #8]
533:           	svTable[SV_ID_SVSAVEPARAM] = saveParameter;
217E  649A4A05     LDR R2, [PC, #20]
2180  4A05649A     STR R2, [R3, #72]
534:           	svTable[SV_ID_SVLOADPARAM] = loadParameter;
2182  645A4A05     LDR R2, [PC, #20]
2184  4770645A     STR R2, [R3, #68]
535:           }
2186  1FD14770     BX LR
2188  1FD1     SUBS R1, R2, #7
218A  1D850000     MOVS R0, R0
218C  1D85     ADDS R5, R0, #6
218E  1D130000     MOVS R0, R0
2190  1D13     ADDS R3, R2, #4
2192  1EA90000     MOVS R0, R0
2194  1EA9     SUBS R1, R5, #2
2196  1DF70000     MOVS R0, R0
2198  1DF7     ADDS R7, R6, #7
219A  23010000     MOVS R0, R0
536:           
537:           /*
538:            * Returns block address from parameter table.
539:            * Also checks if parameter table has been initialized.
540:            */
541:           static void* getBlockAddress(const tParameterTable* paramTable, uint16 paramId, uint8* error)
542:           {
1DA4  2800B530     PUSH {R4, R5, LR}
543:           	void* blockAddr;
544:           	uint16 i;
545:           
546:           	/* send parameter ID error if no parameter table has been initialized */
547:           	if (paramTable == 0)
1DA6  D0122800     CMP R0, #0
1DA8  8804D012     BEQ.N 0x1DD0
548:           	{
549:           		blockAddr = (void*)0;
1DD4  E0052000     MOVS R0, #0
1DD6  4E005     B.N 0x1DE4
550:           		*error = SvErrorParamTableNotInit;
1DD0  70132343     MOVS R3, #67
1DD2  20007013     STRB R3, [R2]
551:           	}
552:           	else
553:           	{
554:           		i = 0;
555:           		while((paramId != paramTable[i].uiParID) && (paramTable[i].uiParID != 0))
1DAA  42A18804     LDRH R4, [R0]
1DAC  D01342A1     CMP R1, R4
1DAE  2300D013     BEQ.N 0x1DD8
1DB0  2C002300     MOVS R3, #0
1DB2  D0082C00     CMP R4, #0
1DB4  3301D008     BEQ.N 0x1DC8
1DBA  190400DC     LSLS R4, R3, #3
1DBC  88251904     ADDS R4, R0, R4
1DBE  428D8825     LDRH R5, [R4]
1DC0  D00A428D     CMP R5, R1
1DC2  2D00D00A     BEQ.N 0x1DDA
1DC4  D1F62D00     CMP R5, #0
1DC6  2340D1F6     BNE.N 0x1DB6
1DD8  29000004     MOVS R4, R0
556:           		{
557:           			i++;
1DB6  B29B3301     ADDS R3, #1
1DB8  DCB29B     UXTH R3, R3
558:           		}
559:           		/* check if parameter is located in parameter table */
560:           		if (paramTable[i].uiParID == 0)
1DDA  D0F42900     CMP R1, #0
1DDC  6860D0F4     BEQ.N 0x1DC8
561:           		{
562:           			blockAddr = (void*)0;
1DCC  E0092000     MOVS R0, #0
1DCE  2343E009     B.N 0x1DE4
563:           			*error = SvErrorInvalidParamId;
1DC8  70132340     MOVS R3, #64
1DCA  20007013     STRB R3, [R2]
564:           		}
565:           		else
566:           		{
567:           			blockAddr = paramTable[i].pAdr;
1DDE  23006860     LDR R0, [R4, #4]
568:           			*error = ERRORSuccess;
1DE0  70132300     MOVS R3, #0
1DE2  BD307013     STRB R3, [R2]
569:           		}
570:           	}
571:           	return (blockAddr);
572:           }
1DE4  B510BD30     POP {R4, R5, PC}
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/SerialGeneric.c
1:             /*
2:              * Generic serial interface.
3:              *
4:              * $LastChangedRevision: 632 $
5:              *
6:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
7:              * All rights reserved.
8:              */
9:             #include "SerialGeneric.h"
10:            
11:            
12:            /* private prototypes */
13:            static void sendSerial(tSerial* serialP, uint8 data);
14:            static uint8 receiveSerial(tSerial* serialP);
15:            static uint8 isReceiveDataAvailable(tSerial* serialP);
16:            static uint8 isSendReady(tSerial* serialP);
17:            static uint8 getTxFifoFree(tSerial* serialP);
18:            static void flush(tSerial* serialP);
19:            
20:            
21:            void initSerialGeneric(tSerial* serialP)
22:            {
23:                serialP->send = (void (*)(tInterface*, uint8))sendSerial;
5B24  60034B06     LDR R3, $d
5B26  4B066003     STR R3, [R0]
24:                serialP->receive = (uint8 (*)(tInterface*))receiveSerial;
5B28  60434B06     LDR R3, [PC, #24]
5B2A  4B066043     STR R3, [R0, #4]
25:                serialP->isReceiveDataAvailable = (uint8 (*)(tInterface*))isReceiveDataAvailable;
5B2C  60834B06     LDR R3, [PC, #24]
5B2E  4B066083     STR R3, [R0, #8]
26:                serialP->isSendReady = (uint8 (*)(tInterface*))isSendReady;
5B30  60C34B06     LDR R3, [PC, #24]
5B32  4B0660C3     STR R3, [R0, #12]
27:                serialP->getTxFifoFree = (uint8 (*)(tInterface*))getTxFifoFree;
5B34  61034B06     LDR R3, [PC, #24]
5B36  4B066103     STR R3, [R0, #16]
28:                serialP->flush = (void (*)(tInterface*))flush;
5B38  61434B06     LDR R3, [PC, #24]
5B3A  47706143     STR R3, [R0, #20]
29:            }
5B3C  46C04770     BX LR
5B3E  5B1146C0     MOV R8, R8
5B40  5B11     LDRH R1, [R2, R4]
5B42  5B130000     MOVS R0, R0
5B44  5B13     LDRH R3, [R2, R4]
5B46  5B170000     MOVS R0, R0
5B48  5B17     LDRH R7, [R2, R4]
5B4A  5B1B0000     MOVS R0, R0
5B4C  5B1B     LDRH R3, [R3, R4]
5B4E  5B1F0000     MOVS R0, R0
5B50  5B1F     LDRH R7, [R3, R4]
5B52  5B230000     MOVS R0, R0
5B54  5B23     LDRH R3, [R4, R4]
5B56  61410000     MOVS R0, R0
30:            
31:            void linkSerial(tProtocol* lnkProtocol, tSerial* serialP)
32:            {
33:                lnkProtocol->hwInterface = (tInterface*)serialP;
5B58  47706141     STR R1, [R0, #20]
34:            }
5B5A  4A084770     BX LR
35:            
36:            static void sendSerial(tSerial* serialP, uint8 data)
37:            {
38:                // do nothing
39:            }
5B10  20004770     BX LR
40:            
41:            static uint8 receiveSerial(tSerial* serialP)
42:            {
43:                return ((uint8)0);
44:            }
5B12  47702000     MOVS R0, #0
5B14  20004770     BX LR
45:            
46:            static uint8 isReceiveDataAvailable(tSerial* serialP)
47:            {
48:                return ((uint8)0);
49:            }
5B16  47702000     MOVS R0, #0
5B18  20004770     BX LR
50:            
51:            static uint8 isSendReady(tSerial* serialP)
52:            {
53:                return ((uint8)0);
54:            }
5B1A  47702000     MOVS R0, #0
5B1C  20004770     BX LR
55:            
56:            static uint8 getTxFifoFree(tSerial* serialP)
57:            {
58:                return ((uint8)0);
59:            }
5B1E  47702000     MOVS R0, #0
5B20  47704770     BX LR
60:            
61:            static void flush(tSerial* serialP)
62:            {
63:                /* do nothing because 'send' immediately sends byte */
64:            }
5B22  4B064770     BX LR
65:            
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/Scope_Main.c
1:             /*
2:              * $LastChangedRevision: 995 $
3:              * $LastChangedDate:: 2016-08-11 15:52:41 +0200#$
4:              *
5:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
6:              * All rights reserved.
7:              */
8:             #include "CommonFcts.h"
9:             #include "Scope_Main.h"
10:            
11:            /* private prototypes */
12:            static uint8 isTriggerEvent(SCOPE_MAIN *pTScope, uint64 curTrgValue);
13:            static uint64 getTriggerValue(SCOPE_MAIN *pTScope);
14:            static void sampleData(SCOPE_MAIN *pTScope);
15:            
16:            ALIGNTYPE ScopeArray[SCOPE_SIZE];
17:            
18:            #if defined(__COMPILER_CODEWARRIOR_ECLIPSE__)
19:            #pragma push
20:            #pragma section sdata_type ".ptrTableStruct" ".ptrTableStruct"
21:            extern volatile tTableStruct *TableStruct;
22:            #pragma pop
23:            #else
24:            extern volatile tTableStruct* TableStruct;
25:            #endif
26:            
27:            /* private prototypes */
28:            static void* getBlockAddress(const tParameterTable* paramTable, uint16 paramId);
29:            static tBlockFunctions* getBlockFunction(const tBlockFunctions* blockFuncTable, uint16 blockId);
30:            
31:            /**
32:             * Scope version.
33:             */
34:            #define SCOPE_VERSION ((uint8)2)
35:            
36:            #define SOURCE_TYPE_ADDRESS ((uint8)0)
37:            #define SOURCE_TYPE_CONTROLBLOCK ((uint8)1)
38:            #define SOURCE_TYPE_INPORTBLOCK ((uint8)2)
39:            #define SOURCE_TYPE_OUTPORTBLOCk ((uint8)3)
40:            
41:            #define TRG_MODE_AUTO ((uint8)0)
42:            #define TRG_MODE_NORMAL ((uint8)1)
43:            
44:            /************************************************/
45:            /*  Scope_Main_Init                             */
46:            /************************************************/
47:            void Scope_Main_Init(SCOPE_MAIN *pTScope)
48:            {
04CE  2301B510     PUSH {R4, LR}
49:            	uint8 i;
50:            
51:            	pTScope->ID = SCOPE_MAIN_ID;
04D0  425B2301     MOVS R3, #1
04D2  8003425B     RSBS R3, R3, #0
04D4  1D028003     STRH R3, [R0]
04D6  41D02     ADDS R2, R0, #4
04D8  34240004     MOVS R4, R0
04DA  233424     ADDS R4, #36
04DC  21000023     MOVS R3, R4
52:            	for (i=0;i<MAX_SCOPE_CHANNELS;i++)
04E6  D1FA42A2     CMP R2, R4
04E8  4B16D1FA     BNE.N 0x4E0
53:            	{
54:            		pTScope->channelAddr[i] = (void*)0;
04DE  C2022100     MOVS R1, #0
04E0  7019C202     STMIA R2!, {R1}
55:            		pTScope->dataSize[i] = (uint8)0;
04E2  33017019     STRB R1, [R3]
04E4  42A23301     ADDS R3, #1
56:            	}
57:            
58:            	pTScope->arrayAddr = (void*)ScopeArray;
04EA  62C34B16     LDR R3, [PC, #88]
04EC  220062C3     STR R3, [R0, #44]
59:            	pTScope->trgLevel = (int32)0;
04EE  23002200     MOVS R2, #0
04F0  63822300     MOVS R3, #0
04F2  63C36382     STR R2, [R0, #56]
04F4  640263C3     STR R3, [R0, #60]
60:            	pTScope->trgLastValue = (int32)0;
04F6  64436402     STR R2, [R0, #64]
04F8  23006443     STR R3, [R0, #68]
61:            	pTScope->trgAddr = (void*)0;
04FA  64832300     MOVS R3, #0
04FC  324C6483     STR R3, [R0, #72]
62:            	pTScope->trgDataType = (uint8)0;
04FE  5483324C     ADDS R2, #76
0500  32015483     STRB R3, [R0, R2]
63:            	pTScope->state = SCOPE_IDLE;
0502  54833201     ADDS R2, #1
0504  65035483     STRB R3, [R0, R2]
64:            	pTScope->offlinePtr = (uint32)0;
0506  32076503     STR R3, [R0, #80]
65:            	pTScope->dataSizeTotal = (uint8)0;
0508  54833207     ADDS R2, #7
050A  32015483     STRB R3, [R0, R2]
66:            	pTScope->noChannels = (uint8)0;
050C  54833201     ADDS R2, #1
050E  22005483     STRB R3, [R0, R2]
67:            	pTScope->stf = (uint16)0;
0510  21562200     MOVS R2, #0
0512  52432156     MOVS R1, #86
0514  31025243     STRH R3, [R0, R1]
68:                pTScope->stfCnt = (uint16)0;
0516  52433102     ADDS R1, #2
0518  31025243     STRH R3, [R0, R1]
69:            	pTScope->timestamp = (uint16)0;
051A  52433102     ADDS R1, #2
051C  31025243     STRH R3, [R0, R1]
70:                pTScope->txFrameSize = (uint8)0;
051E  54423102     ADDS R1, #2
0520  66035442     STRB R2, [R0, R1]
71:            	pTScope->trgDelay = (int32)0;
0522  66436603     STR R3, [R0, #96]
72:            	pTScope->trgEventPos = (int32)0;
0524  310C6643     STR R3, [R0, #100]
73:            	pTScope->trgCountReached = (uint8)0;
0526  5442310C     ADDS R1, #12
0528  66C35442     STRB R2, [R0, R1]
74:            	pTScope->trgCount = (uint32)0;
052A  238066C3     STR R3, [R0, #108]
75:            	pTScope->maxUsedLength = SCOPE_SIZE;
052C  19B2380     MOVS R3, #128
052E  6703019B     LSLS R3, R3, #6
0530  39676703     STR R3, [R0, #112]
76:            	pTScope->trgEdge = EDGE_RISING;
0532  22743967     SUBS R1, #103
0534  54812274     MOVS R2, #116
0536  63035481     STRB R1, [R0, R2]
77:            	pTScope->arraySize = SCOPE_SIZE;
0538  4B036303     STR R3, [R0, #48]
78:            
79:            	TableStruct->piScope = pTScope;
053A  681B4B03     LDR R3, [PC, #12]
053C  6298681B     LDR R3, [R3]
053E  BD106298     STR R0, [R3, #40]
80:            }
0540  46C0BD10     POP {R4, PC}
0542  24846C0     MOV R8, R8
0544  20000248     LSLS R0, R1, #9
0546  29042000     MOVS R0, #0
0548  20002904     CMP R1, #4
054A  B5F82000     MOVS R0, #0
81:            
82:            
83:            
84:            /************************************************/
85:            /*  Scope_Main_Update                           */
86:            /************************************************/
87:            void Scope_Main_Update(SCOPE_MAIN *pTScope)
88:            {
054C  4B5F8     PUSH {R3, R4, R5, R6, R7, LR}
054E  234D0004     MOVS R4, R0
0600  23552700     MOVS R7, #0
89:                uint8 i, j;
90:            	uint64 curTrgValue;
91:            
92:            	switch (pTScope->state)
0550  5CC2234D     MOVS R3, #77
0552  2A085CC2     LDRB R2, [R0, R3]
0554  D80B2A08     CMP R2, #8
0556  93D80B     BHI.N 0x570
0558  4A7B0093     LSLS R3, R2, #2
055A  58D34A7B     LDR R2, [PC, #492]
055C  469F58D3     LDR R3, [R2, R3]
055E  225A469F     MOV PC, R3
93:            	{
94:            		case SCOPE_IDLE:
95:            			break;
96:            		case SCOPE_SAMPLE_ONLINE:
97:            			pTScope->timestamp++;
0560  5A83225A     MOVS R2, #90
0562  33015A83     LDRH R3, [R0, R2]
0564  52833301     ADDS R3, #1
0566  3A025283     STRH R3, [R0, R2]
98:                        pTScope->stfCnt++;
0568  5A833A02     SUBS R2, #2
056A  33015A83     LDRH R3, [R0, R2]
056C  52833301     ADDS R3, #1
056E  BDF85283     STRH R3, [R0, R2]
99:                        break;
100:                   case SCOPE_SAMPLE_OFFLINE:
101:                       /* check if sample time prescaler is reached */
102:                       if (pTScope->stfCnt++ >= pTScope->stf)
0572  5A832258     MOVS R2, #88
0574  1C595A83     LDRH R3, [R0, R2]
0576  52811C59     ADDS R1, R3, #1
0578  3A025281     STRH R1, [R0, R2]
057A  5A823A02     SUBS R2, #2
057C  429A5A82     LDRH R2, [R0, R2]
057E  D904429A     CMP R2, R3
0580  225AD904     BLS.N 0x58C
103:                       {
104:                           pTScope->stfCnt = (uint16)0;
058C  23582200     MOVS R2, #0
058E  52C22358     MOVS R3, #88
0590  F7FF52C2     STRH R2, [R0, R3]
105:           
106:           				sampleData(pTScope);
0592  FF62F7FF     BL .LFE6, .LFB7
0594  2354FF62     MCR2 P3, #3, R2, CR2, CR4, {2}
107:           
108:                           /* if size of next data size would exceed SCOPE_SIZE, the */
109:                           /* offline sampling mode will be stopped (change to idle state) */
110:                           if ((pTScope->offlinePtr + pTScope->dataSizeTotal) > SCOPE_SIZE)
0596  5CE32354     MOVS R3, #84
0598  6D225CE3     LDRB R3, [R4, R3]
059A  46946D22     LDR R2, [R4, #80]
059C  44634694     MOV R12, R2
059E  22804463     ADD R3, R12
05A0  1922280     MOVS R2, #128
05A2  42930192     LSLS R2, R2, #6
05A4  D9EC4293     CMP R3, R2
05A6  2200D9EC     BLS.N 0x582
111:                           {
112:                               pTScope->state = SCOPE_IDLE;
05A8  234D2200     MOVS R2, #0
05AA  54E2234D     MOVS R3, #77
05AC  E7E854E2     STRB R2, [R4, R3]
05AE  F7FFE7E8     B.N 0x582
113:                           }
114:                       }
115:                       pTScope->timestamp++;
0582  5AA3225A     MOVS R2, #90
0584  33015AA3     LDRH R3, [R4, R2]
0586  52A33301     ADDS R3, #1
0588  E7F152A3     STRH R3, [R4, R2]
116:                       break;
058A  2200E7F1     B.N 0x570
117:                   /* wait for trigger in online mode */
118:                   case SCOPE_WAITTRGPOS_ONLINE:
119:                   case SCOPE_WAITTRGNEG_ONLINE:
120:                   	curTrgValue = getTriggerValue(pTScope);
05B0  FF31F7FF     BL .LFE5, .LFB6
05B2  6FF31     CDP2 P0, #3, CR0, CR1, CR6, {0}
05B4  F0006     MOVS R6, R0
05B6  2000F     MOVS R7, R1
121:                   	if (isTriggerEvent(pTScope, curTrgValue))
05B8  B0002     MOVS R2, R0
05BA  20000B     MOVS R3, R1
05BC  F7FF0020     MOVS R0, R4
05BE  FD8FF7FF     BL __fini_array_end, .Ltext0, .LFB5, _efixed
05C0  2800FD8F     STC2 P8, CR2, $d
05C2  D0032800     CMP R0, #0
05C4  2204D003     BEQ.N 0x5CE
122:                   	{
123:                   		pTScope->state = SCOPE_SAMPLE_ONLINE;
05C6  234D2204     MOVS R2, #4
05C8  54E2234D     MOVS R3, #77
05CA  E7D054E2     STRB R2, [R4, R3]
05CC  6426E7D0     B.N 0x570
124:                   	}
125:                   	else
126:                   	{
127:                   		pTScope->trgLastValue = curTrgValue;
05CE  64676426     STR R6, [R4, #64]
05D0  E7CD6467     STR R7, [R4, #68]
05D2  2258E7CD     B.N 0x570
128:                   	}
129:                       break;
130:           
131:                   /* wait for trigger in offline mode */
132:           		case SCOPE_WAITTRG_OFFLINE:
133:           			if (pTScope->stfCnt++ >= pTScope->stf)
05D4  5A832258     MOVS R2, #88
05D6  1C595A83     LDRH R3, [R0, R2]
05D8  52811C59     ADDS R1, R3, #1
05DA  3A025281     STRH R1, [R0, R2]
05DC  5A823A02     SUBS R2, #2
05DE  429A5A82     LDRH R2, [R0, R2]
05E0  D846429A     CMP R2, R3
05E2  2200D846     BHI.N 0x572
134:           			{
135:           				pTScope->stfCnt = (uint16)0;
05E4  23582200     MOVS R2, #0
05E6  52C22358     MOVS R3, #88
05E8  3B0452C2     STRH R2, [R0, R3]
136:           				/* reset array ptr if next dataset would exceed scope buffer size */
137:           				if (pTScope->offlinePtr + pTScope->dataSizeTotal > SCOPE_SIZE)
05EA  5CC33B04     SUBS R3, #4
05EC  6D025CC3     LDRB R3, [R0, R3]
05EE  46946D02     LDR R2, [R0, #80]
05F0  44634694     MOV R12, R2
05F2  22804463     ADD R3, R12
05F4  1922280     MOVS R2, #128
05F6  42930192     LSLS R2, R2, #6
05F8  D9014293     CMP R3, R2
05FA  2300D901     BLS.N 0x600
138:           				{
139:           					pTScope->offlinePtr = (int32)0;
05FC  65032300     MOVS R3, #0
05FE  27006503     STR R3, [R0, #80]
140:           				}
141:           
142:           				i = 0;
143:           				do
144:           				   {
145:           					j = 0;
0606  BE2300     MOVS R3, #0
146:           					do
147:           					{
148:           						*(ALIGNCASTPTR pTScope->arrayAddr + pTScope->offlinePtr++) = \
0610  1C516D22     LDR R2, [R4, #80]
0612  65211C51     ADDS R1, R2, #1
0614  68716521     STR R1, [R4, #80]
061A  54816AE0     LDR R0, [R4, #44]
061C  33015481     STRB R1, [R0, R2]
149:           							*(ALIGNCASTPTR pTScope->channelAddr[i] + j);
0608  19A600BE     LSLS R6, R7, #2
060A  19E519A6     ADDS R6, R4, R6
0616  56C96871     LDR R1, [R6, #4]
0618  6AE056C9     LDRSB R1, [R1, R3]
150:           						j++;
061E  B2DB3301     ADDS R3, #1
0620  782AB2DB     UXTB R3, R3
151:           					}
152:           					while (j < pTScope->dataSize[i]);
060C  352419E5     ADDS R5, R4, R7
060E  6D223524     ADDS R5, #36
0622  429A782A     LDRB R2, [R5]
0624  D8F3429A     CMP R2, R3
0626  3701D8F3     BHI.N 0x610
153:           					i++;
0628  B2FF3701     ADDS R7, #1
062A  4663B2FF     UXTB R7, R7
154:           				}
155:           				while(i < pTScope->noChannels);
0602  469C2355     MOVS R3, #85
0604  2300469C     MOV R12, R3
062C  5CE34663     MOV R3, R12
062E  42BB5CE3     LDRB R3, [R4, R3]
0630  D8E842BB     CMP R3, R7
0632  6D23D8E8     BHI.N 0x606
156:           
157:           				/* checks for minimum samples (= trigger delay) */
158:           				if (pTScope->offlinePtr >= pTScope->trgCount)
0634  6EE26D23     LDR R3, [R4, #80]
0636  42936EE2     LDR R2, [R4, #108]
0638  D31A4293     CMP R3, R2
063A  2201D31A     BCC.N 0x672
159:           				{
160:           					pTScope->trgCountReached = 1;
063C  23682201     MOVS R2, #1
063E  54E22368     MOVS R3, #104
0640  2054E2     STRB R2, [R4, R3]
161:           				}
162:           			}
163:           
164:           			curTrgValue = getTriggerValue(pTScope);
0642  F7FF0020     MOVS R0, R4
0644  FEE7F7FF     BL .LFE5, .LFB6
0646  6FEE7     CDP2 P0, #14, CR0, CR7, CR6, {0}
0648  F0006     MOVS R6, R0
064A  2000F     MOVS R7, R1
0672  F7FF0020     MOVS R0, R4
0674  FECFF7FF     BL .LFE5, .LFB6
0676  6FECF     CDP2 P0, #12, CR0, CR15, CR6, {0}
0678  F0006     MOVS R6, R0
067A  2000F     MOVS R7, R1
165:           			if (isTriggerEvent(pTScope, curTrgValue) && pTScope->trgCountReached)
064C  B0002     MOVS R2, R0
064E  20000B     MOVS R3, R1
0650  F7FF0020     MOVS R0, R4
0652  FD45F7FF     BL __fini_array_end, .Ltext0, .LFB5, _efixed
0654  2800FD45     STC2L P8, CR2, [R5]
0656  D01B2800     CMP R0, #0
0658  6E23D01B     BEQ.N 0x692
067C  B0002     MOVS R2, R0
067E  20000B     MOVS R3, R1
0680  F7FF0020     MOVS R0, R4
0682  FD2DF7FF     BL __fini_array_end, .Ltext0, .LFB5, _efixed
0684  2800FD2D     STC2 P8, CR2, [SP]!
0686  D0032800     CMP R0, #0
0688  2368D003     BEQ.N 0x692
068A  5CE32368     MOVS R3, #104
068C  2B005CE3     LDRB R3, [R4, R3]
068E  D1E32B00     CMP R3, #0
0690  6426D1E3     BNE.N 0x65A
166:           			{
167:           				if (pTScope->trgDelay < (int32)0)
065A  2B006E23     LDR R3, [R4, #96]
065C  DB1B2B00     CMP R3, #0
065E  6D23DB1B     BLT.N 0x698
168:           				{
169:           					pTScope->trgEventPos = pTScope->trgDelay;
0698  23006663     STR R3, [R4, #100]
170:           					pTScope->offlinePtr = (uint32)0;
069A  65232300     MOVS R3, #0
069C  22086523     STR R3, [R4, #80]
171:           					pTScope->state = SCOPE_WAIT_TRG_NEG_DELAY;
069E  334D2208     MOVS R2, #8
06A0  54E2334D     ADDS R3, #77
06A2  E76454E2     STRB R2, [R4, R3]
06A4  2254E764     B.N 0x570
172:           				}
173:           				else
174:           				{
175:           					if (pTScope->offlinePtr > 0)
0660  2B006D23     LDR R3, [R4, #80]
0662  D0242B00     CMP R3, #0
0664  2258D024     BEQ.N 0x6B0
176:           					{
177:           						/**
178:           						 * In case of STF > 0:
179:           						 * Trigger event position = current offline pointer because next sample is
180:           						 * the first 'after trigger' sample.
181:           						 * In case of STF == 0:
182:           						 * Current sample is first 'after trigger' sample, so the 'trigger event sample'
183:           						 * was the previous sample.
184:           						 */
185:           						if (pTScope->stfCnt != 0)
0666  5AA22258     MOVS R2, #88
0668  2A005AA2     LDRH R2, [R4, R2]
066A  D01B2A00     CMP R2, #0
066C  6663D01B     BEQ.N 0x6A6
186:           						{
187:           							pTScope->trgEventPos = pTScope->offlinePtr;
066E  E0236663     STR R3, [R4, #100]
0670  20E023     B.N 0x6BA
188:           						}
189:           						else
190:           						{
191:           							pTScope->trgEventPos = pTScope->offlinePtr - pTScope->dataSizeTotal;
06A6  5CA22254     MOVS R2, #84
06A8  1A9B5CA2     LDRB R2, [R4, R2]
06AA  66631A9B     SUBS R3, R3, R2
06AC  E0046663     STR R3, [R4, #100]
06AE  2354E004     B.N 0x6BA
192:           						}
193:           					}
194:           					else
195:           					{
196:           						pTScope->trgEventPos = pTScope->maxUsedLength - pTScope->dataSizeTotal;
06B0  5CE32354     MOVS R3, #84
06B2  6F225CE3     LDRB R3, [R4, R3]
06B4  1AD36F22     LDR R2, [R4, #112]
06B6  66631AD3     SUBS R3, R2, R3
06B8  22076663     STR R3, [R4, #100]
197:           					}
198:           					pTScope->state = SCOPE_TRG_SAMPLE_OFFLINE;
06BA  234D2207     MOVS R2, #7
06BC  54E2234D     MOVS R3, #77
06BE  E75654E2     STRB R2, [R4, R3]
06C0  2258E756     B.N 0x570
199:           				}
200:           			}
201:           			else
202:           			{
203:           				pTScope->trgLastValue = curTrgValue;
0692  64676426     STR R6, [R4, #64]
0694  E76B6467     STR R7, [R4, #68]
0696  6663E76B     B.N 0x570
204:           			}
205:           			break;
206:           
207:           		case SCOPE_WAIT_TRG_NEG_DELAY:
208:           			/* in case of negative delay wait until delay time has been passed */
209:           			if (pTScope->stfCnt++ >= pTScope->stf)
06C2  5A832258     MOVS R2, #88
06C4  1C595A83     LDRH R3, [R0, R2]
06C6  52811C59     ADDS R1, R3, #1
06C8  3A025281     STRH R1, [R0, R2]
06CA  5A823A02     SUBS R2, #2
06CC  429A5A82     LDRH R2, [R0, R2]
06CE  D900429A     CMP R2, R3
06D0  E74DD900     BLS.N 0x6D4
06D2  2200E74D     B.N 0x570
210:           			{
211:           				pTScope->stfCnt = (uint16)0;
06D4  23582200     MOVS R2, #0
06D6  52C22358     MOVS R3, #88
06D8  3B0452C2     STRH R2, [R0, R3]
212:           
213:           				pTScope->trgEventPos += pTScope->dataSizeTotal;
06DA  5CC33B04     SUBS R3, #4
06DC  6E425CC3     LDRB R3, [R0, R3]
06DE  46946E42     LDR R2, [R0, #100]
06E0  44634694     MOV R12, R2
06E2  66434463     ADD R3, R12
06E4  2B006643     STR R3, [R0, #100]
214:           				if (pTScope->trgEventPos >= 0)
06E6  DA002B00     CMP R3, #0
06E8  E741DA00     BGE.N 0x6EC
06EA  2202E741     B.N 0x570
215:           				{
216:           					pTScope->state = SCOPE_SAMPLE_OFFLINE;
06EC  234D2202     MOVS R2, #2
06EE  54C2234D     MOVS R3, #77
06F0  E73D54C2     STRB R2, [R0, R3]
06F2  2258E73D     B.N 0x570
217:           				}
218:           			}
219:           			break;
220:           
221:           		case SCOPE_TRG_SAMPLE_OFFLINE:
222:                       if (pTScope->stfCnt++ >= pTScope->stf)
06F4  5A832258     MOVS R2, #88
06F6  1C595A83     LDRH R3, [R0, R2]
06F8  52811C59     ADDS R1, R3, #1
06FA  3A025281     STRH R1, [R0, R2]
06FC  5A823A02     SUBS R2, #2
06FE  429A5A82     LDRH R2, [R0, R2]
0700  D900429A     CMP R2, R3
0702  E734D900     BLS.N 0x706
0704  2200E734     B.N 0x570
223:                       {
224:                           pTScope->stfCnt = (uint16)0;
0706  23582200     MOVS R2, #0
0708  52C22358     MOVS R3, #88
070A  3B0452C2     STRH R2, [R0, R3]
225:           
226:           				if ((pTScope->offlinePtr + pTScope->dataSizeTotal) > SCOPE_SIZE)
070C  5CC33B04     SUBS R3, #4
070E  6D025CC3     LDRB R3, [R0, R3]
0710  46946D02     LDR R2, [R0, #80]
0712  44634694     MOV R12, R2
0714  22804463     ADD R3, R12
0716  1922280     MOVS R2, #128
0718  42930192     LSLS R2, R2, #6
071A  D9014293     CMP R3, R2
071C  2300D901     BLS.N 0x722
227:           				{
228:           					pTScope->offlinePtr = (uint32)0;
071E  65032300     MOVS R3, #0
0720  206503     STR R3, [R0, #80]
229:           				}
230:           
231:           				sampleData(pTScope);
0722  F7FF0020     MOVS R0, R4
0724  FE99F7FF     BL .LFE6, .LFB7
0726  6E63FE99     CDP2 P14, #9, CR6, CR9, CR3, {3}
232:           
233:           				if (((pTScope->trgEventPos - pTScope->offlinePtr) <= pTScope->trgDelay) || \
0728  6D226E63     LDR R3, [R4, #100]
072A  1A9B6D22     LDR R2, [R4, #80]
072C  6E221A9B     SUBS R3, R3, R2
072E  42936E22     LDR R2, [R4, #96]
0730  D9054293     CMP R3, R2
0732  6F21D905     BLS.N 0x740
073A  D200429A     CMP R2, R3
073C  E717D200     BCS.N 0x740
073E  2200E717     B.N 0x570
234:           					((pTScope->trgEventPos - pTScope->offlinePtr + pTScope->maxUsedLength) <= pTScope->trgDelay))
0734  468C6F21     LDR R1, [R4, #112]
0736  4463468C     MOV R12, R1
0738  429A4463     ADD R3, R12
235:           				{
236:           					pTScope->state = SCOPE_IDLE;
0740  234D2200     MOVS R2, #0
0742  54E2234D     MOVS R3, #77
0744  E71354E2     STRB R2, [R4, R3]
237:           				}
238:           
239:           			}
240:           			break;
241:           	}
242:           }
0570  2258BDF8     POP {R3, R4, R5, R6, R7, PC}
0746  629CE713     B.N 0x570
0748  629C     STR R4, [R3, #40]
074A  234D0000     MOVS R0, R0
243:           
244:           /************************************************/
245:           /*  Scope_Main_Load                             */
246:           /************************************************/
247:           uint8 Scope_Main_Load(SCOPE_MAIN *pTScope,uint8 *ucData)
248:           {
249:           	ucData[0] = pTScope->state;
074C  5CC3234D     MOVS R3, #77
074E  700B5CC3     LDRB R3, [R0, R3]
0750  2355700B     STRB R3, [R1]
250:           	ucData[1] = pTScope->noChannels;
0752  5CC32355     MOVS R3, #85
0754  704B5CC3     LDRB R3, [R0, R3]
0756  2356704B     STRB R3, [R1, #1]
251:           	ucData[2] = (uint8)(pTScope->stf & 0xFF);
0758  5AC22356     MOVS R3, #86
075A  708A5AC2     LDRH R2, [R0, R3]
075C  5AC3708A     STRB R2, [R1, #2]
252:           	ucData[3] = (uint8)((pTScope->stf >> 8) & 0xFF);
075E  A1B5AC3     LDRH R3, [R0, R3]
0760  70CB0A1B     LSRS R3, R3, #8
0762  235070CB     STRB R3, [R1, #3]
253:           	ucData[4] = (uint8)(pTScope->offlinePtr & 0xFF);
0764  18C32350     MOVS R3, #80
0766  781B18C3     ADDS R3, R0, R3
0768  710B781B     LDRB R3, [R3]
076A  6D03710B     STRB R3, [R1, #4]
254:           	ucData[5] = (uint8)((pTScope->offlinePtr >> 8) & 0xFF);
076C  A1B6D03     LDR R3, [R0, #80]
076E  714B0A1B     LSRS R3, R3, #8
0770  6D03714B     STRB R3, [R1, #5]
255:           	ucData[6] = (uint8)((pTScope->offlinePtr >> 16) & 0xFF);
0772  C1B6D03     LDR R3, [R0, #80]
0774  718B0C1B     LSRS R3, R3, #16
0776  6D03718B     STRB R3, [R1, #6]
256:           	ucData[7] = (uint8)((pTScope->offlinePtr >> 24) & 0xFF);
0778  E1B6D03     LDR R3, [R0, #80]
077A  71CB0E1B     LSRS R3, R3, #24
077C  232C71CB     STRB R3, [R1, #7]
257:           	ucData[8] = (uint8)((uint32)pTScope->arrayAddr & 0xFF);
077E  18C3232C     MOVS R3, #44
0780  781B18C3     ADDS R3, R0, R3
0782  720B781B     LDRB R3, [R3]
0784  6AC3720B     STRB R3, [R1, #8]
258:           	ucData[9] = (uint8)(((uint32)pTScope->arrayAddr >> 8) & 0xFF);
0786  A1B6AC3     LDR R3, [R0, #44]
0788  724B0A1B     LSRS R3, R3, #8
078A  8DC3724B     STRB R3, [R1, #9]
259:           	ucData[10] = (uint8)(((uint32)pTScope->arrayAddr >> 16) & 0xFF);
078C  728B8DC3     LDRH R3, [R0, #46]
078E  6AC3728B     STRB R3, [R1, #10]
260:           	ucData[11] = (uint8)(((uint32)pTScope->arrayAddr >> 24) & 0xFF);
0790  E1B6AC3     LDR R3, [R0, #44]
0792  72CB0E1B     LSRS R3, R3, #24
0794  236072CB     STRB R3, [R1, #11]
261:           
262:           	ucData[12] = (uint8)(pTScope->trgDelay & 0xFF);
0796  18C32360     MOVS R3, #96
0798  781B18C3     ADDS R3, R0, R3
079A  730B781B     LDRB R3, [R3]
079C  6E03730B     STRB R3, [R1, #12]
263:           	ucData[13] = (uint8)((pTScope->trgDelay >> 8) & 0xFF);
079E  121B6E03     LDR R3, [R0, #96]
07A0  734B121B     ASRS R3, R3, #8
07A2  6E03734B     STRB R3, [R1, #13]
264:           	ucData[14] = (uint8)((pTScope->trgDelay >> 16) & 0xFF);
07A4  141B6E03     LDR R3, [R0, #96]
07A6  738B141B     ASRS R3, R3, #16
07A8  6E03738B     STRB R3, [R1, #14]
265:           	ucData[15] = (uint8)((pTScope->trgDelay >> 24) & 0xFF);
07AA  161B6E03     LDR R3, [R0, #96]
07AC  73CB161B     ASRS R3, R3, #24
07AE  236473CB     STRB R3, [R1, #15]
266:           	ucData[16] = (uint8)(pTScope->trgEventPos & 0xFF);
07B0  18C32364     MOVS R3, #100
07B2  781B18C3     ADDS R3, R0, R3
07B4  740B781B     LDRB R3, [R3]
07B6  6E43740B     STRB R3, [R1, #16]
267:           	ucData[17] = (uint8)((pTScope->trgEventPos >> 8) & 0xFF);
07B8  121B6E43     LDR R3, [R0, #100]
07BA  744B121B     ASRS R3, R3, #8
07BC  6E43744B     STRB R3, [R1, #17]
268:           	ucData[18] = (uint8)((pTScope->trgEventPos >> 16) & 0xFF);
07BE  141B6E43     LDR R3, [R0, #100]
07C0  748B141B     ASRS R3, R3, #16
07C2  6E43748B     STRB R3, [R1, #18]
269:           	ucData[19] = (uint8)((pTScope->trgEventPos >> 24) & 0xFF);
07C4  161B6E43     LDR R3, [R0, #100]
07C6  74CB161B     ASRS R3, R3, #24
07C8  237074CB     STRB R3, [R1, #19]
270:           
271:           	ucData[20] = (uint8)(pTScope->maxUsedLength & 0xFF);
07CA  18C32370     MOVS R3, #112
07CC  781B18C3     ADDS R3, R0, R3
07CE  750B781B     LDRB R3, [R3]
07D0  6F03750B     STRB R3, [R1, #20]
272:           	ucData[21] = (uint8)((pTScope->maxUsedLength >> 8) & 0xFF);
07D2  A1B6F03     LDR R3, [R0, #112]
07D4  754B0A1B     LSRS R3, R3, #8
07D6  6F03754B     STRB R3, [R1, #21]
273:           	ucData[22] = (uint8)((pTScope->maxUsedLength >> 16) & 0xFF);
07D8  C1B6F03     LDR R3, [R0, #112]
07DA  758B0C1B     LSRS R3, R3, #16
07DC  6F03758B     STRB R3, [R1, #22]
274:           	ucData[23] = (uint8)((pTScope->maxUsedLength >> 24) & 0xFF);
07DE  E1B6F03     LDR R3, [R0, #112]
07E0  75CB0E1B     LSRS R3, R3, #24
07E2  233075CB     STRB R3, [R1, #23]
275:           
276:           	ucData[24] = (uint8)(pTScope->arraySize & 0xFF);
07E4  18C32330     MOVS R3, #48
07E6  781B18C3     ADDS R3, R0, R3
07E8  760B781B     LDRB R3, [R3]
07EA  6B03760B     STRB R3, [R1, #24]
277:           	ucData[25] = (uint8)((pTScope->arraySize >> 8) & 0xFF);
07EC  A1B6B03     LDR R3, [R0, #48]
07EE  764B0A1B     LSRS R3, R3, #8
07F0  8E43764B     STRB R3, [R1, #25]
278:           	ucData[26] = (uint8)((pTScope->arraySize >> 16) & 0xFF);
07F2  768B8E43     LDRH R3, [R0, #50]
07F4  6B03768B     STRB R3, [R1, #26]
279:           	ucData[27] = (uint8)((pTScope->arraySize >> 24) & 0xFF);
07F6  E1B6B03     LDR R3, [R0, #48]
07F8  76CB0E1B     LSRS R3, R3, #24
07FA  238276CB     STRB R3, [R1, #27]
280:           
281:           	ucData[28] = (uint8)0x80 + SCOPE_VERSION;
07FC  770B2382     MOVS R3, #130
07FE  201D770B     STRB R3, [R1, #28]
282:           
283:           	return ((uint8)29);
284:           }
0800  4770201D     MOVS R0, #29
0802  B5F04770     BX LR
285:           
286:           /************************************************/
287:           /*  Scope_Main_Save                             */
288:           /************************************************/
289:           uint8 Scope_Main_Save(SCOPE_MAIN *pTScope, uint8 *ucData, uint8 ucFRMlen)
290:           {
0804  46DEB5F0     PUSH {R4, R5, R6, R7, LR}
0806  465746DE     MOV LR, R11
0808  464E4657     MOV R7, R10
080A  4645464E     MOV R6, R9
080C  B5E04645     MOV R5, R8
080E  B083B5E0     PUSH {R5, R6, R7, LR}
0810  4B083     SUB SP, #12
0812  D0004     MOVS R4, R0
0814  4692000D     MOVS R5, R1
0816  27014692     MOV R10, R2
291:              const uint8 offset = (uint8)4;
292:              uint8 i = (uint8)0;
293:              uint8 ptr = offset;
0A0C  E7EA2604     MOVS R6, #4
0A0E  4B6CE7EA     B.N 0x9E6
294:           
295:              uint8 sourceType;
296:              uint16 paramId, elementId, blockId;
297:              void* blockAddr;
298:              tBlockFunctions* blockFunctions;
299:           
300:              if (ucFRMlen < offset)
081A  D8002A03     CMP R2, #3
081C  E0D8D800     BHI.N 0x820
081E  784BE0D8     B.N 0x9D2
301:                  return ((uint8)1);
0818  2A032701     MOVS R7, #1
302:              else
303:              {
304:                  /* send error if selected channels > max channels */
305:                  if (ucData[1] > MAX_SCOPE_CHANNELS)
306:                  {
307:               	   return ((uint8)1);
308:                  }
309:                  /* send error if no channels are configured */
310:                  else if (ucData[1] == (uint8)0)
0820  3B01784B     LDRB R3, [R1, #1]
0822  2B073B01     SUBS R3, #1
0824  D9002B07     CMP R3, #7
0826  E0D3D900     BLS.N 0x82A
0828  2200E0D3     B.N 0x9D2
311:                  {
312:               	   return ((uint8)1);
313:                  }
314:           
315:           	   /* IMPORTANT - DO NOT MOVE THIS SETION TO OTHER PARTS */
316:           	   /* OF THE SAVE FUNCTION */
317:           	   /* set state to idle & number of inputs to 0 to avoid */
318:           	   /* undefined behaviour while updating the addresses */
319:           	   /* & scope values if Scope Update function is */
320:           	   /* executed in sample time irq */
321:           	   pTScope->state = SCOPE_IDLE;
082A  234D2200     MOVS R2, #0
082C  54C2234D     MOVS R3, #77
082E  330854C2     STRB R2, [R0, R3]
322:           	   pTScope->noChannels = (uint8)0;
0830  54C23308     ADDS R3, #8
0832  330554C2     STRB R2, [R0, R3]
323:           
324:                  /* Scope Save Frame contains the following parameters: */
325:                  /* - Scope State (1 byte) */
326:                  /* - Number of Inputs (1 byte) */
327:                  /* - Sample Time Prescaler (2 bytes) */
328:           	   /* - Channel #1 Source type (1 byte) */
329:                  /* - Channel #1 Address (4 bytes) */
330:                  /* - Channel #1 DataType (1 byte) */
331:                  /* - ... */
332:           	   /* - Channel #n Source type (1 byte) */
333:                  /* - Channel #n Address (2 bytes) */
334:                  /* - Channel #n DataType (1 byte) */
335:                  /* - Trigger DataType (1 byte) */
336:           	   /* - Trigger Source type (1 byte) */
337:                  /* - Trigger Address (4 bytes) */
338:                  /* - Trigger Level (length depends on trigger level size) */
339:           	   /* - Trigger Delay (4 bytes) */
340:           	   /* - Trigger Edge (1 byte) */
341:           	   /* - Trigger mode (1 byte) */
342:                  pTScope->timestamp = (uint16)0;
0834  52C23305     ADDS R3, #5
0836  650252C2     STRH R2, [R0, R3]
343:                  pTScope->offlinePtr = (uint32)0;
0838  78C96502     STR R2, [R0, #80]
344:                  pTScope->stf = (uint16)ucData[2] + ((uint16)ucData[3] << 8);
083A  20978C9     LDRB R1, [R1, #3]
083C  78AB0209     LSLS R1, R1, #8
083E  185B78AB     LDRB R3, [R5, #2]
0840  B29B185B     ADDS R3, R3, R1
0842  2156B29B     UXTH R3, R3
0844  52432156     MOVS R1, #86
0846  31025243     STRH R3, [R0, R1]
345:                  pTScope->stfCnt = pTScope->stf;
0848  52433102     ADDS R1, #2
084A  20005243     STRH R3, [R0, R1]
346:                  pTScope->trgLastValue = (int32)0;
084C  21002000     MOVS R0, #0
084E  64202100     MOVS R1, #0
0850  64616420     STR R0, [R4, #64]
0852  23546461     STR R1, [R4, #68]
347:           
348:                  pTScope->dataSizeTotal = (uint8)0;
0854  21002354     MOVS R3, #84
0856  54E12100     MOVS R1, #0
0858  210254E1     STRB R1, [R4, R3]
349:                  /* 2 bytes for 16 bit timestamp */
350:                  pTScope->txFrameSize = (uint8)2;
085A  33082102     MOVS R1, #2
085C  54E13308     ADDS R3, #8
085E  330C54E1     STRB R1, [R4, R3]
351:           
352:           	   pTScope->trgCountReached = (uint8)0;
0860  2100330C     ADDS R3, #12
0862  54E12100     MOVS R1, #0
0864  666254E1     STRB R1, [R4, R3]
353:           	   pTScope->trgEventPos = (int32)0;
0866  786B6662     STR R2, [R4, #100]
354:           
355:                  while (i < ucData[1])
0868  2B00786B     LDRB R3, [R5, #1]
086A  D1002B00     CMP R3, #0
086C  E0CDD100     BNE.N 0x870
086E  2604E0CD     B.N 0xA0C
0870  23002604     MOVS R6, #4
0872  46992300     MOVS R3, #0
0874  2B4699     MOV R9, R3
09AC  785B464B     MOV R3, R9
09AE  42A3785B     LDRB R3, [R3, #1]
09B0  D91642A3     CMP R3, R4
09B2  464BD916     BLS.N 0x9E2
356:                  {
357:               	   sourceType = ucData[ptr];
09B4  5D9B464B     MOV R3, R9
09B6  46985D9B     LDRB R3, [R3, R6]
09B8  1C774698     MOV R8, R3
358:               	   ptr++;
09BA  B2FF1C77     ADDS R7, R6, #1
09BC  2B01B2FF     UXTB R7, R7
359:           
360:               	   switch (sourceType)
09BE  D1002B01     CMP R3, #1
09C0  E75DD100     BNE.N 0x9C4
09C2  2B00E75D     B.N 0x880
09C4  D0C82B00     CMP R3, #0
09C6  2B02D0C8     BEQ.N 0x95A
09C8  D09F2B02     CMP R3, #2
09CA  2B03D09F     BEQ.N 0xB0C
09CC  D0B02B03     CMP R3, #3
09CE  2701D0B0     BEQ.N 0xB32
361:               	   {
362:               	   case SOURCE_TYPE_CONTROLBLOCK:
363:           			   elementId = (uint16)ucData[ptr] + ((uint16)ucData[ptr + 1] << 8);
0880  19DA464B     MOV R3, R9
0882  785119DA     ADDS R2, R3, R7
0884  2097851     LDRB R1, [R2, #1]
0886  5DDB0209     LSLS R1, R1, #8
0888  185B5DDB     LDRB R3, [R3, R7]
088A  B29B185B     ADDS R3, R3, R1
088C  9300B29B     UXTH R3, R3
088E  4BCC9300     STR R3, [SP, #0]
364:           			   paramId = (uint16)ucData[ptr + 2] + ((uint16)ucData[ptr + 3] << 8);
0898  21B78D3     LDRB R3, [R2, #3]
089A  7891021B     LSLS R3, R3, #8
089C  18C97891     LDRB R1, [R2, #2]
089E  B28918C9     ADDS R1, R1, R3
365:           
366:           			   blockAddr = getBlockAddress(TableStruct->TParamTable, paramId);
0890  681B4BCC     LDR R3, $d
0892  469B681B     LDR R3, [R3]
0894  6818469B     MOV R11, R3
0896  78D36818     LDR R0, [R3]
08A0  F7FFB289     UXTH R1, R1
08A2  FDF6F7FF     BL .LFE7, .LFB9
08A4  4684FDF6     LDC2L P6, CR4, [R6, #528]!
08A6  28004684     MOV R12, R0
367:           			   if (blockAddr == (void*)0)
08A8  D1002800     CMP R0, #0
08AA  E1FAD100     BNE.N 0x8AE
08AC  8800E1FA     B.N 0xCA4
368:           			   {
369:           				   return ((uint8)1);
370:           			   }
371:           			   blockId = *(uint16*)blockAddr;
08AE  465B8800     LDRH R0, [R0]
372:           			   blockFunctions = getBlockFunction(TableStruct->TFncTable, blockId);
08B0  685B465B     MOV R3, R11
08B2  469B685B     LDR R3, [R3, #4]
08B4  881B469B     MOV R11, R3
373:           			   if (blockFunctions == (tBlockFunctions*)0)
08F0  D1002B00     CMP R3, #0
08F2  E1DCD100     BNE.N 0x8F6
08F4  695BE1DC     B.N 0xCB0
374:           			   {
375:           				   return ((uint8)1);
376:           			   }
377:           			   pTScope->channelAddr[i] = blockFunctions->pFGetAddress(blockAddr, elementId);
08F6  9900695B     LDR R3, [R3, #20]
08F8  46609900     LDR R1, [SP, #0]
08FA  47984660     MOV R0, R12
08FC  A34798     BLX R3
08FE  18EB00A3     LSLS R3, R4, #2
0900  605818EB     ADDS R3, R5, R3
0902  28006058     STR R0, [R3, #4]
378:           			   if (pTScope->channelAddr[i] == (void*)0)
0904  D1382800     CMP R0, #0
0906  4647D138     BNE.N 0x97A
0908  E0624647     MOV R7, R8
090A  4BADE062     B.N 0x9D2
379:           			   {
380:           				   return ((uint8)1);
381:           			   }
382:           			   break;
383:               	   case SOURCE_TYPE_INPORTBLOCK:
384:               		   paramId = (uint16)ucData[ptr + 2] + ((uint16)ucData[ptr + 3] << 8);
0912  19DA464B     MOV R3, R9
0914  78D319DA     ADDS R2, R3, R7
0916  21B78D3     LDRB R3, [R2, #3]
0918  7891021B     LSLS R3, R3, #8
091A  18C97891     LDRB R1, [R2, #2]
091C  B28918C9     ADDS R1, R1, R3
385:           			   blockAddr = getBlockAddress(TableStruct->TParamTable, paramId);
090C  681B4BAD     LDR R3, $d
090E  6818681B     LDR R3, [R3]
0910  464B6818     LDR R0, [R3]
091E  F7FFB289     UXTH R1, R1
0920  FDB7F7FF     BL .LFE7, .LFB9
0922  2800FDB7     LDC2 P8, CR2, [R7]!
386:           			   if (blockAddr == (void*)0)
0924  D1002800     CMP R0, #0
0926  E1B2D100     BNE.N 0x92A
0928  A3E1B2     B.N 0xC90
387:           			   {
388:           				   return ((uint8)1);
0C90  E69E2701     MOVS R7, #1
0C92  2701E69E     B.N 0x9D2
389:           			   }
390:           			   pTScope->channelAddr[i] = blockAddr;
092A  18EB00A3     LSLS R3, R4, #2
092C  605818EB     ADDS R3, R5, R3
092E  E0236058     STR R0, [R3, #4]
391:               		   break;
0930  4BA4E023     B.N 0x97A
392:               	   case SOURCE_TYPE_OUTPORTBLOCk:
393:               		   paramId = (uint16)ucData[ptr + 2] + ((uint16)ucData[ptr + 3] << 8);
0938  19DA464B     MOV R3, R9
093A  78D319DA     ADDS R2, R3, R7
093C  21B78D3     LDRB R3, [R2, #3]
093E  7891021B     LSLS R3, R3, #8
0940  18C97891     LDRB R1, [R2, #2]
0942  B28918C9     ADDS R1, R1, R3
394:           			   blockAddr = getBlockAddress(TableStruct->TParamTable, paramId);
0876  25002B     MOVS R3, R5
0878  464C0025     MOVS R5, R4
087A  4699464C     MOV R4, R9
087C  E0994699     MOV R9, R3
087E  464BE099     B.N 0x9B4
0932  681B4BA4     LDR R3, [PC, #656]
0934  6818681B     LDR R3, [R3]
0936  464B6818     LDR R0, [R3]
0944  F7FFB289     UXTH R1, R1
0946  FDA4F7FF     BL .LFE7, .LFB9
0948  2800FDA4     STC2 P8, CR2, [R4]!
395:           			   if (blockAddr == (void*)0)
094A  D1002800     CMP R0, #0
094C  E1A1D100     BNE.N 0x950
094E  6802E1A1     B.N 0xC94
396:           			   {
397:           				   return ((uint8)1);
0C94  E69C2701     MOVS R7, #1
0C96  2701E69C     B.N 0x9D2
398:           			   }
399:           			   pTScope->channelAddr[i] = *(void**)blockAddr;
0950  A36802     LDR R2, [R0]
0952  18EB00A3     LSLS R3, R4, #2
0954  605A18EB     ADDS R3, R5, R3
0956  E00F605A     STR R2, [R3, #4]
400:               		   break;
0958  A2E00F     B.N 0x97A
401:               	   case SOURCE_TYPE_ADDRESS:
402:               		   pTScope->channelAddr[i] = (void*)((uint32)ucData[ptr] + ((uint32)ucData[ptr + 1] << 8) + \
095A  18AA00A2     LSLS R2, R4, #2
095C  464B18AA     ADDS R2, R5, R2
095E  19D9464B     MOV R3, R9
0960  784B19D9     ADDS R1, R3, R7
0962  21B784B     LDRB R3, [R1, #1]
0964  7888021B     LSLS R3, R3, #8
096A  4648181B     ADDS R3, R3, R0
096C  5DC04648     MOV R0, R9
096E  181B5DC0     LDRB R0, [R0, R7]
0970  78C9181B     ADDS R3, R3, R0
0978  444F6053     STR R3, [R2, #4]
403:               				   ((uint32)ucData[ptr + 2] << 16) + ((uint32)ucData[ptr + 3] << 24));
0966  4007888     LDRB R0, [R1, #2]
0968  181B0400     LSLS R0, R0, #16
0972  60978C9     LDRB R1, [R1, #3]
0974  185B0609     LSLS R1, R1, #24
0976  6053185B     ADDS R3, R3, R1
404:               		   break;
405:               	   default:
406:               		   return ((uint8)1);
09D0  382701     MOVS R7, #1
407:               	   }
408:           
409:                     pTScope->dataSize[i] = (uint16)ucData[ptr + 4];
097A  793B444F     ADD R7, R9
097C  192A793B     LDRB R3, [R7, #4]
097E  3224192A     ADDS R2, R5, R4
0980  70133224     ADDS R2, #36
0982  22547013     STRB R3, [R2]
410:           
411:                     pTScope->dataSizeTotal += pTScope->dataSize[i];
0984  5CA92254     MOVS R2, #84
0986  18595CA9     LDRB R1, [R5, R2]
0988  B2C91859     ADDS R1, R3, R1
098A  54A9B2C9     UXTB R1, R1
098C  320854A9     STRB R1, [R5, R2]
412:           #if defined(__DATA_WIDTH_16BIT__)
413:                     pTScope->txFrameSize += (pTScope->dataSize[i]*2);
414:           #elif defined(__DATA_WIDTH_8BIT__)
415:                     pTScope->txFrameSize += (pTScope->dataSize[i]);
098E  5CA83208     ADDS R2, #8
0990  181B5CA8     LDRB R0, [R5, R2]
0992  54AB181B     ADDS R3, R3, R0
0994  278054AB     STRB R3, [R5, R2]
416:           #else
417:           #error DATA WIDTH NOT DEFINED
418:           #endif
419:           
420:                     pTScope->maxUsedLength = SCOPE_SIZE - \
09A0  672F1A7F     SUBS R7, R7, R1
09A2  3606672F     STR R7, [R5, #112]
421:                   		  (SCOPE_SIZE % pTScope->dataSizeTotal);
0996  1BF2780     MOVS R7, #128
0998  3801BF     LSLS R7, R7, #6
099A  F0030038     MOVS R0, R7
099C  FCFEF003     BL 0x439C
099E  1A7FFCFE     LDC2L P10, CR1, [LR], #508
422:           
423:                     ptr += (uint8)5;
09A4  B2F63606     ADDS R6, #6
09A6  3401B2F6     UXTB R6, R6
424:                     i++;
09A8  B2E43401     ADDS R4, #1
09AA  464BB2E4     UXTB R4, R4
425:                  }
426:           
427:                  /* trigger parameters */
428:           
429:                  /**
430:                   * Trigger data type:
431:                   * 0b 1000 0000
432:                   *         ++++--- Data type byte size
433:                   *       + ------- reserved
434:                   *      +- ------- Signed (1) / Unsigned (0)
435:                   *     +-- ------- Float (1) / Integer (0)
436:                   *    +--- ------- New Version (1) / Old version (0)
437:                   */
438:                  pTScope->trgDataType = ucData[ptr];
09E6  234C5DAA     LDRB R2, [R5, R6]
09E8  54E2234C     MOVS R3, #76
09EA  1C7354E2     STRB R2, [R4, R3]
439:                  ptr++;
09EC  B2DB1C73     ADDS R3, R6, #1
440:                  sourceType = ucData[ptr];
09EE  5CEFB2DB     UXTB R3, R3
09F0  1CB35CEF     LDRB R7, [R5, R3]
441:                  ptr++;
09F2  B2DB1CB3     ADDS R3, R6, #2
09F4  4698B2DB     UXTB R3, R3
09F6  2F014698     MOV R8, R3
442:                  switch (sourceType)
09F8  D0092F01     CMP R7, #1
09FA  2F00D009     BEQ.N 0xA10
09FC  D0692F00     CMP R7, #0
09FE  2F02D069     BEQ.N 0x9D4
0A00  D0442F02     CMP R7, #2
0A02  2F03D044     BEQ.N 0x98E
0A04  D0532F03     CMP R7, #3
0A06  2701D053     BEQ.N 0x9B0
443:                  {
444:           	   case SOURCE_TYPE_CONTROLBLOCK:
445:           		   elementId = (uint16)ucData[ptr] + ((uint16)ucData[ptr + 1] << 8);
0A70  18AA4642     MOV R2, R8
0A72  785218AA     ADDS R2, R5, R2
0A74  2127852     LDRB R2, [R2, #1]
0A76  46410212     LSLS R2, R2, #8
0A78  5C694641     MOV R1, R8
0A7A  18895C69     LDRB R1, [R5, R1]
0A7C  B2891889     ADDS R1, R1, R2
446:           		   paramId = (uint16)ucData[ptr + 2] + ((uint16)ucData[ptr + 3] << 8);
0A18  18EA4643     MOV R3, R8
0A1A  78D318EA     ADDS R2, R5, R3
0A1C  21B78D3     LDRB R3, [R2, #3]
0A1E  7891021B     LSLS R3, R3, #8
0A20  18C97891     LDRB R1, [R2, #2]
0A22  B28918C9     ADDS R1, R1, R3
447:           
448:           		   blockAddr = getBlockAddress(TableStruct->TParamTable, paramId);
0A10  681B4B6C     LDR R3, $d
0A12  4699681B     LDR R3, [R3]
0A14  68184699     MOV R9, R3
0A16  46436818     LDR R0, [R3]
0A24  F7FFB289     UXTH R1, R1
0A26  FD34F7FF     BL .LFE7, .LFB9
0A28  4684FD34     LDC2 P6, CR4, [R4, #-528]!
0A2A  28004684     MOV R12, R0
449:           		   if (blockAddr == (void*)0)
0A2C  D0D02800     CMP R0, #0
0A2E  8801D0D0     BEQ.N 0x9D2
450:           		   {
451:           			   return ((uint8)1);
452:           		   }
453:           		   blockId = *(uint16*)blockAddr;
0A30  464B8801     LDRH R1, [R0]
454:           		   blockFunctions = getBlockFunction(TableStruct->TFncTable, blockId);
0A32  685B464B     MOV R3, R9
0A34  4699685B     LDR R3, [R3, #4]
0A36  881B4699     MOV R9, R3
455:           		   if (blockFunctions == (tBlockFunctions*)0)
0A6C  D0B02B00     CMP R3, #0
0A6E  4642D0B0     BEQ.N 0xBD2
456:           		   {
457:           			   return ((uint8)1);
458:           		   }
459:           		   pTScope->trgAddr = blockFunctions->pFGetAddress(blockAddr, elementId);
0A7E  695BB289     UXTH R1, R1
0A80  4660695B     LDR R3, [R3, #20]
0A82  47984660     MOV R0, R12
0A84  64A04798     BLX R3
0A86  280064A0     STR R0, [R4, #72]
460:           		   if (pTScope->trgAddr == (void*)0)
0A88  D1302800     CMP R0, #0
0A8A  E7A1D130     BNE.N 0xAEE
0A8C  4B4DE7A1     B.N 0x9D2
461:           		   {
462:           			   return ((uint8)1);
463:           		   }
464:           		   break;
465:           	   case SOURCE_TYPE_INPORTBLOCK:
466:           		   paramId = (uint16)ucData[ptr + 2] + ((uint16)ucData[ptr + 3] << 8);
0A94  18EA4643     MOV R3, R8
0A96  78D318EA     ADDS R2, R5, R3
0A98  21B78D3     LDRB R3, [R2, #3]
0A9A  7891021B     LSLS R3, R3, #8
0A9C  18C97891     LDRB R1, [R2, #2]
0A9E  B28918C9     ADDS R1, R1, R3
467:           		   blockAddr = getBlockAddress(TableStruct->TParamTable, paramId);
0A8E  681B4B4D     LDR R3, [PC, #308]
0A90  6818681B     LDR R3, [R3]
0A92  46436818     LDR R0, [R3]
0AA0  F7FFB289     UXTH R1, R1
0AA2  FCF6F7FF     BL .LFE7, .LFB9
0AA4  2800FCF6     LDC2L P8, CR2, [R6], #0
468:           		   if (blockAddr == (void*)0)
0AA6  D1002800     CMP R0, #0
0AA8  E0F5D100     BNE.N 0xAAC
0AAA  64A0E0F5     B.N 0xC98
469:           		   {
470:           			   return ((uint8)1);
0C98  E69A2701     MOVS R7, #1
0C9A  2701E69A     B.N 0x9D2
471:           		   }
472:           		   pTScope->trgAddr = blockAddr;
0AAC  E01E64A0     STR R0, [R4, #72]
473:           		   break;
0AAE  4B44E01E     B.N 0xAEE
474:           	   case SOURCE_TYPE_OUTPORTBLOCk:
475:           		   paramId = (uint16)ucData[ptr + 2] + ((uint16)ucData[ptr + 3] << 8);
0AB6  18EA4643     MOV R3, R8
0AB8  78D318EA     ADDS R2, R5, R3
0ABA  21B78D3     LDRB R3, [R2, #3]
0ABC  7891021B     LSLS R3, R3, #8
0ABE  18C97891     LDRB R1, [R2, #2]
0AC0  B28918C9     ADDS R1, R1, R3
476:           		   blockAddr = getBlockAddress(TableStruct->TParamTable, paramId);
0AB0  681B4B44     LDR R3, $d
0AB2  6818681B     LDR R3, [R3]
0AB4  46436818     LDR R0, [R3]
0AC2  F7FFB289     UXTH R1, R1
0AC4  FCE5F7FF     BL .LFE7, .LFB9
0AC6  2800FCE5     STC2L P8, CR2, [R5], #0
477:           		   if (blockAddr == (void*)0)
0AC8  D1002800     CMP R0, #0
0ACA  E0E6D100     BNE.N 0xACE
0ACC  6803E0E6     B.N 0xC9C
478:           		   {
479:           			   return ((uint8)1);
0C9C  E6982701     MOVS R7, #1
0C9E  2701E698     B.N 0x9D2
480:           		   }
481:           		   pTScope->trgAddr = *(void**)blockAddr;
0ACE  64A36803     LDR R3, [R0]
0AD0  E00C64A3     STR R3, [R4, #72]
482:           		   break;
0AD2  18EAE00C     B.N 0xAEE
483:           	   case SOURCE_TYPE_ADDRESS:
484:           		   pTScope->trgAddr = (void*)((uint32)ucData[ptr] + ((uint32)ucData[ptr + 1] << 8) + \
0AD4  785318EA     ADDS R2, R5, R3
0AD6  21B7853     LDRB R3, [R2, #1]
0AD8  7891021B     LSLS R3, R3, #8
0ADE  4641185B     ADDS R3, R3, R1
0AE0  5C694641     MOV R1, R8
0AE2  185B5C69     LDRB R1, [R5, R1]
0AE4  78D2185B     ADDS R3, R3, R1
0AEC  1DB764A3     STR R3, [R4, #72]
485:           				   ((uint32)ucData[ptr + 2] << 16) + ((uint32)ucData[ptr + 3] << 24));
0ADA  4097891     LDRB R1, [R2, #2]
0ADC  185B0409     LSLS R1, R1, #16
0AE6  61278D2     LDRB R2, [R2, #3]
0AE8  189B0612     LSLS R2, R2, #24
0AEA  64A3189B     ADDS R3, R3, R2
486:           		   break;
487:           	   default:
488:           		   return ((uint8)1);
0A08  E7E22701     MOVS R7, #1
0A0A  2604E7E2     B.N 0x9D2
489:                  }
490:                  ptr += (uint8)4;
0AEE  B2FB1DB7     ADDS R7, R6, #6
0AF0  4698B2FB     UXTB R3, R7
0AF2  234C4698     MOV R8, R3
491:           
492:                  {
493:               	   uint8 trgLevelSize = pTScope->trgDataType & (uint8)0x0F;
0AF4  5CE3234C     MOVS R3, #76
0AF6  469C5CE3     LDRB R3, [R4, R3]
0AF8  270F469C     MOV R12, R3
0AFA  401F270F     MOVS R7, #15
0AFC  2F02401F     ANDS R7, R3
494:               	   uint8 isNewVersion = pTScope->trgDataType & (uint8)0x80;
495:           
496:               	   switch (trgLevelSize)
0AFE  D1002F02     CMP R7, #2
0B00  E098D100     BNE.N 0xB04
0B02  D960E098     B.N 0xC36
0B04  2F04D960     BLS.N .LVL266
0B06  D1002F04     CMP R7, #4
0B08  E09FD100     BNE.N 0xB0C
0B0A  2F08E09F     B.N 0xC4C
0B0C  D0002F08     CMP R7, #8
0B0E  E0C6D000     BEQ.N 0xB12
0B10  46A9E0C6     B.N 0xCA0
0BC8  D1692F01     CMP R7, #1
0BCA  4643D169     BNE.N 0xBA0
497:               	   {
498:               	   case 1:
499:               		   pTScope->trgLevel = (uint8)ucData[ptr];
0BCC  5CEB4643     MOV R3, R8
0BCE  63A35CEB     LDRB R3, [R5, R3]
0BD0  230063A3     STR R3, [R4, #56]
0BD2  63E32300     MOVS R3, #0
0BD4  466363E3     STR R3, [R4, #60]
500:               		   break;
501:               	   case 2:
502:               		   pTScope->trgLevel = (uint16)ucData[ptr] + ((uint16)ucData[ptr + 1] << 8);
0C36  18EB4643     MOV R3, R8
0C38  785B18EB     ADDS R3, R5, R3
0C3A  21B785B     LDRB R3, [R3, #1]
0C3C  4642021B     LSLS R3, R3, #8
0C3E  5CAA4642     MOV R2, R8
0C40  189B5CAA     LDRB R2, [R5, R2]
0C42  63A3189B     ADDS R3, R3, R2
0C44  17DB63A3     STR R3, [R4, #56]
0C46  63E317DB     ASRS R3, R3, #31
0C48  E7C463E3     STR R3, [R4, #60]
503:               		   break;
0C4A  4643E7C4     B.N 0xBD6
504:               	   case 4:
505:               		   pTScope->trgLevel = (uint32)ucData[ptr] + ((uint32)ucData[ptr + 1] << 8) + \
0C4C  18EA4643     MOV R3, R8
0C4E  785318EA     ADDS R2, R5, R3
0C50  21B7853     LDRB R3, [R2, #1]
0C52  7891021B     LSLS R3, R3, #8
0C58  4641185B     ADDS R3, R3, R1
0C5A  5C694641     MOV R1, R8
0C5C  185B5C69     LDRB R1, [R5, R1]
0C5E  78D2185B     ADDS R3, R3, R1
506:               		   	   ((uint32)ucData[ptr + 2] << 16) + ((uint32)ucData[ptr + 3] << 24);
0C54  4097891     LDRB R1, [R2, #2]
0C56  185B0409     LSLS R1, R1, #16
0C60  61278D2     LDRB R2, [R2, #3]
0C62  189B0612     LSLS R2, R2, #24
0C64  63A3189B     ADDS R3, R3, R2
0C66  230063A3     STR R3, [R4, #56]
0C68  63E32300     MOVS R3, #0
0C6A  E7B363E3     STR R3, [R4, #60]
507:               		   break;
0C6C  3EE7B3     B.N 0xBD6
508:               	   case 8:
509:               		   pTScope->trgLevel = (uint64)ucData[ptr] + ((uint64)ucData[ptr + 1] << 8) + \
0B12  44C146A9     MOV R9, R5
0B14  464B44C1     ADD R9, R8
0B16  785B464B     MOV R3, R9
0B18  2100785B     LDRB R3, [R3, #1]
0B1A  22002100     MOVS R1, #0
0B1C  91002200     MOVS R2, #0
0B1E  92019100     STR R1, [SP, #0]
0B20  21B9201     STR R2, [SP, #4]
0B22  9300021B     LSLS R3, R3, #8
0B24  464B9300     STR R3, [SP, #0]
0B32  99019800     LDR R0, [SP, #0]
0B34  18809901     LDR R1, [SP, #4]
0B36  41591880     ADDS R0, R0, R2
0B38  90004159     ADCS R1, R3
0B3A  91019000     STR R0, [SP, #0]
0B3C  46419101     STR R1, [SP, #4]
0B3E  5C6A4641     MOV R1, R8
0B40  23005C6A     LDRB R2, [R5, R1]
0B42  98002300     MOVS R3, #0
0B44  99019800     LDR R0, [SP, #0]
0B46  18809901     LDR R1, [SP, #4]
0B48  41591880     ADDS R0, R0, R2
0B4A  90004159     ADCS R1, R3
0B4C  91019000     STR R0, [SP, #0]
0B4E  46499101     STR R1, [SP, #4]
0BBE  63E363A2     STR R2, [R4, #56]
0BC0  E00863E3     STR R3, [R4, #60]
510:               		   	   ((uint64)ucData[ptr + 2] << 16) + ((uint64)ucData[ptr + 3] << 24) + \
0B26  789B464B     MOV R3, R9
0B28  469B789B     LDRB R3, [R3, #2]
0B2A  2300469B     MOV R11, R3
0B2C  46592300     MOVS R3, #0
0B2E  40A4659     MOV R1, R11
0B30  9800040A     LSLS R2, R1, #16
0B50  78C94649     MOV R1, R9
0B52  468B78C9     LDRB R1, [R1, #3]
0B54  2100468B     MOV R11, R1
0B56  465B2100     MOVS R1, #0
0B58  618465B     MOV R3, R11
0B5A  9A000618     LSLS R0, R3, #24
0B5C  9B019A00     LDR R2, [SP, #0]
0B5E  18129B01     LDR R3, [SP, #4]
0B60  414B1812     ADDS R2, R2, R0
0B62  9200414B     ADCS R3, R1
0B64  93019200     STR R2, [SP, #0]
0B66  22009301     STR R3, [SP, #4]
0B6E  99019800     LDR R0, [SP, #0]
0B70  18809901     LDR R1, [SP, #4]
0B72  41591880     ADDS R0, R0, R2
0B74  90004159     ADCS R1, R3
0B76  91019000     STR R0, [SP, #0]
0B78  464B9101     STR R1, [SP, #4]
511:               		       ((uint64)ucData[ptr + 4] << 32) + ((uint64)ucData[ptr + 5] << 40) + \
0B68  46492200     MOVS R2, #0
0B6A  790B4649     MOV R1, R9
0B6C  9800790B     LDRB R3, [R1, #4]
0B7A  795B464B     MOV R3, R9
0B7C  469B795B     LDRB R3, [R3, #5]
0B7E  2200469B     MOV R11, R3
0B80  46592200     MOVS R2, #0
0B82  20B4659     MOV R1, R11
0B84  9800020B     LSLS R3, R1, #8
0B86  99019800     LDR R0, [SP, #0]
0B88  18809901     LDR R1, [SP, #4]
0B8A  41591880     ADDS R0, R0, R2
0B8C  90004159     ADCS R1, R3
0B8E  91019000     STR R0, [SP, #0]
0B90  46499101     STR R1, [SP, #4]
0B9E  9B019A00     LDR R2, [SP, #0]
0BA0  18129B01     LDR R3, [SP, #4]
0BA2  414B1812     ADDS R2, R2, R0
0BA4  9200414B     ADCS R3, R1
0BA6  93019200     STR R2, [SP, #0]
0BA8  464B9301     STR R3, [SP, #4]
512:               		       ((uint64)ucData[ptr + 6] << 48) + ((uint64)ucData[ptr + 7] << 56);
0B92  79894649     MOV R1, R9
0B94  468B7989     LDRB R1, [R1, #6]
0B96  2000468B     MOV R11, R1
0B98  465B2000     MOVS R0, #0
0B9A  419465B     MOV R3, R11
0B9C  9A000419     LSLS R1, R3, #16
0BAA  79DB464B     MOV R3, R9
0BAC  469979DB     LDRB R3, [R3, #7]
0BAE  22004699     MOV R9, R3
0BB0  46492200     MOVS R2, #0
0BB2  60B4649     MOV R1, R9
0BB4  9800060B     LSLS R3, R1, #24
0BB6  99019800     LDR R0, [SP, #0]
0BB8  18129901     LDR R1, [SP, #4]
0BBA  414B1812     ADDS R2, R2, R0
0BBC  63A2414B     ADCS R3, R1
513:               		   break;
0BC2  2904E008     B.N 0xBD6
0BC4  20002904     CMP R1, #4
0BC6  2F012000     MOVS R0, #0
514:               	   default:
515:               		   /* data size not supported */
516:               		   return ((uint8)1);
0CA0  E6962701     MOVS R7, #1
0CA2  4647E696     B.N 0x9D2
0CA4  E6944647     MOV R7, R8
0CA6  4647E694     B.N 0x9D2
0CA8  E6924647     MOV R7, R8
0CAA  4647E692     B.N 0x9D2
0CAC  E6904647     MOV R7, R8
0CAE  4647E690     B.N 0x9D2
0CB0  E68E4647     MOV R7, R8
0CB2  2000E68E     B.N 0x9D2
517:               	   }
518:           
519:               	   if (!isNewVersion)
0BD6  466A4663     MOV R3, R12
0BD8  7013466A     MOV R2, SP
0BDA  78137013     STRB R3, [R2]
0BDC  B25B7813     LDRB R3, [R2]
0BDE  2B00B25B     SXTB R3, R3
0BE0  DB442B00     CMP R3, #0
0BE2  2320DB44     BLT.N 0xB6E
520:               	   {
521:               		   pTScope->trgDataType |= (uint8)0x20;
0BE4  46622320     MOVS R3, #32
0BE6  431A4662     MOV R2, R12
0BE8  13431A     ORRS R2, R3
0BEA  224C0013     MOVS R3, R2
0BEC  54A3224C     MOVS R2, #76
0BEE  360A54A3     STRB R3, [R4, R2]
522:               		   ptr += (uint8)4;
0BF0  B2F6360A     ADDS R6, #10
0BF2  19ABB2F6     UXTB R6, R6
523:               	   }
524:               	   else
525:               	   {
526:               		   ptr += trgLevelSize;
0C6E  4446003E     MOVS R6, R7
0C70  B2F64446     ADD R6, R8
0C72  E7BEB2F6     UXTB R6, R6
0C74  20E7BE     B.N 0xBF4
527:               	   }
528:                  }
529:           
530:           	   pTScope->trgDelay = ((int32)ucData[ptr] + ((int32)ucData[ptr + 1] << 8) + ((int32)ucData[ptr + 2] << 16) + \
0BF4  785819AB     ADDS R3, R5, R6
0BF6  2007858     LDRB R0, [R3, #1]
0BF8  5DAA0200     LSLS R0, R0, #8
0BFA  18805DAA     LDRB R2, [R5, R6]
0BFC  789A1880     ADDS R0, R0, R2
0BFE  412789A     LDRB R2, [R3, #2]
0C00  18800412     LSLS R2, R2, #16
0C02  78DB1880     ADDS R0, R0, R2
0C08  662018C0     ADDS R0, R0, R3
0C0A  F0036620     STR R0, [R4, #96]
531:           			   ((int32)ucData[ptr + 3] << 24));
0C04  61B78DB     LDRB R3, [R3, #3]
0C06  18C0061B     LSLS R3, R3, #24
532:           	   pTScope->trgCount = (uint32)getAbsValI32(pTScope->trgDelay);
0C0C  FFEAF003     BL getAbsValI32
0C0E  66E0FFEA     CDP2 P6, #14, CR6, CR10, CR0, {7}
0C10  1D3366E0     STR R0, [R4, #108]
533:           	   ptr += (uint8)4;
0C12  B2DB1D33     ADDS R3, R6, #4
534:           
535:           	   pTScope->trgEdge = (tTrgEdgeType)ucData[ptr];
0C14  5CEAB2DB     UXTB R3, R3
0C16  23745CEA     LDRB R2, [R5, R3]
0C18  54E22374     MOVS R3, #116
0C1A  360554E2     STRB R2, [R4, R3]
536:                  ptr++;
0C1C  B2F63605     ADDS R6, #5
0C1E  45B2B2F6     UXTB R6, R6
537:                  
538:                  /* check if trigger mode information is being sent (compatibility check for previous Scope versions) */
539:                  if (ucFRMlen > ptr)
0C20  D92845B2     CMP R10, R6
0C22  5DABD928     BLS.N 0xC76
540:                  {
541:                      /* get current trigger value if trigger mode is set to NORMAL */
542:                      if (ucData[ptr] == TRG_MODE_NORMAL)
0C24  2B015DAB     LDRB R3, [R5, R6]
0C26  D12A2B01     CMP R3, #1
0C28  20D12A     BNE.N 0xC80
543:                      {
544:                          /* current value @ trg addr = last trg value */
545:                          /* (avoids immediate trg event due to default last */
546:                          /* trg value = 0 and current trg value > trg level */
547:                          pTScope->trgLastValue = getTriggerValue(pTScope);
0C2A  F7FF0020     MOVS R0, R4
0C2C  FBF3F7FF     BL .LFE5, .LFB6
0C30  64616420     STR R0, [R4, #64]
0C32  E0246461     STR R1, [R4, #68]
0C34  4643E024     B.N 0xC80
548:                      }
549:                  }
550:                  else
551:                  {
552:                      pTScope->trgLastValue = getTriggerValue(pTScope);
0C76  F7FF0020     MOVS R0, R4
0C78  FBCDF7FF     BL .LFE5, .LFB6
0C7A  6420FBCD     SMLAL R6, R4, SP, R0
0C7C  64616420     STR R0, [R4, #64]
0C7E  786A6461     STR R1, [R4, #68]
553:                  }
554:           
555:           	   /* IMPORTANT - DO NOT MOVE THIS SETION TO OTHER PARTS */
556:           	   /* OF THE SAVE FUNCTION */
557:           	   /* 'number of inputs' & 'state' moved to end of save function */
558:           	   /* to avoid undefined behaviour if save function is */
559:           	   /* interrupted by sample time irq & program is executed */
560:           	   /* in sample time irq */
561:           	   pTScope->noChannels = ucData[1];
0C80  2355786A     LDRB R2, [R5, #1]
0C82  54E22355     MOVS R3, #85
0C84  782A54E2     STRB R2, [R4, R3]
562:           	   pTScope->state = (tScopeState)ucData[0];
0C86  3B08782A     LDRB R2, [R5]
0C88  54E23B08     SUBS R3, #8
0C8A  270054E2     STRB R2, [R4, R3]
563:           
564:                  return ((uint8)0);
0C8C  E6A02700     MOVS R7, #0
0C8E  2701E6A0     B.N 0x9D2
565:              }
566:           }
09D2  B0030038     MOVS R0, R7
09D4  BC3CB003     ADD SP, #12
09D6  4690BC3C     POP {R2, R3, R4, R5}
09D8  46994690     MOV R8, R2
09DA  46A24699     MOV R9, R3
09DC  46AB46A2     MOV R10, R4
09DE  BDF046AB     MOV R11, R5
09E0  2CBDF0     POP {R4, R5, R6, R7, PC}
09E2  464D002C     MOVS R4, R5
09E4  5DAA464D     MOV R5, R9
567:           
568:           /**
569:            * Returns block element address.
570:            */
571:           void* Scope_Main_GetAddress(const SCOPE_MAIN* block, uint16 elementId)
572:           {
573:           	/* Scope doesn't have any elements so return null pointer */
574:           	void* addr = (void*)0;
575:           	return (addr);
576:           }
0CB4  47702000     MOVS R0, #0
577:           
578:           
579:           /* this function will return 1, if the trigger was hit and */
580:           /* 0, if the trigger was not hit */
581:           static uint8 isTriggerEvent(SCOPE_MAIN *pTScope, uint64 curTrgValue)
582:           {
00E0  B085B5F0     PUSH {R4, R5, R6, R7, LR}
00E2  9202B085     SUB SP, #20
00E4  93039202     STR R2, [SP, #8]
583:           	uint8 size = pTScope->trgDataType & (uint8)0x0F;
00E8  5CC2234C     MOVS R3, #76
00EA  3B3D5CC2     LDRB R2, [R0, R3]
584:           	uint8 isFloat = pTScope->trgDataType & (uint8)0x40;
585:           	uint8 isEvent = (uint8)0;
00FE  B0052000     MOVS R0, #0
040A  E6782000     MOVS R0, #0
040C  2000E678     B.N 0x100
040E  E6762000     MOVS R0, #0
0410  2000E676     B.N 0x100
586:           	if (isFloat)
00F0  D4000651     LSLS R1, R2, #25
587:           	{
588:           		switch (size)
00F6  D0042B04     CMP R3, #4
589:           		{
590:           			case 4:
591:           			{
592:           				float32 trgLastValue = *(float32*)&pTScope->trgLastValue;
0104  6B846C03     LDR R3, [R0, #64]
593:           				float32 trgLevel = *(float32*)&pTScope->trgLevel;
0106  9D026B84     LDR R4, [R0, #56]
594:           				float32 curValue = *(float32*)&curTrgValue;
0108  22749D02     LDR R5, [SP, #8]
595:           				if (pTScope->trgEdge == EDGE_RISING)
010A  5C822274     MOVS R2, #116
596:           				{
597:           					if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
0134  1C181C21     ADDS R1, R4, #0
0136  F0051C18     ADDS R0, R3, #0
0138  FAEAF005     BL 0x5710
013A  2800FAEA     SSAX R8, R10, R0
013C  D1002800     CMP R0, #0
013E  E15BD100     BNE.N 0x142
0140  2601E15B     B.N 0x3FA
0142  1C292601     MOVS R6, #1
0144  1C201C29     ADDS R1, R5, #0
0146  F0051C20     ADDS R0, R4, #0
0148  FAECF005     BL 0x5724
014A  2800FAEC     SSAX R8, R12, R0
014C  D1002800     CMP R0, #0
014E  2600D100     BNE.N 0x152
0150  B2F02600     MOVS R6, #0
598:           					{
599:           						isEvent = (uint8)1;
600:           					}
601:           					else
602:           					{
603:           						isEvent = (uint8)0;
03FA  E6802000     MOVS R0, #0
03FC  2000E680     B.N 0x100
604:           					}
605:           				}
606:           				else
607:           				{
608:           					if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
0112  1C181C21     ADDS R1, R4, #0
0120  1C292601     MOVS R6, #1
0122  1C201C29     ADDS R1, R5, #0
0124  F0051C20     ADDS R0, R4, #0
0126  FB11F005     BL 0x574C
0128  2800FB11     SMLABB R8, R1, R0, R2
012A  D1002800     CMP R0, #0
012C  2600D100     BNE.N 0x130
012E  B2F02600     MOVS R6, #0
609:           					{
610:           						isEvent = (uint8)1;
0130  E7E5B2F0     UXTB R0, R6
0132  1C21E7E5     B.N 0x100
0152  E7D4B2F0     UXTB R0, R6
0154  6C06E7D4     B.N 0x100
0198  E7B1B2F0     UXTB R0, R6
019A  22E7B1     B.N 0x100
01C2  E79CB2F0     UXTB R0, R6
01C4  692E79C     B.N 0x100
0202  E77CB2C0     UXTB R0, R0
0204  2B01E77C     B.N 0x100
023A  E760B2C0     UXTB R0, R0
023C  2000E760     B.N 0x100
024E  E756B2C0     UXTB R0, R0
0250  2340E756     B.N 0x100
027C  E73FB2C0     UXTB R0, R0
027E  2000E73F     B.N 0x100
0290  E735B2C0     UXTB R0, R0
0292  6C01E735     B.N 0x100
02B2  E724B2C0     UXTB R0, R0
02B4  2000E724     B.N 0x100
02C6  E71AB2C0     UXTB R0, R0
02C8  4293E71A     B.N 0x100
02DC  E70FB2C0     UXTB R0, R0
02DE  4293E70F     B.N 0x100
0336  E6E2B2C0     UXTB R0, R0
0338  2B01E6E2     B.N 0x100
0362  E6CCB2C0     UXTB R0, R0
0364  2000E6CC     B.N 0x100
0372  E6C4B2C0     UXTB R0, R0
0374  2340E6C4     B.N 0x100
0396  E6B2B2C0     UXTB R0, R0
0398  2000E6B2     B.N 0x100
03A6  E6AAB2C0     UXTB R0, R0
03A8  6C02E6AA     B.N 0x100
03C4  E69BB2C0     UXTB R0, R0
03C6  2000E69B     B.N 0x100
03D4  E693B2C0     UXTB R0, R0
03D6  4293E693     B.N 0x100
03EA  E688B2C0     UXTB R0, R0
03EC  4293E688     B.N 0x100
611:           					}
612:           					else
613:           					{
614:           						isEvent = (uint8)0;
03FE  E67E2000     MOVS R0, #0
0400  2000E67E     B.N 0x100
615:           					}
616:           				}
617:           				break;
618:           			}
619:           			case 8:
620:           			{
621:           				float64 trgLastValue = *(float64*)&pTScope->trgLastValue;
0156  6C476C06     LDR R6, [R0, #64]
0158  6B846C47     LDR R7, [R0, #68]
622:           				float64 trgLevel = *(float64*)&pTScope->trgLevel;
015A  6BC56B84     LDR R4, [R0, #56]
015C  9A026BC5     LDR R5, [R0, #60]
623:           				float64 curValue = *(float64*)&curTrgValue;
015E  9B039A02     LDR R2, [SP, #8]
0160  92009B03     LDR R3, [SP, #12]
0162  93019200     STR R2, [SP, #0]
0164  23749301     STR R3, [SP, #4]
624:           				if (pTScope->trgEdge == EDGE_RISING)
0166  5CC32374     MOVS R3, #116
0168  2B015CC3     LDRB R3, [R0, R3]
016A  D0162B01     CMP R3, #1
016C  22D016     BEQ.N 0x19C
625:           				{
626:           					if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
019C  2B0022     MOVS R2, R4
019E  30002B     MOVS R3, R5
01A0  390030     MOVS R0, R6
01A2  F0050039     MOVS R1, R7
01A4  FA40F005     BL 0x5628
01A6  2800FA40     ASR.W R8, R0, R0
01A8  D1002800     CMP R0, #0
01AA  E129D100     BNE.N 0x1AE
01AC  2601E129     B.N 0x402
01AE  9A002601     MOVS R6, #1
01B0  9B019A00     LDR R2, [SP, #0]
01B2  209B01     LDR R3, [SP, #4]
01B4  290020     MOVS R0, R4
01B6  F0050029     MOVS R1, R5
01B8  FA40F005     BL 0x563C
01BA  2800FA40     ASR.W R8, R0, R0
01BC  D1002800     CMP R0, #0
01BE  2600D100     BNE.N 0x1C2
01C0  B2F02600     MOVS R6, #0
627:           					{
628:           						isEvent = (uint8)1;
629:           					}
630:           					else
631:           					{
632:           						isEvent = (uint8)0;
0402  E67C2000     MOVS R0, #0
0404  2000E67C     B.N 0x100
633:           					}
634:           				}
635:           				else
636:           				{
637:           					if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
016E  2B0022     MOVS R2, R4
0170  30002B     MOVS R3, R5
0172  390030     MOVS R0, R6
0174  F0050039     MOVS R1, R7
0176  FA6BF005     BL 0x5650
0178  2800FA6B     ROR.W R8, R11, R0
017A  D1002800     CMP R0, #0
017C  E142D100     BNE.N 0x180
017E  2301E142     B.N 0x406
0180  1C1E2301     MOVS R3, #1
0182  9A001C1E     ADDS R6, R3, #0
0184  9B019A00     LDR R2, [SP, #0]
0186  209B01     LDR R3, [SP, #4]
0188  290020     MOVS R0, R4
018A  F0050029     MOVS R1, R5
018C  FA6AF005     BL 0x5664
018E  2800FA6A     ROR.W R8, R10, R0
0190  D1012800     CMP R0, #0
0192  2300D101     BNE.N 0x198
0194  1C1E2300     MOVS R3, #0
0196  B2F01C1E     ADDS R6, R3, #0
638:           					{
639:           						isEvent = (uint8)1;
640:           					}
641:           					else
642:           					{
643:           						isEvent = (uint8)0;
0406  E67A2000     MOVS R0, #0
0408  2000E67A     B.N 0x100
644:           					}
645:           				}
646:           				break;
647:           			}
648:           		}
649:           	}
650:           	else
651:           	{
652:           		uint8 isSigned = pTScope->trgDataType & (uint8)0x20;
653:           		if (isSigned)
01C6  D4000692     LSLS R2, R2, #26
01C8  E096D400     BMI.N 0x1CC
01CA  2B02E096     B.N 0x2FA
654:           		{
655:           			switch (size)
01CC  D0402B02     CMP R3, #2
01CE  D919D040     BEQ.N 0x152
01D0  2B04D919     BLS.N 0x206
01D2  D05E2B04     CMP R3, #4
01D4  2B08D05E     BEQ.N 0x194
01D6  D0002B08     CMP R3, #8
01D8  E116D000     BEQ.N 0x1DC
01DA  6C06E116     B.N 0x40A
0206  D0002B01     CMP R3, #1
0208  E0FED000     BEQ.N 0x20C
020A  2340E0FE     B.N 0x40A
656:           			{
657:           				case 1:
658:           				{
659:           					int8 trgLastValue = (int8)pTScope->trgLastValue;
020C  18C32340     MOVS R3, #64
020E  210018C3     ADDS R3, R0, R3
0210  56592100     MOVS R1, #0
0212  23385659     LDRSB R1, [R3, R1]
660:           					int8 trgLevel = (int8)pTScope->trgLevel;
0214  18C32338     MOVS R3, #56
0216  781B18C3     ADDS R3, R0, R3
0218  B25B781B     LDRB R3, [R3]
021A  AA02B25B     SXTB R3, R3
661:           					int8 curValue = (int8)curTrgValue;
021C  7812AA02     ADD R2, SP, #8
021E  B2527812     LDRB R2, [R2]
0220  2474B252     SXTB R2, R2
662:           					if (pTScope->trgEdge == EDGE_RISING)
0222  5D002474     MOVS R4, #116
0224  28015D00     LDRB R0, [R0, R4]
0226  D0092801     CMP R0, #1
0228  2000D009     BEQ.N 0x23E
663:           					{
664:           						if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
0240  DB004299     CMP R1, R3
0242  E75CDB00     BLT.N 0x246
0244  FD8E75C     B.N 0x100
0246  17D10FD8     LSRS R0, R3, #31
0248  429A17D1     ASRS R1, R2, #31
024A  4148429A     CMP R2, R3
024C  B2C04148     ADCS R0, R1
665:           						{
666:           							isEvent = (uint8)1;
667:           						}
668:           						else
669:           						{
670:           							isEvent = (uint8)0;
023E  42992000     MOVS R0, #0
671:           						}
672:           					}
673:           					else
674:           					{
675:           						if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
022C  DC004299     CMP R1, R3
022E  E766DC00     BGT.N 0x232
0230  17D8E766     B.N 0x100
0232  FD117D8     ASRS R0, R3, #31
0234  42930FD1     LSRS R1, R2, #31
0236  41484293     CMP R3, R2
0238  B2C04148     ADCS R0, R1
676:           						{
677:           							isEvent = (uint8)1;
678:           						}
679:           						else
680:           						{
681:           							isEvent = (uint8)0;
022A  42992000     MOVS R0, #0
682:           						}
683:           					}
684:           					break;
685:           				}
686:           				case 2:
687:           				{
688:           					int16 trgLastValue = (int16)pTScope->trgLastValue;
0252  18C32340     MOVS R3, #64
0254  220018C3     ADDS R3, R0, R3
0256  5E9A2200     MOVS R2, #0
0258  23385E9A     LDRSH R2, [R3, R2]
689:           					int16 trgLevel = (int16)pTScope->trgLevel;
025A  5EC12338     MOVS R3, #56
025C  AB025EC1     LDRSH R1, [R0, R3]
690:           					int16 curValue = (int16)curTrgValue;
025E  2400AB02     ADD R3, SP, #8
0260  5F1B2400     MOVS R4, #0
0262  24745F1B     LDRSH R3, [R3, R4]
691:           					if (pTScope->trgEdge == EDGE_RISING)
0264  5D002474     MOVS R4, #116
0266  28015D00     LDRB R0, [R0, R4]
0268  D0092801     CMP R0, #1
026A  2000D009     BEQ.N 0x280
692:           					{
693:           						if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
0282  DB00428A     CMP R2, R1
0284  E73BDB00     BLT.N 0x288
0286  FC8E73B     B.N 0x100
0288  17DA0FC8     LSRS R0, R1, #31
028A  428B17DA     ASRS R2, R3, #31
028C  4150428B     CMP R3, R1
028E  B2C04150     ADCS R0, R2
694:           						{
695:           							isEvent = (uint8)1;
696:           						}
697:           						else
698:           						{
699:           							isEvent = (uint8)0;
0280  428A2000     MOVS R0, #0
700:           						}
701:           					}
702:           					else
703:           					{
704:           						if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
026E  DC00428A     CMP R2, R1
0270  E745DC00     BGT.N 0x274
0272  17C8E745     B.N 0x100
0274  FDA17C8     ASRS R0, R1, #31
0276  42990FDA     LSRS R2, R3, #31
0278  41504299     CMP R1, R3
027A  B2C04150     ADCS R0, R2
705:           						{
706:           							isEvent = (uint8)1;
707:           						}
708:           						else
709:           						{
710:           							isEvent = (uint8)0;
026C  428A2000     MOVS R0, #0
711:           						}
712:           					}
713:           					break;
714:           				}
715:           				case 4:
716:           				{
717:           					int32 trgLastValue = (int32)pTScope->trgLastValue;
0294  6B836C01     LDR R1, [R0, #64]
718:           					int32 trgLevel = (int32)pTScope->trgLevel;
0296  9A026B83     LDR R3, [R0, #56]
719:           					int32 curValue = (int32)curTrgValue;
0298  24749A02     LDR R2, [SP, #8]
720:           					if (pTScope->trgEdge == EDGE_RISING)
029A  5D002474     MOVS R4, #116
029C  28015D00     LDRB R0, [R0, R4]
029E  D0092801     CMP R0, #1
02A0  2000D009     BEQ.N 0x2B6
721:           					{
722:           						if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
02B8  DB004299     CMP R1, R3
02BA  E720DB00     BLT.N 0x2BE
02BC  FD8E720     B.N 0x100
02BE  17D10FD8     LSRS R0, R3, #31
02C0  429A17D1     ASRS R1, R2, #31
02C2  4148429A     CMP R2, R3
02C4  B2C04148     ADCS R0, R1
723:           						{
724:           							isEvent = (uint8)1;
725:           						}
726:           						else
727:           						{
728:           							isEvent = (uint8)0;
02B6  42992000     MOVS R0, #0
729:           						}
730:           					}
731:           					else
732:           					{
733:           						if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
02A4  DC004299     CMP R1, R3
02A6  E72ADC00     BGT.N 0x2AA
02A8  17D8E72A     B.N 0x100
02AA  FD117D8     ASRS R0, R3, #31
02AC  42930FD1     LSRS R1, R2, #31
02AE  41484293     CMP R3, R2
02B0  B2C04148     ADCS R0, R1
734:           						{
735:           							isEvent = (uint8)1;
736:           						}
737:           						else
738:           						{
739:           							isEvent = (uint8)0;
02A2  42992000     MOVS R0, #0
740:           						}
741:           					}
742:           					break;
743:           				}
744:           				case 8:
745:           				{
746:           					int64 trgLastValue = (int64)pTScope->trgLastValue;
01DC  6C426C06     LDR R6, [R0, #64]
01DE  6B856C42     LDR R2, [R0, #68]
747:           					int64 trgLevel = (int64)pTScope->trgLevel;
01E0  6BC36B85     LDR R5, [R0, #56]
01E2  9F026BC3     LDR R3, [R0, #60]
748:           					int64 curValue = (int64)curTrgValue;
01E4  9C039F02     LDR R7, [SP, #8]
01E6  21749C03     LDR R4, [SP, #12]
749:           					if (pTScope->trgEdge == EDGE_RISING)
01E8  5C412174     MOVS R1, #116
01EA  29015C41     LDRB R1, [R0, R1]
01EC  D06C2901     CMP R1, #1
01EE  429AD06C     BEQ.N 0x1CA
750:           					{
751:           						if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
02CA  DD084293     CMP R3, R2
02CC  2001DD08     BLE.N 0x2E0
02CE  42A32001     MOVS R0, #1
02D0  DC0242A3     CMP R3, R4
02D2  D102DC02     BGT.N 0x2DA
02D4  42BDD102     BNE.N 0x2DC
02D6  D90042BD     CMP R5, R7
02D8  2000D900     BLS.N 0x2DC
02DA  B2C02000     MOVS R0, #0
02E0  D1014293     CMP R3, R2
02E2  42B5D101     BNE.N communicate::LNet_OnlineScope
02E4  D8F242B5     CMP R5, R6
02E6  2000D8F2     BHI.N 0x2CE
752:           						{
753:           							isEvent = (uint8)1;
754:           						}
755:           						else
756:           						{
757:           							isEvent = (uint8)0;
02E8  E7092000     MOVS R0, #0
02EA  429AE709     B.N 0x100
758:           						}
759:           					}
760:           					else
761:           					{
762:           						if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
01F0  DD7B429A     CMP R2, R3
01F2  2001DD7B     BLE.N 0x1EC
01F4  429C2001     MOVS R0, #1
01F6  DC02429C     CMP R4, R3
01F8  D102DC02     BGT.N 0x200
01FA  42AFD102     BNE.N 0x202
01FC  D90042AF     CMP R7, R5
01FE  2000D900     BLS.N 0x202
0200  B2C02000     MOVS R0, #0
02EC  D102429A     CMP R2, R3
02EE  42AED102     BNE.N 0x2F6
02F0  D90042AE     CMP R6, R5
02F2  E77ED900     BLS.N 0x2F6
02F4  2000E77E     B.N 0x1F4
763:           						{
764:           							isEvent = (uint8)1;
765:           						}
766:           						else
767:           						{
768:           							isEvent = (uint8)0;
02F6  E7022000     MOVS R0, #0
02F8  2B02E702     B.N 0x100
769:           						}
770:           					}
771:           					break;
772:           				}
773:           			}
774:           		}
775:           		else
776:           		{
777:           			switch (size)
02FA  D03B2B02     CMP R3, #2
02FC  D91CD03B     BEQ.N 0x376
02FE  2B04D91C     BLS.N 0x33A
0300  D0522B04     CMP R3, #4
0302  2B08D052     BEQ.N 0x2AA
0304  D0002B08     CMP R3, #8
0306  E081D000     BEQ.N 0x30A
0308  6C06E081     B.N 0x40E
033A  D1672B01     CMP R3, #1
033C  2340D167     BNE.N 0x30E
778:           			{
779:           				case 1:
780:           				{
781:           					uint8 trgLastValue = (uint8)pTScope->trgLastValue;
033E  18C32340     MOVS R3, #64
0340  781A18C3     ADDS R3, R0, R3
0342  2338781A     LDRB R2, [R3]
782:           					uint8 trgLevel = (uint8)pTScope->trgLevel;
0344  18C32338     MOVS R3, #56
0346  781B18C3     ADDS R3, R0, R3
0348  A902781B     LDRB R3, [R3]
783:           					uint8 curValue = (uint8)curTrgValue;
034A  7809A902     ADD R1, SP, #8
034C  24747809     LDRB R1, [R1]
784:           					if (pTScope->trgEdge == EDGE_RISING)
034E  5D002474     MOVS R4, #116
0350  28015D00     LDRB R0, [R0, R4]
0352  D0072801     CMP R0, #1
0354  2000D007     BEQ.N 0x366
785:           					{
786:           						if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
0368  D300429A     CMP R2, R3
036A  E6C8D300     BCC.N 0x36E
036C  4299E6C8     B.N 0x100
036E  41404299     CMP R1, R3
0370  B2C04140     ADCS R0, R0
787:           						{
788:           							isEvent = (uint8)1;
789:           						}
790:           						else
791:           						{
792:           							isEvent = (uint8)0;
0366  429A2000     MOVS R0, #0
793:           						}
794:           					}
795:           					else
796:           					{
797:           						if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
0358  D800429A     CMP R2, R3
035A  E6D0D800     BHI.N 0x35E
035C  428BE6D0     B.N 0x100
035E  4140428B     CMP R3, R1
0360  B2C04140     ADCS R0, R0
798:           						{
799:           							isEvent = (uint8)1;
800:           						}
801:           						else
802:           						{
803:           							isEvent = (uint8)0;
0356  429A2000     MOVS R0, #0
804:           						}
805:           					}
806:           					break;
807:           				}
808:           				case 2:
809:           				{
810:           					uint16 trgLastValue = (uint16)pTScope->trgLastValue;
0376  18C32340     MOVS R3, #64
0378  881B18C3     ADDS R3, R0, R3
037A  8F01881B     LDRH R3, [R3]
811:           					uint16 trgLevel = (uint16)pTScope->trgLevel;
037C  AA028F01     LDRH R1, [R0, #56]
812:           					uint16 curValue = (uint16)curTrgValue;
037E  8812AA02     ADD R2, SP, #8
0380  24748812     LDRH R2, [R2]
813:           					if (pTScope->trgEdge == EDGE_RISING)
0382  5D002474     MOVS R4, #116
0384  28015D00     LDRB R0, [R0, R4]
0386  D0072801     CMP R0, #1
0388  2000D007     BEQ.N 0x39A
814:           					{
815:           						if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
039C  D300428B     CMP R3, R1
039E  E6AED300     BCC.N 0x3A2
03A0  428AE6AE     B.N 0x100
03A2  4140428A     CMP R2, R1
03A4  B2C04140     ADCS R0, R0
816:           						{
817:           							isEvent = (uint8)1;
818:           						}
819:           						else
820:           						{
821:           							isEvent = (uint8)0;
039A  428B2000     MOVS R0, #0
822:           						}
823:           					}
824:           					else
825:           					{
826:           						if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
038C  D800428B     CMP R3, R1
038E  E6B6D800     BHI.N 0x392
0390  4291E6B6     B.N 0x100
0392  41404291     CMP R1, R2
0394  B2C04140     ADCS R0, R0
827:           						{
828:           							isEvent = (uint8)1;
829:           						}
830:           						else
831:           						{
832:           							isEvent = (uint8)0;
038A  428B2000     MOVS R0, #0
833:           						}
834:           					}
835:           					break;
836:           				}
837:           				case 4:
838:           				{
839:           					uint32 trgLastValue = (uint32)pTScope->trgLastValue;
03AA  6B836C02     LDR R2, [R0, #64]
840:           					uint32 trgLevel = (uint32)pTScope->trgLevel;
03AC  9C026B83     LDR R3, [R0, #56]
841:           					uint32 curValue = (uint32)curTrgValue;
03AE  21749C02     LDR R4, [SP, #8]
842:           					if (pTScope->trgEdge == EDGE_RISING)
03B0  5C412174     MOVS R1, #116
03B2  29015C41     LDRB R1, [R0, R1]
03B4  D0072901     CMP R1, #1
03B6  2000D007     BEQ.N 0x3C8
843:           					{
844:           						if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
03CA  D300429A     CMP R2, R3
03CC  E697D300     BCC.N 0x3D0
03CE  429CE697     B.N 0x100
03D0  4140429C     CMP R4, R3
03D2  B2C04140     ADCS R0, R0
845:           						{
846:           							isEvent = (uint8)1;
847:           						}
848:           						else
849:           						{
850:           							isEvent = (uint8)0;
03C8  429A2000     MOVS R0, #0
851:           						}
852:           					}
853:           					else
854:           					{
855:           						if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
03BA  D800429A     CMP R2, R3
03BC  E69FD800     BHI.N 0x3C0
03BE  42A3E69F     B.N 0x100
03C0  414042A3     CMP R3, R4
03C2  B2C04140     ADCS R0, R0
856:           						{
857:           							isEvent = (uint8)1;
858:           						}
859:           						else
860:           						{
861:           							isEvent = (uint8)0;
03B8  429A2000     MOVS R0, #0
862:           						}
863:           					}
864:           					break;
865:           				}
866:           				case 8:
867:           				{
868:           					uint64 trgLastValue = (uint64)pTScope->trgLastValue;
030A  6C426C06     LDR R6, [R0, #64]
030C  6B856C42     LDR R2, [R0, #68]
869:           					uint64 trgLevel = (uint64)pTScope->trgLevel;
030E  6BC36B85     LDR R5, [R0, #56]
0310  9F026BC3     LDR R3, [R0, #60]
870:           					uint64 curValue = (uint64)curTrgValue;
0312  9C039F02     LDR R7, [SP, #8]
0314  21749C03     LDR R4, [SP, #12]
871:           					if (pTScope->trgEdge == EDGE_RISING)
0316  5C412174     MOVS R1, #116
0318  29015C41     LDRB R1, [R0, R1]
031A  D05C2901     CMP R1, #1
031C  429AD05C     BEQ.N $d
872:           					{
873:           						if ((trgLastValue < trgLevel) && (curValue >= trgLevel))
03D8  D9084293     CMP R3, R2
03DA  2001D908     BLS.N 0x3EE
03DC  42A32001     MOVS R0, #1
03DE  D80242A3     CMP R3, R4
03E0  D102D802     BHI.N 0x3E8
03E2  42BDD102     BNE.N 0x3EA
03E4  D90042BD     CMP R5, R7
03E6  2000D900     BLS.N 0x3EA
03E8  B2C02000     MOVS R0, #0
03EE  D1014293     CMP R3, R2
03F0  42B5D101     BNE.N 0x3F6
03F2  D8F242B5     CMP R5, R6
03F4  2000D8F2     BHI.N 0x3DC
874:           						{
875:           							isEvent = (uint8)1;
876:           						}
877:           						else
878:           						{
879:           							isEvent = (uint8)0;
03F6  E6822000     MOVS R0, #0
03F8  2000E682     B.N 0x100
880:           						}
881:           					}
882:           					else
883:           					{
884:           						if ((trgLastValue > trgLevel) && (curValue <= trgLevel))
031E  D802429A     CMP R2, R3
0320  D176D802     BHI.N 0x328
0322  42AED176     BNE.N 0x312
0324  D97442AE     CMP R6, R5
0326  2001D974     BLS.N 0x312
0328  429C2001     MOVS R0, #1
032A  D802429C     CMP R4, R3
032C  D102D802     BHI.N 0x334
032E  42AFD102     BNE.N 0x336
0330  D90042AF     CMP R7, R5
0332  2000D900     BLS.N 0x336
0334  B2C02000     MOVS R0, #0
885:           						{
886:           							isEvent = (uint8)1;
887:           						}
888:           						else
889:           						{
890:           							isEvent = (uint8)0;
0412  E6742000     MOVS R0, #0
0414  234CE674     B.N 0x100
891:           						}
892:           					}
893:           					break;
894:           				}
895:           			}
896:           		} /* isSigned */
897:           	} /* isFloat */
898:           	return (isEvent);
899:           }
0100  BDF0B005     ADD SP, #20
0102  6C03BDF0     POP {R4, R5, R6, R7, PC}
0104  6B846C03     LDR R3, [R0, #64]
0106  9D026B84     LDR R4, [R0, #56]
0108  22749D02     LDR R5, [SP, #8]
010A  5C822274     MOVS R2, #116
010C  2A015C82     LDRB R2, [R0, R2]
010E  D0102A01     CMP R2, #1
0110  1C21D010     BEQ.N 0x134
0112  1C181C21     ADDS R1, R4, #0
0114  F0051C18     ADDS R0, R3, #0
0116  FB0FF005     BL 0x5738
0118  2800FB0F     MLA R8, PC, R0, R2
011A  D1002800     CMP R0, #0
011C  E16ED100     BNE.N 0x120
011E  2601E16E     B.N 0x3FE
0120  1C292601     MOVS R6, #1
0122  1C201C29     ADDS R1, R5, #0
0124  F0051C20     ADDS R0, R4, #0
0126  FB11F005     BL 0x574C
0128  2800FB11     SMLABB R8, R1, R0, R2
012A  D1002800     CMP R0, #0
012C  2600D100     BNE.N 0x130
012E  B2F02600     MOVS R6, #0
0130  E7E5B2F0     UXTB R0, R6
0132  1C21E7E5     B.N 0x100
0134  1C181C21     ADDS R1, R4, #0
0136  F0051C18     ADDS R0, R3, #0
0138  FAEAF005     BL 0x5710
013A  2800FAEA     SSAX R8, R10, R0
013C  D1002800     CMP R0, #0
013E  E15BD100     BNE.N 0x142
0140  2601E15B     B.N 0x3FA
0142  1C292601     MOVS R6, #1
0144  1C201C29     ADDS R1, R5, #0
0146  F0051C20     ADDS R0, R4, #0
0148  FAECF005     BL 0x5724
014A  2800FAEC     SSAX R8, R12, R0
014C  D1002800     CMP R0, #0
014E  2600D100     BNE.N 0x152
0150  B2F02600     MOVS R6, #0
0152  E7D4B2F0     UXTB R0, R6
0154  6C06E7D4     B.N 0x100
0156  6C476C06     LDR R6, [R0, #64]
0158  6B846C47     LDR R7, [R0, #68]
015A  6BC56B84     LDR R4, [R0, #56]
015C  9A026BC5     LDR R5, [R0, #60]
015E  9B039A02     LDR R2, [SP, #8]
0160  92009B03     LDR R3, [SP, #12]
0162  93019200     STR R2, [SP, #0]
0164  23749301     STR R3, [SP, #4]
0166  5CC32374     MOVS R3, #116
0168  2B015CC3     LDRB R3, [R0, R3]
016A  D0162B01     CMP R3, #1
016C  22D016     BEQ.N 0x19C
016E  2B0022     MOVS R2, R4
0170  30002B     MOVS R3, R5
0172  390030     MOVS R0, R6
0174  F0050039     MOVS R1, R7
0176  FA6BF005     BL 0x5650
0178  2800FA6B     ROR.W R8, R11, R0
017A  D1002800     CMP R0, #0
017C  E142D100     BNE.N 0x180
017E  2301E142     B.N 0x406
0180  1C1E2301     MOVS R3, #1
0182  9A001C1E     ADDS R6, R3, #0
0184  9B019A00     LDR R2, [SP, #0]
0186  209B01     LDR R3, [SP, #4]
0188  290020     MOVS R0, R4
018A  F0050029     MOVS R1, R5
018C  FA6AF005     BL 0x5664
018E  2800FA6A     ROR.W R8, R10, R0
0190  D1012800     CMP R0, #0
0192  2300D101     BNE.N 0x198
0194  1C1E2300     MOVS R3, #0
0196  B2F01C1E     ADDS R6, R3, #0
0198  E7B1B2F0     UXTB R0, R6
019A  22E7B1     B.N 0x100
019C  2B0022     MOVS R2, R4
019E  30002B     MOVS R3, R5
01A0  390030     MOVS R0, R6
01A2  F0050039     MOVS R1, R7
01A4  FA40F005     BL 0x5628
01A6  2800FA40     ASR.W R8, R0, R0
01A8  D1002800     CMP R0, #0
01AA  E129D100     BNE.N 0x1AE
01AC  2601E129     B.N 0x402
01AE  9A002601     MOVS R6, #1
01B0  9B019A00     LDR R2, [SP, #0]
01B2  209B01     LDR R3, [SP, #4]
01B4  290020     MOVS R0, R4
01B6  F0050029     MOVS R1, R5
01B8  FA40F005     BL 0x563C
01BA  2800FA40     ASR.W R8, R0, R0
01BC  D1002800     CMP R0, #0
01BE  2600D100     BNE.N 0x1C2
01C0  B2F02600     MOVS R6, #0
01C2  E79CB2F0     UXTB R0, R6
01C4  692E79C     B.N 0x100
01C6  D4000692     LSLS R2, R2, #26
01C8  E096D400     BMI.N 0x1CC
01CA  2B02E096     B.N 0x2FA
01CC  D0402B02     CMP R3, #2
01CE  D919D040     BEQ.N 0x152
01D0  2B04D919     BLS.N 0x206
01D2  D05E2B04     CMP R3, #4
01D4  2B08D05E     BEQ.N 0x194
01D6  D0002B08     CMP R3, #8
01D8  E116D000     BEQ.N 0x1DC
01DA  6C06E116     B.N 0x40A
01DC  6C426C06     LDR R6, [R0, #64]
01DE  6B856C42     LDR R2, [R0, #68]
01E0  6BC36B85     LDR R5, [R0, #56]
01E2  9F026BC3     LDR R3, [R0, #60]
01E4  9C039F02     LDR R7, [SP, #8]
01E6  21749C03     LDR R4, [SP, #12]
01E8  5C412174     MOVS R1, #116
01EA  29015C41     LDRB R1, [R0, R1]
01EC  D06C2901     CMP R1, #1
01EE  429AD06C     BEQ.N 0x1CA
01F0  DD7B429A     CMP R2, R3
01F2  2001DD7B     BLE.N 0x1EC
01F4  429C2001     MOVS R0, #1
01F6  DC02429C     CMP R4, R3
01F8  D102DC02     BGT.N 0x200
01FA  42AFD102     BNE.N 0x202
01FC  D90042AF     CMP R7, R5
01FE  2000D900     BLS.N 0x202
0200  B2C02000     MOVS R0, #0
0202  E77CB2C0     UXTB R0, R0
0204  2B01E77C     B.N 0x100
0206  D0002B01     CMP R3, #1
0208  E0FED000     BEQ.N 0x20C
020A  2340E0FE     B.N 0x40A
020C  18C32340     MOVS R3, #64
020E  210018C3     ADDS R3, R0, R3
0210  56592100     MOVS R1, #0
0212  23385659     LDRSB R1, [R3, R1]
0214  18C32338     MOVS R3, #56
0216  781B18C3     ADDS R3, R0, R3
0218  B25B781B     LDRB R3, [R3]
021A  AA02B25B     SXTB R3, R3
021C  7812AA02     ADD R2, SP, #8
021E  B2527812     LDRB R2, [R2]
0220  2474B252     SXTB R2, R2
0222  5D002474     MOVS R4, #116
0224  28015D00     LDRB R0, [R0, R4]
0226  D0092801     CMP R0, #1
0228  2000D009     BEQ.N 0x23E
022A  42992000     MOVS R0, #0
022C  DC004299     CMP R1, R3
022E  E766DC00     BGT.N 0x232
0230  17D8E766     B.N 0x100
0232  FD117D8     ASRS R0, R3, #31
0234  42930FD1     LSRS R1, R2, #31
0236  41484293     CMP R3, R2
0238  B2C04148     ADCS R0, R1
023A  E760B2C0     UXTB R0, R0
023C  2000E760     B.N 0x100
023E  42992000     MOVS R0, #0
0240  DB004299     CMP R1, R3
0242  E75CDB00     BLT.N 0x246
0244  FD8E75C     B.N 0x100
0246  17D10FD8     LSRS R0, R3, #31
0248  429A17D1     ASRS R1, R2, #31
024A  4148429A     CMP R2, R3
024C  B2C04148     ADCS R0, R1
024E  E756B2C0     UXTB R0, R0
0250  2340E756     B.N 0x100
0252  18C32340     MOVS R3, #64
0254  220018C3     ADDS R3, R0, R3
0256  5E9A2200     MOVS R2, #0
0258  23385E9A     LDRSH R2, [R3, R2]
025A  5EC12338     MOVS R3, #56
025C  AB025EC1     LDRSH R1, [R0, R3]
025E  2400AB02     ADD R3, SP, #8
0260  5F1B2400     MOVS R4, #0
0262  24745F1B     LDRSH R3, [R3, R4]
0264  5D002474     MOVS R4, #116
0266  28015D00     LDRB R0, [R0, R4]
0268  D0092801     CMP R0, #1
026A  2000D009     BEQ.N 0x280
026C  428A2000     MOVS R0, #0
026E  DC00428A     CMP R2, R1
0270  E745DC00     BGT.N 0x274
0272  17C8E745     B.N 0x100
0274  FDA17C8     ASRS R0, R1, #31
0276  42990FDA     LSRS R2, R3, #31
0278  41504299     CMP R1, R3
027A  B2C04150     ADCS R0, R2
027C  E73FB2C0     UXTB R0, R0
027E  2000E73F     B.N 0x100
0280  428A2000     MOVS R0, #0
0282  DB00428A     CMP R2, R1
0284  E73BDB00     BLT.N 0x288
0286  FC8E73B     B.N 0x100
0288  17DA0FC8     LSRS R0, R1, #31
028A  428B17DA     ASRS R2, R3, #31
028C  4150428B     CMP R3, R1
028E  B2C04150     ADCS R0, R2
0290  E735B2C0     UXTB R0, R0
0292  6C01E735     B.N 0x100
0294  6B836C01     LDR R1, [R0, #64]
0296  9A026B83     LDR R3, [R0, #56]
0298  24749A02     LDR R2, [SP, #8]
029A  5D002474     MOVS R4, #116
029C  28015D00     LDRB R0, [R0, R4]
029E  D0092801     CMP R0, #1
02A0  2000D009     BEQ.N 0x2B6
02A2  42992000     MOVS R0, #0
02A4  DC004299     CMP R1, R3
02A6  E72ADC00     BGT.N 0x2AA
02A8  17D8E72A     B.N 0x100
02AA  FD117D8     ASRS R0, R3, #31
02AC  42930FD1     LSRS R1, R2, #31
02AE  41484293     CMP R3, R2
02B0  B2C04148     ADCS R0, R1
02B2  E724B2C0     UXTB R0, R0
02B4  2000E724     B.N 0x100
02B6  42992000     MOVS R0, #0
02B8  DB004299     CMP R1, R3
02BA  E720DB00     BLT.N 0x2BE
02BC  FD8E720     B.N 0x100
02BE  17D10FD8     LSRS R0, R3, #31
02C0  429A17D1     ASRS R1, R2, #31
02C2  4148429A     CMP R2, R3
02C4  B2C04148     ADCS R0, R1
02C6  E71AB2C0     UXTB R0, R0
02C8  4293E71A     B.N 0x100
02CA  DD084293     CMP R3, R2
02CC  2001DD08     BLE.N 0x2E0
02CE  42A32001     MOVS R0, #1
02D0  DC0242A3     CMP R3, R4
02D2  D102DC02     BGT.N 0x2DA
02D4  42BDD102     BNE.N 0x2DC
02D6  D90042BD     CMP R5, R7
02D8  2000D900     BLS.N 0x2DC
02DA  B2C02000     MOVS R0, #0
02DC  E70FB2C0     UXTB R0, R0
02DE  4293E70F     B.N 0x100
02E0  D1014293     CMP R3, R2
02E2  42B5D101     BNE.N communicate::LNet_OnlineScope
02E4  D8F242B5     CMP R5, R6
02E6  2000D8F2     BHI.N 0x2CE
02E8  E7092000     MOVS R0, #0
02EA  429AE709     B.N 0x100
02EC  D102429A     CMP R2, R3
02EE  42AED102     BNE.N 0x2F6
02F0  D90042AE     CMP R6, R5
02F2  E77ED900     BLS.N 0x2F6
02F4  2000E77E     B.N 0x1F4
02F6  E7022000     MOVS R0, #0
02F8  2B02E702     B.N 0x100
02FA  D03B2B02     CMP R3, #2
02FC  D91CD03B     BEQ.N 0x376
02FE  2B04D91C     BLS.N 0x33A
0300  D0522B04     CMP R3, #4
0302  2B08D052     BEQ.N 0x2AA
0304  D0002B08     CMP R3, #8
0306  E081D000     BEQ.N 0x30A
0308  6C06E081     B.N 0x40E
030A  6C426C06     LDR R6, [R0, #64]
030C  6B856C42     LDR R2, [R0, #68]
030E  6BC36B85     LDR R5, [R0, #56]
0310  9F026BC3     LDR R3, [R0, #60]
0312  9C039F02     LDR R7, [SP, #8]
0314  21749C03     LDR R4, [SP, #12]
0316  5C412174     MOVS R1, #116
0318  29015C41     LDRB R1, [R0, R1]
031A  D05C2901     CMP R1, #1
031C  429AD05C     BEQ.N $d
031E  D802429A     CMP R2, R3
0320  D176D802     BHI.N 0x328
0322  42AED176     BNE.N 0x312
0324  D97442AE     CMP R6, R5
0326  2001D974     BLS.N 0x312
0328  429C2001     MOVS R0, #1
032A  D802429C     CMP R4, R3
032C  D102D802     BHI.N 0x334
032E  42AFD102     BNE.N 0x336
0330  D90042AF     CMP R7, R5
0332  2000D900     BLS.N 0x336
0334  B2C02000     MOVS R0, #0
0336  E6E2B2C0     UXTB R0, R0
0338  2B01E6E2     B.N 0x100
033A  D1672B01     CMP R3, #1
033C  2340D167     BNE.N 0x30E
033E  18C32340     MOVS R3, #64
0340  781A18C3     ADDS R3, R0, R3
0342  2338781A     LDRB R2, [R3]
0344  18C32338     MOVS R3, #56
0346  781B18C3     ADDS R3, R0, R3
0348  A902781B     LDRB R3, [R3]
034A  7809A902     ADD R1, SP, #8
034C  24747809     LDRB R1, [R1]
034E  5D002474     MOVS R4, #116
0350  28015D00     LDRB R0, [R0, R4]
0352  D0072801     CMP R0, #1
0354  2000D007     BEQ.N 0x366
0356  429A2000     MOVS R0, #0
0358  D800429A     CMP R2, R3
035A  E6D0D800     BHI.N 0x35E
035C  428BE6D0     B.N 0x100
035E  4140428B     CMP R3, R1
0360  B2C04140     ADCS R0, R0
0362  E6CCB2C0     UXTB R0, R0
0364  2000E6CC     B.N 0x100
0366  429A2000     MOVS R0, #0
0368  D300429A     CMP R2, R3
036A  E6C8D300     BCC.N 0x36E
036C  4299E6C8     B.N 0x100
036E  41404299     CMP R1, R3
0370  B2C04140     ADCS R0, R0
0372  E6C4B2C0     UXTB R0, R0
0374  2340E6C4     B.N 0x100
0376  18C32340     MOVS R3, #64
0378  881B18C3     ADDS R3, R0, R3
037A  8F01881B     LDRH R3, [R3]
037C  AA028F01     LDRH R1, [R0, #56]
037E  8812AA02     ADD R2, SP, #8
0380  24748812     LDRH R2, [R2]
0382  5D002474     MOVS R4, #116
0384  28015D00     LDRB R0, [R0, R4]
0386  D0072801     CMP R0, #1
0388  2000D007     BEQ.N 0x39A
038A  428B2000     MOVS R0, #0
038C  D800428B     CMP R3, R1
038E  E6B6D800     BHI.N 0x392
0390  4291E6B6     B.N 0x100
0392  41404291     CMP R1, R2
0394  B2C04140     ADCS R0, R0
0396  E6B2B2C0     UXTB R0, R0
0398  2000E6B2     B.N 0x100
039A  428B2000     MOVS R0, #0
039C  D300428B     CMP R3, R1
039E  E6AED300     BCC.N 0x3A2
03A0  428AE6AE     B.N 0x100
03A2  4140428A     CMP R2, R1
03A4  B2C04140     ADCS R0, R0
03A6  E6AAB2C0     UXTB R0, R0
03A8  6C02E6AA     B.N 0x100
03AA  6B836C02     LDR R2, [R0, #64]
03AC  9C026B83     LDR R3, [R0, #56]
03AE  21749C02     LDR R4, [SP, #8]
03B0  5C412174     MOVS R1, #116
03B2  29015C41     LDRB R1, [R0, R1]
03B4  D0072901     CMP R1, #1
03B6  2000D007     BEQ.N 0x3C8
03B8  429A2000     MOVS R0, #0
03BA  D800429A     CMP R2, R3
03BC  E69FD800     BHI.N 0x3C0
03BE  42A3E69F     B.N 0x100
03C0  414042A3     CMP R3, R4
03C2  B2C04140     ADCS R0, R0
03C4  E69BB2C0     UXTB R0, R0
03C6  2000E69B     B.N 0x100
03C8  429A2000     MOVS R0, #0
03CA  D300429A     CMP R2, R3
03CC  E697D300     BCC.N 0x3D0
03CE  429CE697     B.N 0x100
03D0  4140429C     CMP R4, R3
03D2  B2C04140     ADCS R0, R0
03D4  E693B2C0     UXTB R0, R0
03D6  4293E693     B.N 0x100
03D8  D9084293     CMP R3, R2
03DA  2001D908     BLS.N 0x3EE
03DC  42A32001     MOVS R0, #1
03DE  D80242A3     CMP R3, R4
03E0  D102D802     BHI.N 0x3E8
03E2  42BDD102     BNE.N 0x3EA
03E4  D90042BD     CMP R5, R7
03E6  2000D900     BLS.N 0x3EA
03E8  B2C02000     MOVS R0, #0
03EA  E688B2C0     UXTB R0, R0
03EC  4293E688     B.N 0x100
03EE  D1014293     CMP R3, R2
03F0  42B5D101     BNE.N 0x3F6
03F2  D8F242B5     CMP R5, R6
03F4  2000D8F2     BHI.N 0x3DC
03F6  E6822000     MOVS R0, #0
03F8  2000E682     B.N 0x100
03FA  E6802000     MOVS R0, #0
03FC  2000E680     B.N 0x100
03FE  E67E2000     MOVS R0, #0
0400  2000E67E     B.N 0x100
0402  E67C2000     MOVS R0, #0
0404  2000E67C     B.N 0x100
0406  E67A2000     MOVS R0, #0
0408  2000E67A     B.N 0x100
040A  E6782000     MOVS R0, #0
040C  2000E678     B.N 0x100
040E  E6762000     MOVS R0, #0
0410  2000E676     B.N 0x100
0412  E6742000     MOVS R0, #0
0414  234CE674     B.N 0x100
900:           
901:           /* return current trigger value */
902:           static uint64 getTriggerValue(SCOPE_MAIN *pTScope)
903:           {
904:           	uint64 trgValue;
905:           	uint8 trgLevelSize = pTScope->trgDataType & (uint8)0x0F;
0416  5CC2234C     MOVS R3, #76
0418  3B3D5CC2     LDRB R2, [R0, R3]
041A  40133B3D     SUBS R3, #61
041C  2B024013     ANDS R3, R2
906:           	switch (trgLevelSize)
041E  D0102B02     CMP R3, #2
0420  B2DAD010     BEQ.N 0x444
0422  2A02B2DA     UXTB R2, R3
0424  D9072A02     CMP R2, #2
0426  2B04D907     BLS.N 0x438
0428  D00F2B04     CMP R3, #4
042A  2B08D00F     BEQ.N 0x44C
042C  D1112B08     CMP R3, #8
042E  6C83D111     BNE.N 0x454
0438  D10B2B01     CMP R3, #1
043A  6C83D10B     BNE.N 0x454
0454  21002000     MOVS R0, #0
0456  E7F32100     MOVS R1, #0
907:           	{
908:           	case 1:
909:           		trgValue = *(uint8*)pTScope->trgAddr;
043C  78186C83     LDR R3, [R0, #72]
043E  21007818     LDRB R0, [R3]
0440  47702100     MOVS R1, #0
910:           		break;
911:           	case 2:
912:           		trgValue = *(uint16*)pTScope->trgAddr;
0444  88186C83     LDR R3, [R0, #72]
0446  21008818     LDRH R0, [R3]
0448  E7FA2100     MOVS R1, #0
913:           		break;
044A  6C83E7FA     B.N 0x442
914:           	case 4:
915:           		trgValue = *(uint32*)pTScope->trgAddr;
044C  68186C83     LDR R3, [R0, #72]
044E  21006818     LDR R0, [R3]
0450  E7F62100     MOVS R1, #0
916:           		break;
0452  2000E7F6     B.N 0x442
917:           	case 8:
918:           		trgValue = *(uint64*)pTScope->trgAddr;
0430  68186C83     LDR R3, [R0, #72]
0432  68596818     LDR R0, [R3]
0434  E0046859     LDR R1, [R3, #4]
919:           		break;
0436  2B01E004     B.N 0x442
920:           	default:
921:           		/* unsupported size */
922:           		break;
923:           	}
924:           	return (trgValue);
0458  B5F0E7F3     B.N 0x442
925:           }
0442  6C834770     BX LR
0444  88186C83     LDR R3, [R0, #72]
0446  21008818     LDRH R0, [R3]
0448  E7FA2100     MOVS R1, #0
044A  6C83E7FA     B.N 0x442
044C  68186C83     LDR R3, [R0, #72]
044E  21006818     LDR R0, [R3]
0450  E7F62100     MOVS R1, #0
0452  2000E7F6     B.N 0x442
0454  21002000     MOVS R0, #0
0456  E7F32100     MOVS R1, #0
0458  B5F0E7F3     B.N 0x442
926:           
927:           /* sample offline data and write it into offline array */
928:           static void sampleData(SCOPE_MAIN *pTScope)
929:           {
045A  2700B5F0     PUSH {R4, R5, R6, R7, LR}
930:           	uint8 i,j;
931:           
932:           	i = 0;
045C  23552700     MOVS R7, #0
933:               do
934:               {
935:               	j = 0;
0462  BE2300     MOVS R3, #0
936:                   do
937:                   {
938:                   	*(ALIGNCASTPTR pTScope->arrayAddr + pTScope->offlinePtr++) = \
046C  1C516D02     LDR R2, [R0, #80]
046E  65011C51     ADDS R1, R2, #1
0470  68716501     STR R1, [R0, #80]
0476  54A16AC4     LDR R4, [R0, #44]
0478  330154A1     STRB R1, [R4, R2]
939:           				*(ALIGNCASTPTR pTScope->channelAddr[i] + j);
0464  198600BE     LSLS R6, R7, #2
0466  19C51986     ADDS R6, R0, R6
0472  56C96871     LDR R1, [R6, #4]
0474  6AC456C9     LDRSB R1, [R1, R3]
940:                       j++;
047A  B2DB3301     ADDS R3, #1
047C  782AB2DB     UXTB R3, R3
941:                   }
942:                   while (j < pTScope->dataSize[i]);
0468  352419C5     ADDS R5, R0, R7
046A  6D023524     ADDS R5, #36
047E  429A782A     LDRB R2, [R5]
0480  D8F3429A     CMP R2, R3
0482  3701D8F3     BHI.N 0x46C
943:           
944:                   i++;
0484  B2FF3701     ADDS R7, #1
0486  4663B2FF     UXTB R7, R7
945:               }
946:               while(i < pTScope->noChannels);
045E  469C2355     MOVS R3, #85
0460  2300469C     MOV R12, R3
0488  5CC34663     MOV R3, R12
048A  42BB5CC3     LDRB R3, [R0, R3]
048C  D8E842BB     CMP R3, R7
048E  BDF0D8E8     BHI.N 0x462
947:           }
0490  B510BDF0     POP {R4, R5, R6, R7, PC}
948:           
949:           /*
950:            * Returns block functions from block function table.
951:            */
952:           static tBlockFunctions* getBlockFunction(const tBlockFunctions* blockFuncTable, uint16 blockId)
953:           {
954:           	uint16 i = 0;
955:           	tBlockFunctions* blockFunctionAddr;
956:           
957:           	while ((blockId != blockFuncTable[i].iBlockID) && (blockFuncTable[i].iBlockID != 0))
08B6  4298881B     LDRH R3, [R3]
08CC  189B0053     LSLS R3, R2, #1
0A38  4299881B     LDRH R3, [R3]
0A4C  189B0053     LSLS R3, R2, #1
958:           	{
959:           		i++;
08C8  B2923201     ADDS R2, #1
0A48  B2923201     ADDS R2, #1
960:           	}
961:           	/* check if Block ID can be found in function table */
962:           	if (blockFuncTable[i].iBlockID == 0)
08EA  D1002800     CMP R0, #0
0A68  D0B22900     CMP R1, #0
0A6A  2B00D0B2     BEQ.N 0xBD2
963:           	{
964:           		blockFunctionAddr = (tBlockFunctions*)0;
965:           	}
966:           	else
967:           	{
968:           		blockFunctionAddr = (tBlockFunctions*)&blockFuncTable[i];
969:           	}
970:           	return (blockFunctionAddr);
971:           }
972:           
973:           /*
974:            * Returns block address from parameter table.
975:            */
976:           static void* getBlockAddress(const tParameterTable* paramTable, uint16 paramId)
977:           {
0492  2800B510     PUSH {R4, LR}
978:           	void* blockAddr;
979:           	uint16 i;
980:           
981:           	/* send parameter ID error if no parameter table has been initialized */
982:           	if (paramTable == 0)
0494  D0162800     CMP R0, #0
0496  8803D016     BEQ.N 0x4C6
983:           	{
984:           		blockAddr = (void*)0;
04C6  E7FC2000     MOVS R0, #0
04C8  2000E7FC     B.N 0x4C4
985:           	}
986:           	else
987:           	{
988:           		i = 0;
989:           		while((paramId != paramTable[i].uiParID) && (paramTable[i].uiParID != 0))
0498  42998803     LDRH R3, [R0]
049A  D00D4299     CMP R1, R3
049C  2B00D00D     BEQ.N 0x4BA
049E  D0132B00     CMP R3, #0
04A0  2300D013     BEQ.N 0x4CA
04A2  33012300     MOVS R3, #0
04A8  188200DA     LSLS R2, R3, #3
04AA  88141882     ADDS R2, R0, R2
04AC  428C8814     LDRH R4, [R2]
04AE  D004428C     CMP R4, R1
04B0  2C00D004     BEQ.N 0x4BC
04B2  D1F62C00     CMP R4, #0
04B4  2000D1F6     BNE.N 0x4A4
04BA  20000002     MOVS R2, R0
990:           		{
991:           			i++;
04A4  B29B3301     ADDS R3, #1
04A6  DAB29B     UXTH R3, R3
992:           		}
993:           		/* check if parameter is located in parameter table */
994:           		if (paramTable[i].uiParID == 0)
04BE  D0002900     CMP R1, #0
04C0  6850D000     BEQ.N 0x4C4
995:           		{
996:           			blockAddr = (void*)0;
04B6  E0042000     MOVS R0, #0
04B8  2E004     B.N 0x4C4
04BC  29002000     MOVS R0, #0
04CA  E7FA2000     MOVS R0, #0
04CC  B510E7FA     B.N 0x4C4
997:           		}
998:           		else
999:           		{
1000:          			blockAddr = paramTable[i].pAdr;
04C2  BD106850     LDR R0, [R2, #4]
1001:          		}
1002:          	}
1003:          	return (blockAddr);
1004:          }
04C4  2000BD10     POP {R4, PC}
04C6  E7FC2000     MOVS R0, #0
04C8  2000E7FC     B.N 0x4C4
04CA  E7FA2000     MOVS R0, #0
04CC  B510E7FA     B.N 0x4C4
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/LNet.c
1:             /*
2:              * $LastChangedRevision: 12 $
3:              * $LastChangedDate:: 2017-03-01 18:11:38 +0100#$
4:              *
5:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
6:              * All rights reserved.
7:              */
8:             #include "Services.h"
9:             #include "LNet.h"
10:            
11:            #define HW_INTERFACE (protocol->hwInterface)
12:            
13:            /* private prototypes */
14:            static void enableSend(tLNet* protocol);
15:            static void enableReceive(tLNet* protocol);
16:            static void communicate(tLNet* protocol);
17:            static void LNet_OnlineScope(tLNet* protocol);
18:            static void checkFill(tLNet* protocol, uint8 data, tLNetFrameState* stateVar, tLNetFrameState state);
19:            static uint8 receiveSize(tLNet* protocol, uint8 size);
20:            static void sendProtocolError(tLNet* protocol, uint8 serviceId, uint8 errorId);
21:            
22:            #if defined(__COMPILER_CODEWARRIOR_ECLIPSE__)
23:            #pragma push
24:            #pragma section sdata_type ".ptrTableStruct" ".ptrTableStruct"
25:            extern volatile tTableStruct *TableStruct;
26:            #pragma pop
27:            #else
28:            extern volatile tTableStruct* TableStruct;
29:            #endif
30:            
31:            /* TODO move both variables to LNet structure */
32:            static tLNetFrameState nextGlobalState;
33:            static uint8 lastSyn;
34:            
35:            /* enable send procedure / disable receive procedure */
36:            static void enableSend(tLNet* protocol)
37:            {
38:            	protocol->ucCommState = SEND_ALLOWED;
219C  76C32301     MOVS R3, #1
219E  230076C3     STRB R3, [R0, #27]
39:            	protocol->ucSndState = LNET_STATE_SYN;
21A0  76832300     MOVS R3, #0
21A2  47707683     STRB R3, [R0, #26]
40:            }
21A4  29554770     BX LR
41:            
42:            /* enable receive procedure / disable send procedure */
43:            static void enableReceive(tLNet* protocol)
44:            {
45:            	protocol->ucCommState = RECEIVE_ALLOWED;
21D2  4DA72600     MOVS R6, #0
22B6  766676E6     STRB R6, [R4, #27]
22C2  766676E6     STRB R6, [R4, #27]
255A  76C32300     MOVS R3, #0
46:            	protocol->ucRcvState = LNET_STATE_SYN;
22B8  E7967666     STRB R6, [R4, #25]
22C4  E7907666     STRB R6, [R4, #25]
22C6  4D6CE790     B.N 0x21EA
255E  47707643     STRB R3, [R0, #25]
47:            }
48:            
49:            static void communicate(tLNet* protocol)
50:            {
21C4  46DEB5F8     PUSH {R3, R4, R5, R6, R7, LR}
21C6  465746DE     MOV LR, R11
21C8  464E4657     MOV R7, R10
21CA  4645464E     MOV R6, R9
21CC  B5E04645     MOV R5, R8
21CE  4B5E0     PUSH {R5, R6, R7, LR}
21D0  26000004     MOVS R4, R0
51:            	/* service table pointer */
52:            	tSERVICEFunction* svTable;
53:            	/* current received message byte */
54:            	uint8 msg;
55:            
56:            	/* send procedure */
57:            	while ((protocol->ucCommState == SEND_ALLOWED) && protocol->hwInterface->isSendReady(HW_INTERFACE))
21D6  2355E008     B.N 0x21EA
21EA  2B017EE3     LDRB R3, [R4, #27]
21EC  D16B2B01     CMP R3, #1
21EE  6960D16B     BNE.N 0x21C8
21F0  68C36960     LDR R0, [R4, #20]
21F2  479868C3     LDR R3, [R0, #12]
21F4  28004798     BLX R3
21F6  D0662800     CMP R0, #0
21F8  7EA3D066     BEQ.N 0x21C8
58:            	{
59:            		switch (protocol->ucSndState)
21D4  E0084DA7     LDR R5, $d
21FA  2B057EA3     LDRB R3, [R4, #26]
21FC  D8602B05     CMP R3, #5
21FE  9BD860     BHI.N 0x21C2
2200  58EB009B     LSLS R3, R3, #2
2202  469F58EB     LDR R3, [R5, R3]
2204  7A21469F     MOV PC, R3
60:            		{
61:            			case LNET_STATE_SYN:
62:            				protocol->ucFrameCheck = LNET_STD_SYN;
21D8  77232355     MOVS R3, #85
21DA  77667723     STRB R3, [R4, #28]
63:            				protocol->ucFrameBufferPtr = 0;
21DC  69607766     STRB R6, [R4, #29]
64:            				protocol->hwInterface->send(HW_INTERFACE, LNET_STD_SYN);
21DE  68036960     LDR R0, [R4, #20]
21E0  21556803     LDR R3, [R0]
21E2  47982155     MOVS R1, #85
21E4  23014798     BLX R3
65:            				protocol->ucSndState = LNET_STATE_SIZE;
21E6  76A32301     MOVS R3, #1
21E8  7EE376A3     STRB R3, [R4, #26]
66:            				break;
67:            
68:            			case LNET_STATE_SIZE:
69:            				protocol->ucFrameCheck += (protocol->ucFrameSize);
2206  7F237A21     LDRB R1, [R4, #8]
2208  18CB7F23     LDRB R3, [R4, #28]
220A  772318CB     ADDS R3, R1, R3
220C  69607723     STRB R3, [R4, #28]
70:            				protocol->hwInterface->send(HW_INTERFACE, protocol->ucFrameSize);
220E  68036960     LDR R0, [R4, #20]
2210  47986803     LDR R3, [R0]
2212  7A214798     BLX R3
71:            				checkFill(protocol, protocol->ucFrameSize, &protocol->ucSndState, LNET_STATE_NODE);
2214  23027A21     LDRB R1, [R4, #8]
2216  222302     MOVS R3, #2
2218  321A0022     MOVS R2, R4
221A  20321A     ADDS R2, #26
221C  F7FF0020     MOVS R0, R4
221E  FFC2F7FF     BL .LFE0, .LFB3
2220  E7E2FFC2     CDP2 P7, #12, CR14, CR2, CR2, {7}
72:            				break;
2222  7E21E7E2     B.N 0x21EA
73:            
74:            			case LNET_STATE_NODE:
75:            				protocol->ucFrameCheck += protocol->node;
2224  7F237E21     LDRB R1, [R4, #24]
2226  18CB7F23     LDRB R3, [R4, #28]
2228  772318CB     ADDS R3, R1, R3
222A  69607723     STRB R3, [R4, #28]
76:            				protocol->hwInterface->send(HW_INTERFACE, protocol->node);
222C  68036960     LDR R0, [R4, #20]
222E  47986803     LDR R3, [R0]
2230  7E214798     BLX R3
77:            				checkFill(protocol, protocol->node, &protocol->ucSndState, LNET_STATE_DATA);
2232  23037E21     LDRB R1, [R4, #24]
2234  222303     MOVS R3, #3
2236  321A0022     MOVS R2, R4
2238  20321A     ADDS R2, #26
223A  F7FF0020     MOVS R0, R4
223C  FFB3F7FF     BL .LFE0, .LFB3
223E  E7D3FFB3     MRC2 P7, #5, LR, CR3, CR3, {6}
78:            				break;
2240  7F63E7D3     B.N 0x21EA
79:            
80:            			case LNET_STATE_DATA:
81:            				protocol->ucFrameData[protocol->ucFrameBufferPtr] &= 0xFF;
2242  68E27F63     LDRB R3, [R4, #29]
2244  469468E2     LDR R2, [R4, #12]
2246  44634694     MOV R12, R2
2248  781A4463     ADD R3, R12
82:            				protocol->ucFrameCheck += \
224A  7F21781A     LDRB R2, [R3]
224C  18527F21     LDRB R1, [R4, #28]
224E  77221852     ADDS R2, R2, R1
2250  69607722     STRB R2, [R4, #28]
83:            					protocol->ucFrameData[protocol->ucFrameBufferPtr];
84:            				protocol->hwInterface->send(HW_INTERFACE, \
2252  78196960     LDR R0, [R4, #20]
2254  68037819     LDRB R1, [R3]
2256  47986803     LDR R3, [R0]
2258  7F634798     BLX R3
85:            						protocol->ucFrameData[protocol->ucFrameBufferPtr]);
86:            
87:            				if ((protocol->ucFrameBufferPtr + 1) >= protocol->ucFrameSize)
225A  1C597F63     LDRB R3, [R4, #29]
225C  7A221C59     ADDS R1, R3, #1
225E  42917A22     LDRB R2, [R4, #8]
2260  DB0B4291     CMP R1, R2
2262  68E2DB0B     BLT.N 0x227C
88:            				{
89:            					checkFill(protocol, protocol->ucFrameData[protocol->ucFrameBufferPtr], \
2264  5CD168E2     LDR R2, [R4, #12]
2266  23055CD1     LDRB R1, [R2, R3]
2268  222305     MOVS R3, #5
226A  321A0022     MOVS R2, R4
226C  20321A     ADDS R2, #26
226E  F7FF0020     MOVS R0, R4
2270  FF99F7FF     BL .LFE0, .LFB3
2272  7F63FF99     CDP2 P15, #9, CR7, CR9, CR3, {3}
90:            						&protocol->ucSndState, LNET_STATE_CRC);
91:            				}
92:            				else
93:            				{
94:            					checkFill(protocol, protocol->ucFrameData[protocol->ucFrameBufferPtr], \
227C  5CD168E2     LDR R2, [R4, #12]
227E  23035CD1     LDRB R1, [R2, R3]
2280  222303     MOVS R3, #3
2282  321A0022     MOVS R2, R4
2284  20321A     ADDS R2, #26
2286  F7FF0020     MOVS R0, R4
2288  FF8DF7FF     BL .LFE0, .LFB3
228A  E7F2FF8D     MCR2 P7, #4, LR, CR13, CR2, {7}
228C  6960E7F2     B.N .LVL15
95:            						&protocol->ucSndState, LNET_STATE_DATA);
96:            				}
97:            				protocol->ucFrameBufferPtr++;
2274  33017F63     LDRB R3, [R4, #29]
2276  77633301     ADDS R3, #1
2278  E7B67763     STRB R3, [R4, #29]
98:            				break;
227A  68E2E7B6     B.N 0x21EA
99:            
100:           			case LNET_STATE_FILL:
101:           				protocol->hwInterface->send(HW_INTERFACE, LNET_FILL);
228E  68036960     LDR R0, [R4, #20]
2290  316803     LDR R3, [R0]
2292  47980031     MOVS R1, R6
2294  4B784798     BLX R3
102:           				protocol->ucSndState = nextGlobalState;
2296  785B4B78     LDR R3, [PC, #480]
2298  76A3785B     LDRB R3, [R3, #1]
229A  E7A576A3     STRB R3, [R4, #26]
103:           				break;
229C  7F23E7A5     B.N 0x21EA
104:           
105:           			case LNET_STATE_CRC:
106:           				protocol->ucFrameCheck &= 0xFF;
229E  2B557F23     LDRB R3, [R4, #28]
107:           				if ((protocol->ucFrameCheck == LNET_STD_SYN) || (protocol->ucFrameCheck == LNET_OSM_SYN))
22A0  D00B2B55     CMP R3, #85
22A2  2B02D00B     BEQ.N .LBE20
22A4  D0092B02     CMP R3, #2
22A6  6960D009     BEQ.N .LBE20
108:           				{
109:           					protocol->ucFrameCheck = (~protocol->ucFrameCheck) & 0xFF;
22BC  772343DB     MVNS R3, R3
22BE  E7F27723     STRB R3, [R4, #28]
22C0  76E6E7F2     B.N 0x22A8
110:           				}
111:           				protocol->hwInterface->send(HW_INTERFACE, protocol->ucFrameCheck);
22A8  7F216960     LDR R0, [R4, #20]
22AA  68037F21     LDRB R1, [R4, #28]
22AC  47986803     LDR R3, [R0]
22AE  69604798     BLX R3
112:           
113:           				/* frame complete -> flush tx buffer */
114:           				protocol->hwInterface->flush(HW_INTERFACE);
22B0  69436960     LDR R0, [R4, #20]
22B2  47986943     LDR R3, [R0, #20]
22B4  76E64798     BLX R3
115:           
116:           				enableReceive(protocol);
117:           				break;
118:           
119:           			default:
120:           				enableReceive(protocol);
121:           				break;
122:           		}	/* switch end */
123:           	}		/* tx while end */
124:           
125:           	/* receive procedure */
126:           	while ((protocol->ucCommState == RECEIVE_ALLOWED) && protocol->hwInterface->isReceiveDataAvailable(HW_INTERFACE))
23FE  2B007EE3     LDRB R3, [R4, #27]
2400  D10E2B00     CMP R3, #0
2402  6960D10E     BNE.N .LBB33
2404  68836960     LDR R0, [R4, #20]
2406  47986883     LDR R3, [R0, #8]
2408  28004798     BLX R3
240A  D0092800     CMP R0, #0
240C  6960D009     BEQ.N .LBB33
127:           	{
128:           		/* get 1 byte from rx buffer */
129:           		msg = protocol->hwInterface->receive(HW_INTERFACE);
240E  68436960     LDR R0, [R4, #20]
2410  47986843     LDR R3, [R0, #4]
2412  24798     BLX R3
2414  7E630002     MOVS R2, R0
130:           		
131:           		switch (protocol->ucRcvState)
22C8  E0984D6C     LDR R5, [PC, #432]
22CA  2855E098     B.N 0x23FE
2416  2B057E63     LDRB R3, [R4, #25]
2418  D8EE2B05     CMP R3, #5
241A  9BD8EE     BHI.N 0x23FA
241C  58EB009B     LSLS R3, R3, #2
241E  469F58EB     LDR R3, [R5, R3]
2420  4B17469F     MOV PC, R3
132:           		{
133:           			case LNET_STATE_SYN:
134:           				if (msg == LNET_STD_SYN)
22CC  D0002855     CMP R0, #85
22CE  E095D000     BEQ.N 0x22D2
22D0  2355E095     B.N 0x23FE
135:           				{
136:           					protocol->ucFrameCheck = LNET_STD_SYN;
22D2  77232355     MOVS R3, #85
22D4  3B547723     STRB R3, [R4, #28]
137:           					protocol->ucRcvState = LNET_STATE_SIZE;
22D6  76633B54     SUBS R3, #84
22D8  E0907663     STRB R3, [R4, #25]
22DA  2800E090     B.N 0x23FE
138:           				}
139:           				break;
140:           
141:           			case LNET_STATE_SIZE:
142:           				if (receiveSize(protocol, msg))
143:           				{
144:           					checkFill(protocol, msg, &protocol->ucRcvState, protocol->ucRcvState);
22F6  32190022     MOVS R2, R4
22F8  13219     ADDS R2, #25
22FA  200001     MOVS R1, R0
22FC  F7FF0020     MOVS R0, R4
22FE  FF52F7FF     BL .LFE0, .LFB3
2300  E07CFF52     MRC2 P0, #2, LR, CR2, CR12, {3}
2302  2300E07C     B.N 0x23FE
145:           				}
146:           				break;
147:           
148:           			case LNET_STATE_NODE:
149:           				if (msg == protocol->node)
231C  42837E23     LDRB R3, [R4, #24]
231E  D0024283     CMP R3, R0
2320  2300D002     BEQ.N 0x2328
150:           				{
151:           					protocol->ucFrameCheck += msg;
2328  18C37F23     LDRB R3, [R4, #28]
232A  772318C3     ADDS R3, R0, R3
232C  23037723     STRB R3, [R4, #28]
152:           					checkFill(protocol, msg, &protocol->ucRcvState, LNET_STATE_DATA);
232E  222303     MOVS R3, #3
2330  32190022     MOVS R2, R4
2332  13219     ADDS R2, #25
2334  200001     MOVS R1, R0
2336  F7FF0020     MOVS R0, R4
2338  FF35F7FF     BL .LFE0, .LFB3
233A  E05FFF35     MRC2 P0, #1, LR, CR5, CR15, {2}
233C  7F23E05F     B.N 0x23FE
153:           				}
154:           				else
155:           				{
156:           					protocol->ucRcvState = LNET_STATE_SYN;
2322  76632300     MOVS R3, #0
2324  E06A7663     STRB R3, [R4, #25]
2326  7F23E06A     B.N 0x23FE
157:           				}
158:           				break;
159:           
160:           			case LNET_STATE_DATA:
161:           				protocol->ucFrameCheck += msg;
233E  18C37F23     LDRB R3, [R4, #28]
2340  772318C3     ADDS R3, R0, R3
2342  7F637723     STRB R3, [R4, #28]
162:           				protocol->ucFrameData[protocol->ucFrameBufferPtr] = msg;
2344  68E27F63     LDRB R3, [R4, #29]
2346  54D068E2     LDR R2, [R4, #12]
2348  7F6354D0     STRB R0, [R2, R3]
163:           				protocol->ucFrameBufferPtr++;
234A  33017F63     LDRB R3, [R4, #29]
234C  B2DB3301     ADDS R3, #1
234E  7763B2DB     UXTB R3, R3
2350  7A227763     STRB R3, [R4, #29]
164:           				
165:           				if (protocol->ucFrameBufferPtr >= protocol->ucFrameSize)
2352  429A7A22     LDRB R2, [R4, #8]
2354  D807429A     CMP R2, R3
2356  2305D807     BHI.N 0x2368
166:           				{
167:           					checkFill(protocol, msg, &protocol->ucRcvState, LNET_STATE_CRC);
2358  222305     MOVS R3, #5
235A  32190022     MOVS R2, R4
235C  13219     ADDS R2, #25
235E  200001     MOVS R1, R0
2360  F7FF0020     MOVS R0, R4
2362  FF20F7FF     BL .LFE0, .LFB3
2364  E04AFF20     CDP2 P0, #2, CR14, CR0, CR10, {2}
2366  2303E04A     B.N 0x23FE
168:           				}
169:           				else
170:           				{
171:           					checkFill(protocol, msg, &protocol->ucRcvState, LNET_STATE_DATA);
2368  222303     MOVS R3, #3
236A  32190022     MOVS R2, R4
236C  13219     ADDS R2, #25
236E  200001     MOVS R1, R0
2370  F7FF0020     MOVS R0, R4
2372  FF18F7FF     BL .LFE0, .LFB3
2374  E042FF18     CDP2 P0, #1, CR14, CR8, CR2, {2}
2376  2800E042     B.N 0x23FE
172:           				}	
173:           				break;
174:           
175:           			case LNET_STATE_FILL:
176:           
177:           				if (msg == LNET_FILL)
2378  D1032800     CMP R0, #0
237A  4B3ED103     BNE.N 0x2384
178:           				{
179:           					protocol->ucRcvState = nextGlobalState;
237C  785B4B3E     LDR R3, [PC, #248]
237E  7663785B     LDRB R3, [R3, #1]
2380  E03C7663     STRB R3, [R4, #25]
2382  4B3CE03C     B.N 0x23FE
180:           				}
181:           				else
182:           				{
183:           					if (lastSyn == LNET_STD_SYN)
2384  781B4B3C     LDR R3, [PC, #240]
2386  2B55781B     LDRB R3, [R3]
2388  D0022B55     CMP R3, #85
238A  2300D002     BEQ.N .LBB29, .LBB30
184:           					{
185:           						receiveSize(protocol, msg);
186:           					}
187:           					else
188:           					{
189:           						protocol->ucRcvState = LNET_STATE_SYN;
238C  76632300     MOVS R3, #0
238E  E0357663     STRB R3, [R4, #25]
2390  7A63E035     B.N 0x23FE
190:           					}
191:           				}	
192:           				break;
193:           
194:           			case LNET_STATE_CRC:
195:           				protocol->ucFrameCheck &= 0xFF;
23BC  2B557F23     LDRB R3, [R4, #28]
196:           				if ((protocol->ucFrameCheck == LNET_STD_SYN) || (protocol->ucFrameCheck == LNET_OSM_SYN))
23BE  D0092B55     CMP R3, #85
23C0  2B02D009     BEQ.N 0x23D6
23C2  D0072B02     CMP R3, #2
23C4  7F23D007     BEQ.N 0x23D6
197:           				{
198:           					protocol->ucFrameCheck = (~protocol->ucFrameCheck) & 0xFF;
23D6  772343DB     MVNS R3, R3
23D8  E7F47723     STRB R3, [R4, #28]
23DA  68E3E7F4     B.N 0x23C6
199:           				}
200:           				if (protocol->ucFrameCheck == msg)
23C6  42937F23     LDRB R3, [R4, #28]
23C8  D0074293     CMP R3, R2
23CA  2113D007     BEQ.N 0x23DC
201:           				{
202:           					if (protocol->ucFrameData[0] <= MAX_SERVICE_ID)
23DC  781B68E3     LDR R3, [R4, #12]
23DE  2B1A781B     LDRB R3, [R3]
23E0  D8052B1A     CMP R3, #26
23E2  9BD805     BHI.N 0x23F0
203:           					{
204:           						/* elements are function pointers */
205:           						svTable = (tSERVICEFunction*)protocol->pServiceTable;
206:           						svTable[protocol->ucFrameData[0]]((tProtocol*)protocol);
23E4  6922009B     LSLS R3, R3, #2
23E6  589B6922     LDR R2, [R4, #16]
23E8  20589B     LDR R3, [R3, R2]
23EA  47980020     MOVS R0, R4
23EC  E0064798     BLX R3
23EE  2121E006     B.N 0x23FE
207:           					}
208:           					else
209:           					{
210:           						sendError((tProtocol*)protocol, ERRORServiceNotAvail);
23F0  202121     MOVS R1, #33
23F2  F7FF0020     MOVS R0, R4
23F4  FCF7F7FF     BL sendError
23F6  E001FCF7     LDC2L P0, CR14, [R7], #4
23F8  2300E001     B.N 0x23FE
211:           					}
212:           				}
213:           				else
214:           				{
215:           					sendError((tProtocol*)protocol, ERRORChksum);
23CC  202113     MOVS R1, #19
23CE  F7FF0020     MOVS R0, R4
23D0  FD09F7FF     BL sendError
23D2  E013FD09     STC2 P0, CR14, [R9, #-76]
23D4  43DBE013     B.N 0x23FE
216:           				}
217:           				break;
218:           
219:           			default:
220:           				protocol->ucRcvState = LNET_STATE_SYN;
23FA  76632300     MOVS R3, #0
23FC  7EE37663     STRB R3, [R4, #25]
221:           				break;
222:           		}	/* switch end */
223:           	}		/* rx while end */
224:           
225:           	LNet_OnlineScope(protocol);
226:           }
2436  4690BC3C     POP {R2, R3, R4, R5}
2438  46994690     MOV R8, R2
243A  46A24699     MOV R9, R3
243C  46AB46A2     MOV R10, R4
243E  BDF846AB     MOV R11, R5
2440  6960BDF8     POP {R3, R4, R5, R6, R7, PC}
2470  46C0E7E1     B.N 0x2436
2472  609C46C0     MOV R8, R8
2474  609C     STR R4, [R3, #8]
2476  28580000     MOVS R0, R0
2478  20002858     CMP R0, #88
247A  60B42000     MOVS R0, #0
247C  60B4     STR R4, [R6, #8]
247E  29040000     MOVS R0, R0
2480  20002904     CMP R1, #4
2482  6A922000     MOVS R0, #0
227:           
228:           
229:           static void checkFill(tLNet* protocol, uint8 data, tLNetFrameState* stateVar, tLNetFrameState state)
230:           {
231:           	if ((data == LNET_STD_SYN) || (data == LNET_OSM_SYN))
21A6  D0032955     CMP R1, #85
21A8  2902D003     BEQ.N 0x21B2
21AA  D0012902     CMP R1, #2
21AC  7013D001     BEQ.N 0x21B2
232:           	{
233:           		lastSyn = data;
21B2  70014803     LDR R0, [PC, #12]
21B4  70437001     STRB R1, [R0]
234:           		nextGlobalState = state;
21B6  23047043     STRB R3, [R0, #1]
235:           		*stateVar = LNET_STATE_FILL;
21B8  70132304     MOVS R3, #4
21BA  E7F87013     STRB R3, [R2]
21BC  46C0E7F8     B.N 0x21B0
21BE  285846C0     MOV R8, R8
21C0  20002858     CMP R0, #88
21C2  B5F82000     MOVS R0, #0
236:           	}
237:           	else
238:           	{
239:           		*stateVar = state;
21AE  47707013     STRB R3, [R2]
240:           	}
241:           }
21B0  48034770     BX LR
21B2  70014803     LDR R0, [PC, #12]
21B4  70437001     STRB R1, [R0]
21B6  23047043     STRB R3, [R0, #1]
21B8  70132304     MOVS R3, #4
21BA  E7F87013     STRB R3, [R2]
21BC  46C0E7F8     B.N 0x21B0
21BE  285846C0     MOV R8, R8
21C0  20002858     CMP R0, #88
21C2  B5F82000     MOVS R0, #0
242:           
243:           
244:           /* online scope mode (osm) */
245:           static void LNet_OnlineScope(tLNet* protocol)
246:           {
247:           	uint16 i, j;
248:           	static uint32 txBufFull = (uint32)0;
249:           	uint8 checksum;
250:           
251:           	/* if scope pointer is not NULL, scope state is 5 (online running) and */
252:           	/* prescaler counter is 0 -> send osm frame */
253:           	if ((TableStruct->piScope != 0) && (TableStruct->piScope->state == SCOPE_SAMPLE_ONLINE))
2422  681B4B17     LDR R3, [PC, #92]
2424  6A9A681B     LDR R3, [R3]
2426  2A006A9A     LDR R2, [R3, #40]
2428  D0042A00     CMP R2, #0
242A  6A9AD004     BEQ.N 0x2436
242C  234D6A9A     LDR R2, [R3, #40]
242E  5CD3234D     MOVS R3, #77
2430  2B045CD3     LDRB R3, [R2, R3]
2432  D0052B04     CMP R3, #4
2434  BC3CD005     BEQ.N 0x2442
254:           	{
255:           		/* call TxFifoFree function (pointer to function located in protocol, */
256:           		/* functions itself is located in the communication interface file */
257:           		/* (e.g. SCI) */
258:           		/* tx fifo must have frame data + lnet overhead (+4) free bytes */
259:           		if ((protocol->hwInterface->getTxFifoFree(HW_INTERFACE) >= (TableStruct->piScope->txFrameSize + 4)) && \
2442  69036960     LDR R0, [R4, #20]
2444  47986903     LDR R3, [R0, #16]
2446  4B0D4798     BLX R3
2448  681A4B0D     LDR R3, [PC, #52]
244A  6A91681A     LDR R2, [R3]
244C  235C6A91     LDR R1, [R2, #40]
244E  5CCB235C     MOVS R3, #92
2450  33045CCB     LDRB R3, [R1, R3]
2452  42983304     ADDS R3, #4
2454  DB074298     CMP R0, R3
2456  6A91DB07     BLT.N 0x2468
245E  3B025AC9     LDRH R1, [R1, R3]
2460  5AC33B02     SUBS R3, #2
2462  42995AC3     LDRH R3, [R0, R3]
2464  D20D4299     CMP R1, R3
2466  4A03D20D     BCS.N 0x2484
260:           		    (TableStruct->piScope->stfCnt >= TableStruct->piScope->stf))
2458  6A906A91     LDR R1, [R2, #40]
245A  23586A90     LDR R0, [R2, #40]
245C  5AC92358     MOVS R3, #88
261:           		{
262:                       TableStruct->piScope->stfCnt = 0;
2484  21006A92     LDR R2, [R2, #40]
2486  23582100     MOVS R1, #0
2488  52D12358     MOVS R3, #88
248A  696052D1     STRH R1, [R2, R3]
263:           			/* send osm frame */
264:           			protocol->hwInterface->send(HW_INTERFACE, LNET_OSM_SYN);
248C  68036960     LDR R0, [R4, #20]
248E  31026803     LDR R3, [R0]
2490  47983102     ADDS R1, #2
2492  69604798     BLX R3
265:           			protocol->hwInterface->send(HW_INTERFACE, TableStruct->piScope->txFrameSize);
2494  4E2C6960     LDR R0, [R4, #20]
2496  68334E2C     LDR R6, [PC, #176]
2498  6A9B6833     LDR R3, [R6]
249A  275C6A9B     LDR R3, [R3, #40]
249C  5DD9275C     MOVS R7, #92
249E  68035DD9     LDRB R1, [R3, R7]
24A0  47986803     LDR R3, [R0]
24A2  69604798     BLX R3
266:           			protocol->hwInterface->send(HW_INTERFACE, protocol->node);
24A4  7E216960     LDR R0, [R4, #20]
24A6  68037E21     LDRB R1, [R4, #24]
24A8  47986803     LDR R3, [R0]
24AA  69604798     BLX R3
267:           
268:           			protocol->hwInterface->send(HW_INTERFACE, LOW(TableStruct->piScope->timestamp));
24AC  68336960     LDR R0, [R4, #20]
24AE  6A9B6833     LDR R3, [R6]
24B0  255A6A9B     LDR R3, [R3, #40]
24B2  5D59255A     MOVS R5, #90
24B4  68035D59     LDRB R1, [R3, R5]
24B6  47986803     LDR R3, [R0]
24B8  69604798     BLX R3
269:           			protocol->hwInterface->send(HW_INTERFACE, HIGH(TableStruct->piScope->timestamp));
24BA  68336960     LDR R0, [R4, #20]
24BC  6A9B6833     LDR R3, [R6]
24BE  5B596A9B     LDR R3, [R3, #40]
24C0  A095B59     LDRH R1, [R3, R5]
24C2  68030A09     LSRS R1, R1, #8
24C4  47986803     LDR R3, [R0]
24C6  68334798     BLX R3
270:           
271:           			checksum = LNET_OSM_SYN + TableStruct->piScope->txFrameSize + \
24C8  6A986833     LDR R3, [R6]
24CA  6A996A98     LDR R0, [R3, #40]
24D0  33025DC3     LDRB R3, [R0, R7]
24D2  7E273302     ADDS R3, #2
24D4  19DB7E27     LDRB R7, [R4, #24]
24D6  5B4F19DB     ADDS R3, R3, R7
24DA  5B5718FB     ADDS R3, R7, R3
24E0  B2FF18FF     ADDS R7, R7, R3
24E2  2300B2FF     UXTB R7, R7
272:           			    protocol->node + LOW(TableStruct->piScope->timestamp) + HIGH(TableStruct->piScope->timestamp);
24CC  6A9A6A99     LDR R1, [R3, #40]
24CE  5DC36A9A     LDR R2, [R3, #40]
24D8  18FB5B4F     LDRH R7, [R1, R5]
24DC  A3F5B57     LDRH R7, [R2, R5]
24DE  18FF0A3F     LSRS R7, R7, #8
273:           
274:                       i = (uint16)0;
24E4  46992300     MOVS R3, #0
24E6  4B174699     MOV R9, R3
275:                       do
276:                       {
277:                           j = (uint16)0;
24F0  464B2500     MOVS R5, #0
278:                           do
279:                           {
280:           #if defined(__DATA_WIDTH_16BIT__)
281:                               uint16 tmp;
282:                               tmp = *((uint16*)TableStruct->piScope->channelAddr[i] + j);
283:                               protocol->hwInterface->send(HW_INTERFACE, (uint8)tmp);
284:                               protocol->hwInterface->send(HW_INTERFACE, (uint8)(tmp >> 8));
285:                               checksum += (tmp & 0xFF);
286:                               checksum += (tmp >> 8);
287:           #elif defined(__DATA_WIDTH_8BIT__)
288:                               /* procedure not tested yet */
289:                               uint8 tmp;
290:                               tmp = *((uint8*) TableStruct->piScope->channelAddr[i] + j);
24E8  46984B17     LDR R3, $d
24EA  23554698     MOV R8, R3
24F2  9B464B     MOV R3, R9
24F4  469A009B     LSLS R3, R3, #2
24F6  4643469A     MOV R10, R3
24F8  681B4643     MOV R3, R8
24FA  6A9B681B     LDR R3, [R3]
24FC  44536A9B     LDR R3, [R3, #40]
24FE  685B4453     ADD R3, R10
2500  5D5E685B     LDR R3, [R3, #4]
2502  69605D5E     LDRB R6, [R3, R5]
291:                               protocol->hwInterface->send(HW_INTERFACE, tmp);
2504  68036960     LDR R0, [R4, #20]
2506  316803     LDR R3, [R0]
2508  47980031     MOVS R1, R6
250A  19F74798     BLX R3
292:                               checksum += tmp;									
250C  B2FF19F7     ADDS R7, R6, R7
250E  3501B2FF     UXTB R7, R7
293:           #else
294:           #error DATA WIDTH NOT DEFINED
295:           #endif
296:                               j++;
2510  B2AD3501     ADDS R5, #1
2512  4643B2AD     UXTH R5, R5
297:                           }
298:                           while (j < TableStruct->piScope->dataSize[i]);
2514  681A4643     MOV R3, R8
2516  6A93681A     LDR R2, [R3]
2518  444B6A93     LDR R3, [R2, #40]
251A  3324444B     ADD R3, R9
251C  781B3324     ADDS R3, #36
251E  42AB781B     LDRB R3, [R3]
2520  D8E942AB     CMP R3, R5
2522  464BD8E9     BHI.N 0x24F8
299:                           i++;
2524  3301464B     MOV R3, R9
2526  B29B3301     ADDS R3, #1
2528  4699B29B     UXTH R3, R3
252A  6A934699     MOV R9, R3
300:                       }
301:                       while(i < TableStruct->piScope->noChannels);
24EC  469B2355     MOVS R3, #85
24EE  2500469B     MOV R11, R3
252C  465A6A93     LDR R3, [R2, #40]
252E  5C9B465A     MOV R2, R11
2530  454B5C9B     LDRB R3, [R3, R2]
2532  D8DC454B     CMP R3, R9
2534  2F02D8DC     BHI.N 0x24F0
302:           
303:                       checksum &= 0xFF;
304:           			if (checksum == LNET_OSM_SYN)
2536  D0042F02     CMP R7, #2
2538  6960D004     BEQ.N 0x2544
305:           			{
306:           				checksum = ~checksum;
2544  E7F837FB     ADDS R7, #251
2546  2904E7F8     B.N 0x253A
2548  20002904     CMP R1, #4
254A  60C12000     MOVS R0, #0
307:           			}
308:           			protocol->hwInterface->send(HW_INTERFACE, checksum);
253A  68036960     LDR R0, [R4, #20]
253C  396803     LDR R3, [R0]
253E  47980039     MOVS R1, R7
2540  E7784798     BLX R3
2542  37FBE778     B.N 0x2436
309:           		}
310:           		else
311:           		{
312:           			/* debug: counter of failed transfers due to full tx fifo */
313:           			txBufFull++;
2468  68534A03     LDR R2, [PC, #12]
246A  33016853     LDR R3, [R2, #4]
246C  60533301     ADDS R3, #1
246E  E7E16053     STR R3, [R2, #4]
314:           		}
315:           	}
316:           }
317:           
318:           /**
319:            * @brief Receives and checks size.
320:            *
321:            * @param protocol Protocol
322:            * @param size Size
323:            *
324:            * @return 1 (true) in case of valid size otherwise 0 (false)
325:            */
326:           static uint8 receiveSize(tLNet* protocol, uint8 size)
327:           {
328:           	uint8 isValidSize = 0;
329:           
330:           	if (size > 0)
22DC  D01A2800     CMP R0, #0
22DE  7A63D01A     BEQ.N .LBE25
331:           	{
332:           		if (size > protocol->ucMaxCommSize)
22E0  42837A63     LDRB R3, [R4, #9]
22E2  D30E4283     CMP R3, R0
22E4  3D30E     BCC.N 0x2304
2392  42837A63     LDRB R3, [R4, #9]
333:           		{
334:           			protocol->ucRcvState = LNET_STATE_SYN;
2304  76632300     MOVS R3, #0
2306  68E27663     STRB R3, [R4, #25]
23AA  76632300     MOVS R3, #0
335:           			/* sends size error with 'Device Info' service identifier */
336:           			sendProtocolError(protocol, SV_ID_SVDEVICEINFO, ERRORSizeTooLarge);
337:           		}
338:           		else
339:           		{
340:           			protocol->ucFrameCheck = LNET_STD_SYN + size;
22E6  33550003     MOVS R3, R0
22E8  77233355     ADDS R3, #85
22EA  72207723     STRB R3, [R4, #28]
2398  33550003     MOVS R3, R0
341:           			protocol->ucFrameSize = size;
22EC  23007220     STRB R0, [R4, #8]
239E  23007220     STRB R0, [R4, #8]
342:           			protocol->ucFrameBufferPtr = 0;
22EE  77632300     MOVS R3, #0
22F0  33027763     STRB R3, [R4, #29]
23A0  77632300     MOVS R3, #0
343:           			protocol->ucRcvState = LNET_STATE_NODE;
22F2  76633302     ADDS R3, #2
22F4  227663     STRB R3, [R4, #25]
23A4  76633302     ADDS R3, #2
344:           			isValidSize = 1;
345:           		}
346:           	}
347:           	else
348:           	{
349:           		protocol->ucRcvState = LNET_STATE_SYN;
2316  76632300     MOVS R3, #0
2318  E0707663     STRB R3, [R4, #25]
231A  7E23E070     B.N 0x23FE
350:           	}
351:           	return (isValidSize);
352:           }
353:           
354:           static void sendProtocolError(tLNet* protocol, uint8 serviceId, uint8 errorId)
355:           {
356:           	protocol->ucFrameData[0] = serviceId;
2308  701368E2     LDR R2, [R4, #12]
23AE  701368E2     LDR R2, [R4, #12]
357:           	sendError((tProtocol*)protocol, errorId);
230C  202115     MOVS R1, #21
23B2  202115     MOVS R1, #21
23B4  F7FF0020     MOVS R0, R4
23B6  FD16F7FF     BL sendError
23B8  E020FD16     LDC2 P0, CR14, [R6, #-128]
23BA  7F23E020     B.N 0x23FE
23BC  2B557F23     LDRB R3, [R4, #28]
23BE  D0092B55     CMP R3, #85
23C0  2B02D009     BEQ.N 0x23D6
23C2  D0072B02     CMP R3, #2
23C4  7F23D007     BEQ.N 0x23D6
23C6  42937F23     LDRB R3, [R4, #28]
23C8  D0074293     CMP R3, R2
23CA  2113D007     BEQ.N 0x23DC
23CC  202113     MOVS R1, #19
23CE  F7FF0020     MOVS R0, R4
23D0  FD09F7FF     BL sendError
23D2  E013FD09     STC2 P0, CR14, [R9, #-76]
23D4  43DBE013     B.N 0x23FE
23D6  772343DB     MVNS R3, R3
23D8  E7F47723     STRB R3, [R4, #28]
23DA  68E3E7F4     B.N 0x23C6
23DC  781B68E3     LDR R3, [R4, #12]
23DE  2B1A781B     LDRB R3, [R3]
23E0  D8052B1A     CMP R3, #26
23E2  9BD805     BHI.N 0x23F0
23E4  6922009B     LSLS R3, R3, #2
23E6  589B6922     LDR R2, [R4, #16]
23E8  20589B     LDR R3, [R3, R2]
23EA  47980020     MOVS R0, R4
23EC  E0064798     BLX R3
23EE  2121E006     B.N 0x23FE
23F0  202121     MOVS R1, #33
23F2  F7FF0020     MOVS R0, R4
23F4  FCF7F7FF     BL sendError
23F6  E001FCF7     LDC2L P0, CR14, [R7], #4
23F8  2300E001     B.N 0x23FE
23FA  76632300     MOVS R3, #0
23FC  7EE37663     STRB R3, [R4, #25]
23FE  2B007EE3     LDRB R3, [R4, #27]
2400  D10E2B00     CMP R3, #0
2402  6960D10E     BNE.N .LBB33
2404  68836960     LDR R0, [R4, #20]
2406  47986883     LDR R3, [R0, #8]
2408  28004798     BLX R3
240A  D0092800     CMP R0, #0
240C  6960D009     BEQ.N .LBB33
240E  68436960     LDR R0, [R4, #20]
2410  47986843     LDR R3, [R0, #4]
2412  24798     BLX R3
2414  7E630002     MOVS R2, R0
2416  2B057E63     LDRB R3, [R4, #25]
2418  D8EE2B05     CMP R3, #5
241A  9BD8EE     BHI.N 0x23FA
241C  58EB009B     LSLS R3, R3, #2
241E  469F58EB     LDR R3, [R5, R3]
2420  4B17469F     MOV PC, R3
2422  681B4B17     LDR R3, [PC, #92]
2424  6A9A681B     LDR R3, [R3]
2426  2A006A9A     LDR R2, [R3, #40]
2428  D0042A00     CMP R2, #0
242A  6A9AD004     BEQ.N 0x2436
242C  234D6A9A     LDR R2, [R3, #40]
242E  5CD3234D     MOVS R3, #77
2430  2B045CD3     LDRB R3, [R2, R3]
2432  D0052B04     CMP R3, #4
2434  BC3CD005     BEQ.N 0x2442
2436  4690BC3C     POP {R2, R3, R4, R5}
2438  46994690     MOV R8, R2
243A  46A24699     MOV R9, R3
243C  46AB46A2     MOV R10, R4
243E  BDF846AB     MOV R11, R5
2440  6960BDF8     POP {R3, R4, R5, R6, R7, PC}
2442  69036960     LDR R0, [R4, #20]
2444  47986903     LDR R3, [R0, #16]
2446  4B0D4798     BLX R3
2448  681A4B0D     LDR R3, [PC, #52]
244A  6A91681A     LDR R2, [R3]
244C  235C6A91     LDR R1, [R2, #40]
244E  5CCB235C     MOVS R3, #92
2450  33045CCB     LDRB R3, [R1, R3]
2452  42983304     ADDS R3, #4
2454  DB074298     CMP R0, R3
2456  6A91DB07     BLT.N 0x2468
2458  6A906A91     LDR R1, [R2, #40]
245A  23586A90     LDR R0, [R2, #40]
245C  5AC92358     MOVS R3, #88
245E  3B025AC9     LDRH R1, [R1, R3]
2460  5AC33B02     SUBS R3, #2
2462  42995AC3     LDRH R3, [R0, R3]
2464  D20D4299     CMP R1, R3
2466  4A03D20D     BCS.N 0x2484
2468  68534A03     LDR R2, [PC, #12]
246A  33016853     LDR R3, [R2, #4]
246C  60533301     ADDS R3, #1
246E  E7E16053     STR R3, [R2, #4]
2470  46C0E7E1     B.N 0x2436
2472  609C46C0     MOV R8, R8
2474  609C     STR R4, [R3, #8]
2476  28580000     MOVS R0, R0
2478  20002858     CMP R0, #88
247A  60B42000     MOVS R0, #0
247C  60B4     STR R4, [R6, #8]
247E  29040000     MOVS R0, R0
2480  20002904     CMP R1, #4
2482  6A922000     MOVS R0, #0
2484  21006A92     LDR R2, [R2, #40]
2486  23582100     MOVS R1, #0
2488  52D12358     MOVS R3, #88
248A  696052D1     STRH R1, [R2, R3]
248C  68036960     LDR R0, [R4, #20]
248E  31026803     LDR R3, [R0]
2490  47983102     ADDS R1, #2
2492  69604798     BLX R3
2494  4E2C6960     LDR R0, [R4, #20]
2496  68334E2C     LDR R6, [PC, #176]
2498  6A9B6833     LDR R3, [R6]
249A  275C6A9B     LDR R3, [R3, #40]
249C  5DD9275C     MOVS R7, #92
249E  68035DD9     LDRB R1, [R3, R7]
24A0  47986803     LDR R3, [R0]
24A2  69604798     BLX R3
24A4  7E216960     LDR R0, [R4, #20]
24A6  68037E21     LDRB R1, [R4, #24]
24A8  47986803     LDR R3, [R0]
24AA  69604798     BLX R3
24AC  68336960     LDR R0, [R4, #20]
24AE  6A9B6833     LDR R3, [R6]
24B0  255A6A9B     LDR R3, [R3, #40]
24B2  5D59255A     MOVS R5, #90
24B4  68035D59     LDRB R1, [R3, R5]
24B6  47986803     LDR R3, [R0]
24B8  69604798     BLX R3
24BA  68336960     LDR R0, [R4, #20]
24BC  6A9B6833     LDR R3, [R6]
24BE  5B596A9B     LDR R3, [R3, #40]
24C0  A095B59     LDRH R1, [R3, R5]
24C2  68030A09     LSRS R1, R1, #8
24C4  47986803     LDR R3, [R0]
24C6  68334798     BLX R3
24C8  6A986833     LDR R3, [R6]
24CA  6A996A98     LDR R0, [R3, #40]
24CC  6A9A6A99     LDR R1, [R3, #40]
24CE  5DC36A9A     LDR R2, [R3, #40]
24D0  33025DC3     LDRB R3, [R0, R7]
24D2  7E273302     ADDS R3, #2
24D4  19DB7E27     LDRB R7, [R4, #24]
24D6  5B4F19DB     ADDS R3, R3, R7
24D8  18FB5B4F     LDRH R7, [R1, R5]
24DA  5B5718FB     ADDS R3, R7, R3
24DC  A3F5B57     LDRH R7, [R2, R5]
24DE  18FF0A3F     LSRS R7, R7, #8
24E0  B2FF18FF     ADDS R7, R7, R3
24E2  2300B2FF     UXTB R7, R7
24E4  46992300     MOVS R3, #0
24E6  4B174699     MOV R9, R3
24E8  46984B17     LDR R3, $d
24EA  23554698     MOV R8, R3
24EC  469B2355     MOVS R3, #85
24EE  2500469B     MOV R11, R3
24F0  464B2500     MOVS R5, #0
24F2  9B464B     MOV R3, R9
24F4  469A009B     LSLS R3, R3, #2
24F6  4643469A     MOV R10, R3
24F8  681B4643     MOV R3, R8
24FA  6A9B681B     LDR R3, [R3]
24FC  44536A9B     LDR R3, [R3, #40]
24FE  685B4453     ADD R3, R10
2500  5D5E685B     LDR R3, [R3, #4]
2502  69605D5E     LDRB R6, [R3, R5]
2504  68036960     LDR R0, [R4, #20]
2506  316803     LDR R3, [R0]
2508  47980031     MOVS R1, R6
250A  19F74798     BLX R3
250C  B2FF19F7     ADDS R7, R6, R7
250E  3501B2FF     UXTB R7, R7
2510  B2AD3501     ADDS R5, #1
2512  4643B2AD     UXTH R5, R5
2514  681A4643     MOV R3, R8
2516  6A93681A     LDR R2, [R3]
2518  444B6A93     LDR R3, [R2, #40]
251A  3324444B     ADD R3, R9
251C  781B3324     ADDS R3, #36
251E  42AB781B     LDRB R3, [R3]
2520  D8E942AB     CMP R3, R5
2522  464BD8E9     BHI.N 0x24F8
2524  3301464B     MOV R3, R9
2526  B29B3301     ADDS R3, #1
2528  4699B29B     UXTH R3, R3
252A  6A934699     MOV R9, R3
252C  465A6A93     LDR R3, [R2, #40]
252E  5C9B465A     MOV R2, R11
2530  454B5C9B     LDRB R3, [R3, R2]
2532  D8DC454B     CMP R3, R9
2534  2F02D8DC     BHI.N 0x24F0
2536  D0042F02     CMP R7, #2
2538  6960D004     BEQ.N 0x2544
253A  68036960     LDR R0, [R4, #20]
253C  396803     LDR R3, [R0]
253E  47980039     MOVS R1, R7
2540  E7784798     BLX R3
2542  37FBE778     B.N 0x2436
2544  E7F837FB     ADDS R7, #251
2546  2904E7F8     B.N 0x253A
2548  20002904     CMP R1, #4
254A  60C12000     MOVS R0, #0
358:           }
359:           
360:           /*
361:            * Initializes LNet by using an external buffer.
362:            * Hence this kind of LNet initialization doesn't use malloc
363:            * and therefore needs no heap memory.
364:            */
365:           void initLNet(tLNet* protocol, uint8* dataBuffer, uint8 dataBufferSize, uint8 node)
366:           {
367:           	protocol->ucFrameData = dataBuffer;
254C  724260C1     STR R1, [R0, #12]
368:           	protocol->ucMaxCommSize = dataBufferSize;
254E  76037242     STRB R2, [R0, #9]
369:           	protocol->node = node;
2550  4B047603     STRB R3, [R0, #24]
370:           
371:           	/* hook functions */
372:           	protocol->pCommunicate = (void (*)(tProtocol*))communicate;
2552  60034B04     LDR R3, [PC, #16]
2554  4B046003     STR R3, [R0]
373:           	protocol->pSnd_Enable = (void (*)(tProtocol*))enableSend;
2556  60434B04     LDR R3, [PC, #16]
2558  23006043     STR R3, [R0, #4]
374:           
375:           	/* set to receive state at begin */
376:           	enableReceive(protocol);
377:           }
2560  46C04770     BX LR
2562  21C546C0     MOV R8, R8
2564  21C5     MOVS R1, #197
2566  219D0000     MOVS R0, R0
2568  219D     MOVS R1, #157
256A  B5F00000     MOVS R0, R0
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/CommonFcts.c
1:             /* $LastChangedRevision: 842 $
2:              * $LastChangedDate:: 2015-11-26 15:56:03 +0100#$
3:              *
4:              * Copyright (c) 2015, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
5:              * All rights reserved.
6:              */
7:             #include "CommonFcts.h"
8:             
9:             /** Pseudo Initialization */
10:            void Common_Init(void* pTCommon)
11:            {
12:            }
4B9C  47704770     BX LR
13:            
14:            /** Pseudo Update */
15:            void Common_Update(void* pTCommon)
16:            {
17:            }
4B9E  20004770     BX LR
18:            
19:            /** Pseudo Load block data */
20:            int16 Common_Load(const void* pTCommon, uint8 ucData[])
21:            {
22:                return ((int16)0);
23:            }
4BA0  47702000     MOVS R0, #0
4BA2  1E504770     BX LR
24:            
25:            /** Pseudo Save block data */
26:            int16 Common_Save(void* pTCommon, const uint8 ucData[], uint8 ucFrameLength)
27:            {
28:            	int16 retVal;
29:            
30:                if (ucFrameLength != (uint8)0)
4BA4  41821E50     SUBS R0, R2, #1
4BA6  B2104182     SBCS R2, R0
31:                {
32:                	retVal = (int16)1;
33:                }
34:                else
35:                {
36:                	retVal = (int16)0;
37:                }
38:                return (retVal);
4BA8  4770B210     SXTH R0, R2
39:            }
4BAA  20004770     BX LR
40:            
41:            /** Pseudo Get Address */
42:            void* Common_GetAddress(const void* pTCommon, uint16 elementId)
43:            {
44:            	return ((void*)0);
45:            }
4BAC  47702000     MOVS R0, #0
4BAE  237F4770     BX LR
46:            
47:            /* abs(x) functions */
48:            
49:            /** @brief Calculation of 8-bit absolute value.
50:             *
51:             * out = |in|
52:             * 
53:             * @param x 8-bit fixed point input value.
54:             * @return Absolute value of input.
55:             */
56:            int8 getAbsValI8(int8 x){
57:            	if (x == ((int8)0x80)){
4BB2  32800002     MOVS R2, R0
4BB4  D0013280     ADDS R2, #128
4BB6  1E03D001     BEQ.N 0x4BBC
4BB8  DB011E03     SUBS R3, R0, #0
58:            		x = (int8)0x7F;
4BB0  2237F     MOVS R3, #127
59:            	}else if (x < 0){
4BBA  18DB01     BLT.N 0x4BC0
60:            		x = -(x);
4BC0  B2434240     RSBS R0, R0, #0
4BC2  E7FAB243     SXTB R3, R0
4BC4  4B05E7FA     B.N 0x4BBC
61:            	}
62:            	return (x);
63:            }
4BBC  47700018     MOVS R0, R3
4BBE  42404770     BX LR
4BC0  B2434240     RSBS R0, R0, #0
4BC2  E7FAB243     SXTB R3, R0
4BC4  4B05E7FA     B.N 0x4BBC
64:            
65:            /** @brief Calculation of 16-bit absolute value.
66:             *
67:             * out = |in|
68:             * 
69:             * @param x 16-bit fixed point input value.
70:             * @return Absolute value of input.
71:             */
72:            int16 getAbsValI16(int16 x){
73:            	if (x == ((int16)0x8000)){
4BC6  42984B05     LDR R3, [PC, #20]
4BC8  D0044298     CMP R0, R3
4BCA  1E03D004     BEQ.N 0x4BD6
4BCC  DA031E03     SUBS R3, R0, #0
74:            		x = (int16)0x7FFF;
4BD6  184B02     LDR R3, [PC, #8]
75:            	}else if (x < 0){
4BCE  4240DA03     BGE.N 0x4BD8
76:            		x = -(x);
4BD0  B2034240     RSBS R0, R0, #0
4BD2  E000B203     SXTH R3, R0
4BD4  4B02E000     B.N 0x4BD8
77:            	}
78:            	return (x);
79:            }
4BD8  47700018     MOVS R0, R3
4BDA  80004770     BX LR
4BDC  FFFF8000     STRH R0, [R0]
4BDE  7FFFFFFF     MRC2 P15, #7, R7, CR15, CR15, {7}
4BE0  7FFF     LDRB R7, [R7, #31]
4BE2  23800000     MOVS R0, R0
80:            
81:            /** @brief Calculation of 32-bit absolute value.
82:             *
83:             * out = |in|
84:             * 
85:             * @param x 32-bit fixed point input value.
86:             * @return Absolute value of input.
87:             */
88:            int32 getAbsValI32(int32 x){
89:            	if (x == ((int32)0x80000000)){
4BE4  61B2380     MOVS R3, #128
4BE6  4298061B     LSLS R3, R3, #24
4BE8  D0034298     CMP R0, R3
4BEA  17C3D003     BEQ.N 0x4BF4
4BEC  18C017C3     ASRS R3, R0, #31
4BEE  405818C0     ADDS R0, R0, R3
4BF0  47704058     EORS R0, R3
90:            		x = (int32)0x7FFFFFFF;
4BF4  E7FC4800     LDR R0, [PC]
91:            	}else if (x < 0){
92:            		x = -(x);
93:            	}
94:            	return (x);
4BF6  FFFFE7FC     B.N 0x4BF2
4BF8  7FFFFFFF     MRC2 P15, #7, R7, CR15, CR15, {7}
4BFA  B5307FFF     LDRB R7, [R7, #31]
95:            }
4BF2  48004770     BX LR
4BF4  E7FC4800     LDR R0, [PC]
4BF6  FFFFE7FC     B.N 0x4BF2
4BF8  7FFFFFFF     MRC2 P15, #7, R7, CR15, CR15, {7}
4BFA  B5307FFF     LDRB R7, [R7, #31]
96:            
97:            /** @brief Calculation of 64-bit absolute value.
98:             *
99:             * out = |in|
100:            * 
101:            * @param x 64-bit fixed point input value.
102:            * @return Absolute value of input.
103:            */
104:           int64 getAbsValI64(int64 x){
4BFC  2800B530     PUSH {R4, R5, LR}
105:           	if (x == ((int64)0x8000000000000000)){
4BFE  D00A2800     CMP R0, #0
4C00  17CCD00A     BEQ.N 0x4C18
4C02  2517CC     ASRS R4, R1, #31
4C04  40600025     MOVS R5, R4
4C06  24060     EORS R0, R4
4C08  40610002     MOVS R2, R0
4C0A  B4061     EORS R1, R4
4C0C  1B12000B     MOVS R3, R1
4C0E  41AB1B12     SUBS R2, R2, R4
4C10  1041AB     SBCS R3, R5
4C18  61B2380     MOVS R3, #128
4C1A  4299061B     LSLS R3, R3, #24
4C1C  D1F04299     CMP R1, R3
4C1E  2201D1F0     BNE.N 0x4C02
106:           		x = (int64)0x7FFFFFFFFFFFFFFF;
4C20  42522201     MOVS R2, #1
4C22  4B004252     RSBS R2, R2, #0
4C24  E7F44B00     LDR R3, [PC]
107:           	}else if (x < 0){
108:           		x = -(x);
109:           	}
110:           	return (x);
4C26  FFFFE7F4     B.N 0x4C12
4C28  7FFFFFFF     MRC2 P15, #7, R7, CR15, CR15, {7}
4C2A  B5107FFF     LDRB R7, [R7, #31]
111:           }
4C12  190010     MOVS R0, R2
4C14  BD300019     MOVS R1, R3
4C16  2380BD30     POP {R4, R5, PC}
4C18  61B2380     MOVS R3, #128
4C1A  4299061B     LSLS R3, R3, #24
4C1C  D1F04299     CMP R1, R3
4C1E  2201D1F0     BNE.N 0x4C02
4C20  42522201     MOVS R2, #1
4C22  4B004252     RSBS R2, R2, #0
4C24  E7F44B00     LDR R3, [PC]
4C26  FFFFE7F4     B.N 0x4C12
4C28  7FFFFFFF     MRC2 P15, #7, R7, CR15, CR15, {7}
4C2A  B5107FFF     LDRB R7, [R7, #31]
112:           
113:           /** @brief Calculation of single precision absolute value.
114:            *
115:            * out = |in|
116:            * 
117:            * @param x 32-bit floating point input value.
118:            * @return Absolute value of input.
119:            */
120:           float32 getAbsValR32(float32 x){
4C2C  1C04B510     PUSH {R4, LR}
4C2E  21001C04     ADDS R4, R0, #0
121:           	if (x < 0){
4C30  F0002100     MOVS R1, #0
4C32  FD6DF000     BL 0x5710
4C34  2800FD6D     STC2L P8, CR2, [SP]!
4C36  D1012800     CMP R0, #0
4C38  1C20D101     BNE.N 0x4C3E
122:           		x = -(x);
4C3E  61B2380     MOVS R3, #128
4C40  469C061B     LSLS R3, R3, #24
4C42  4464469C     MOV R12, R3
4C44  E7F84464     ADD R4, R12
4C46  B570E7F8     B.N 0x4C3A
123:           	}
124:           	return (x);
125:           }
4C3A  BD101C20     ADDS R0, R4, #0
4C3C  2380BD10     POP {R4, PC}
4C3E  61B2380     MOVS R3, #128
4C40  469C061B     LSLS R3, R3, #24
4C42  4464469C     MOV R12, R3
4C44  E7F84464     ADD R4, R12
4C46  B570E7F8     B.N 0x4C3A
126:           
127:           /** @brief Calculation of double precision absolute value.
128:            *
129:            * out = |in|
130:            * 
131:            * @param x 64-bit floating point input value.
132:            * @return Absolute value of input.
133:            */
134:           float64 getAbsValR64(float64 x){
4C48  5B570     PUSH {R4, R5, R6, LR}
4C4A  C0005     MOVS R5, R0
4C4C  2200000C     MOVS R4, R1
135:           	if (x < 0){
4C4E  23002200     MOVS R2, #0
4C50  282300     MOVS R3, #0
4C52  210028     MOVS R0, R5
4C54  F0000021     MOVS R1, R4
4C56  FCE7F000     BL 0x5628
4C58  2800FCE7     STC2L P8, CR2, [R7], #0
4C5A  D1022800     CMP R0, #0
4C5C  28D102     BNE.N 0x4C64
136:           		x = -(x);
4C64  61B2380     MOVS R3, #128
137:           	}
138:           	return (x);
139:           }
4C5E  210028     MOVS R0, R5
4C60  BD700021     MOVS R1, R4
4C62  2380BD70     POP {R4, R5, R6, PC}
4C64  61B2380     MOVS R3, #128
4C66  469C061B     LSLS R3, R3, #24
4C68  4464469C     MOV R12, R3
4C6A  E7F74464     ADD R4, R12
4C6C  46C0E7F7     B.N 0x4C5E
---  C:/Users/c17668/Documents/Box Sync/Motor Control/X2C/1.2.6 PRO_export/X2CScopeLib.X/X2CScope/src/BlockServicesX2C.c
1:             /**
2:              * @file
3:              * @brief Generic X2C block services.
4:              *
5:              * $LastChangedRevision: 781 $
6:              *
7:              * Copyright (c) 2013, Linz Center of Mechatronics GmbH (LCM) http://www.lcm.at/
8:              * All rights reserved.
9:              */
10:            #include "Services.h"
11:            #include "TableStruct.h"
12:            #include "BlockServicesX2C.h"
13:            
14:            extern volatile tTableStruct *TableStruct;
15:            
16:            /**
17:             * @brief Adds common block services to service table.
18:             *
19:             * @param[IN] protocol Protocol
20:             */
21:            void addBlockServices(tProtocol* protocol)
22:            {
23:                tSERVICEFunction* pServiceTable = (tSERVICEFunction*) protocol->pServiceTable;
31B4  4A036903     LDR R3, [R0, #16]
24:            
25:                pServiceTable[SV_ID_SVGETRAMBLOCK] = getRAMBlock;
31B6  625A4A03     LDR R2, [PC, #12]
31B8  4A03625A     STR R2, [R3, #36]
26:                pServiceTable[SV_ID_GETBLOCKDATA] = getBlockData;
31BA  61DA4A03     LDR R2, [PC, #12]
31BC  4A0361DA     STR R2, [R3, #28]
27:                pServiceTable[SV_ID_PUTBLOCKDATA] = putBlockData;
31BE  621A4A03     LDR R2, [PC, #12]
31C0  4770621A     STR R2, [R3, #32]
28:            }
31C2  2FB74770     BX LR
31C4  2FB7     CMP R7, #183
31C6  31250000     MOVS R0, R0
31C8  3125     ADDS R1, #37
31CA  30810000     MOVS R0, R0
31CC  3081     ADDS R0, #129
31CE  69030000     MOVS R0, R0
29:            
30:            /**
31:             * @brief Adds extended block services to service table.
32:             *
33:             * @param[IN] protocol Protocol
34:             */
35:            void addExtendedBlockServices(tProtocol* protocol)
36:            {
37:            	tSERVICEFunction* serviceTable = (tSERVICEFunction*) protocol->pServiceTable;
31D0  4A016903     LDR R3, [R0, #16]
38:            	serviceTable[SV_ID_SVPUTRAMBLOCK] = putRAMBlock;
31D2  629A4A01     LDR R2, [PC, #4]
31D4  4770629A     STR R2, [R3, #40]
39:            }
31D6  2ED94770     BX LR
31D8  2ED9     CMP R6, #217
31DA  B5F00000     MOVS R0, R0
40:            
41:            /**
42:             * @brief Writes data to target memory.
43:             *
44:             */
45:            void putRAMBlock(tProtocol* protocol)
46:            {
2ED8  5B5F8     PUSH {R3, R4, R5, R6, R7, LR}
2EDA  68C30005     MOVS R5, R0
47:            	void* addr;
48:            	uint8 size, type;
49:            	uint16 i;
50:            	const uint8 addrOffset = (uint8)1;
51:            #if defined(__ADDRESS_WIDTH_8BIT__)
52:            	const uint8 typeOffset = addrOffset + (uint8)1;
53:            #elif defined(__ADDRESS_WIDTH_16BIT__)
54:            	const uint8 typeOffset = addrOffset + (uint8)2;
55:            #elif defined(__ADDRESS_WIDTH_32BIT__)
56:            	const uint8 typeOffset = addrOffset + (uint8)4;
57:            #else
58:            #error ADDRESS WIDTH NOT DEFINED
59:            #endif
60:            	const uint8 dataOffset = typeOffset + (uint8)1;
61:            
62:            #if defined(__ADDRESS_WIDTH_8BIT__)
63:            	addr = (void*)((uint8)protocol->ucFRAMEData[addrOffset]);
64:            #elif defined(__ADDRESS_WIDTH_16BIT__)
65:            	addr = (void*)((uint16)protocol->ucFRAMEData[addrOffset] + \
66:            			((uint16)protocol->ucFRAMEData[addrOffset + 1] << 8));
67:            #elif defined(__ADDRESS_WIDTH_32BIT__)
68:            	addr = (void*)((uint32)protocol->ucFRAMEData[addrOffset] + \
2EDC  789E68C3     LDR R3, [R0, #12]
2EE8  18B6785A     LDRB R2, [R3, #1]
69:            			((uint32)protocol->ucFRAMEData[addrOffset + 1] << 8) + \
2EDE  236789E     LDRB R6, [R3, #2]
2EE0  78DA0236     LSLS R6, R6, #8
2EE6  785A18B6     ADDS R6, R6, R2
2EEA  791A18B6     ADDS R6, R6, R2
70:            			((uint32)protocol->ucFRAMEData[addrOffset + 2] << 16) + \
2EE2  41278DA     LDRB R2, [R3, #3]
2EE4  18B60412     LSLS R2, R2, #16
2EF0  7A0418B6     ADDS R6, R6, R2
71:            			((uint32)protocol->ucFRAMEData[addrOffset + 3] << 24));
2EEC  612791A     LDRB R2, [R3, #4]
2EEE  18B60612     LSLS R2, R2, #24
72:            #else
73:            #error ADDRESS WIDTH NOT DEFINED
74:            #endif
75:            
76:            	size = protocol->ucFRAMESize - dataOffset;
2EF2  3C067A04     LDRB R4, [R0, #8]
2EF4  B2E43C06     SUBS R4, #6
2EF6  795FB2E4     UXTB R4, R4
77:            	type = protocol->ucFRAMEData[typeOffset];
2EF8  39795F     LDRB R7, [R3, #5]
78:            
79:            	if (size % type)
2EFA  200039     MOVS R1, R7
2EFC  F0010020     MOVS R0, R4
2EFE  FB71F001     BL 0x45E4
2F00  B2C9FB71     USADA8 R2, R1, R9, R11
2F02  2900B2C9     UXTB R1, R1
2F04  D10A2900     CMP R1, #0
2F06  2F02D10A     BNE.N 0x2F1E
80:            	{
81:            		sendError(protocol, ERRORFormat);
2F1E  282114     MOVS R1, #20
2F20  F7FE0028     MOVS R0, R5
2F22  FF60F7FE     BL sendError
2F24  E045FF60     CDP2 P0, #6, CR14, CR0, CR5, {2}
82:            		return;
2F26  8A4E045     B.N .LVL22
83:            	}
84:            
85:            	switch (type)
2F08  D0282F02     CMP R7, #2
2F0A  2F04D028     BEQ.N .LBE2, .LBB3
2F0C  D00B2F04     CMP R7, #4
2F0E  2F01D00B     BEQ.N .LBB2
2F10  D03B2F01     CMP R7, #1
2F12  2114D03B     BEQ.N .LBE3, .LBB4
86:            	{
87:            		case DATATYPE_8BIT:
88:            		{
89:            			uint8* addr8 = (uint8*)addr;
90:            			for (i=0;i<size;i++)
2F8C  2C00B2A4     UXTH R4, R4
2F8E  D0082C00     CMP R4, #0
2F90  2300D008     BEQ.N .LBE4
2F92  68EA2300     MOVS R3, #0
2F9E  42A2B29A     UXTH R2, R3
2FA0  D3F742A2     CMP R2, R4
2FA2  2302D3F7     BCC.N 0x2F94
91:            			{
92:            				*addr8++ = (uint8)protocol->ucFRAMEData[dataOffset + i] & 0xFF;
2F94  18D268EA     LDR R2, [R5, #12]
2F96  799218D2     ADDS R2, R2, R3
2F98  559A7992     LDRB R2, [R2, #6]
2F9A  3301559A     STRB R2, [R3, R6]
2F9C  B29A3301     ADDS R3, #1
93:            			}
94:            			break;
95:            		}
96:            		case DATATYPE_16BIT:
97:            		{
98:            			uint16* addr16 = (uint16*)addr;
99:            			for (i=0;i<size/2;i++)
2F5E  D0200864     LSRS R4, R4, #1
2F60  3C01D020     BEQ.N .LBE4
2F62  B2A33C01     SUBS R4, #1
2F64  5BB2A3     UXTH R3, R4
2F66  199B005B     LSLS R3, R3, #1
2F68  3302199B     ADDS R3, R3, R6
2F6A  323302     ADDS R3, #2
2F6C  24070032     MOVS R2, R6
2F86  D1F5429A     CMP R2, R3
2F88  E00BD1F5     BNE.N 0x2F76
2F8A  B2A4E00B     B.N .LBE4
100:           			{
101:           				*addr16++ = (uint16)protocol->ucFRAMEData[dataOffset + 2*i] + \
2F72  1B8E2106     MOVS R1, #6
2F74  68E91B8E     SUBS R6, R1, R6
2F7E  18095D89     LDRB R1, [R1, R6]
2F80  80111809     ADDS R1, R1, R0
2F82  32028011     STRH R1, [R2]
2F84  429A3202     ADDS R2, #2
102:           						((uint16)protocol->ucFRAMEData[dataOffset + 2*i+1] << 8);
2F6E  1BA42407     MOVS R4, #7
2F70  21061BA4     SUBS R4, R4, R6
2F76  188968E9     LDR R1, [R5, #12]
2F78  5D081889     ADDS R1, R1, R2
2F7A  2005D08     LDRB R0, [R1, R4]
2F7C  5D890200     LSLS R0, R0, #8
103:           			}
104:           			break;
105:           		}
106:           		case DATATYPE_32BIT:
107:           		{
108:           			uint32* addr32 = (uint32*)addr;
109:           			for (i=0;i<size/4;i++)
2F28  D03B08A4     LSRS R4, R4, #2
2F2A  3C01D03B     BEQ.N .LBE4
2F2C  B2A43C01     SUBS R4, #1
2F2E  3403B2A4     UXTH R4, R4
2F30  A43403     ADDS R4, #3
2F32  220800A4     LSLS R4, R4, #2
2F34  3E082208     MOVS R2, #8
2F58  D1ED4294     CMP R4, R2
2F5A  E022D1ED     BNE.N 0x2F38
2F5C  864E022     B.N .LBE4
110:           			{
111:           				*addr32++ = (uint32)protocol->ucFRAMEData[dataOffset + 4*i] + \
2F36  68E83E08     SUBS R6, #8
2F38  188168E8     LDR R0, [R5, #12]
2F42  783F1E8F     SUBS R7, R1, #2
2F44  19DB783F     LDRB R7, [R7]
2F54  320450B3     STR R3, [R6, R2]
2F56  42943204     ADDS R2, #4
112:           						((uint32)protocol->ucFRAMEData[dataOffset + 4*i+1] << 8) + \
2F3A  1E4B1881     ADDS R1, R0, R2
2F3C  781B1E4B     SUBS R3, R1, #1
2F3E  21B781B     LDRB R3, [R3]
2F40  1E8F021B     LSLS R3, R3, #8
2F46  5C8019DB     ADDS R3, R3, R7
2F4C  7849181B     ADDS R3, R3, R0
113:           						((uint32)protocol->ucFRAMEData[dataOffset + 4*i+2] << 16) + \
2F48  4005C80     LDRB R0, [R0, R2]
2F4A  181B0400     LSLS R0, R0, #16
2F52  50B3185B     ADDS R3, R3, R1
114:           						((uint32)protocol->ucFRAMEData[dataOffset + 4*i+3] << 24);
2F4E  6097849     LDRB R1, [R1, #1]
2F50  185B0609     LSLS R1, R1, #24
115:           			}
116:           			break;
117:           		}
118:           		default:
119:           		{
120:           			sendError(protocol, ERRORFormat);
2F14  282114     MOVS R1, #20
2F16  F7FE0028     MOVS R0, R5
2F18  FF65F7FE     BL sendError
2F1A  E04AFF65     CDP2 P0, #6, CR14, CR5, CR10, {2}
121:           			return;
2F1C  2114E04A     B.N .LVL22
122:           		}
123:           	}
124:           
125:           	protocol->ucFRAMESize = (uint8)2;
2FA4  722B2302     MOVS R3, #2
2FA6  2300722B     STRB R3, [R5, #8]
126:           	protocol->ucFRAMEData[1] = ERRORSuccess;
2FA8  68EA2300     MOVS R3, #0
2FAA  705368EA     LDR R2, [R5, #12]
2FAC  686B7053     STRB R3, [R2, #1]
127:           	protocol->pSnd_Enable((struct tProtocol*)protocol);
2FAE  28686B     LDR R3, [R5, #4]
2FB0  47980028     MOVS R0, R5
2FB2  BDF84798     BLX R3
128:           }
2FB4  B5F8BDF8     POP {R3, R4, R5, R6, R7, PC}
129:           
130:           /**
131:            * @brief Reads data from target memory.
132:            *        Service is protected by payload protection.
133:            *
134:            * @param[IN] protocol Protocol
135:            */
136:           void getRAMBlock(tProtocol* protocol)
137:           {
2FB6  68C2B5F8     PUSH {R3, R4, R5, R6, R7, LR}
138:               void *addr;
139:               uint16 i;
140:               uint8 size, type;
141:               uint8 errorID = ERRORSuccess;
142:           #if defined(__ADDRESS_WIDTH_8BIT__)
143:               const uint8 addrOffset = (uint8)2;
144:           #elif defined(__ADDRESS_WIDTH_16BIT__)
145:               const uint8 addrOffset = (uint8)3;
146:           #elif defined(__ADDRESS_WIDTH_32BIT__)
147:               const uint8 addrOffset = (uint8)5;
148:           #else
149:           #error ADDRESS WIDTH NOT DEFINED
150:           #endif
151:           
152:               size = protocol->ucFRAMEData[addrOffset];
2FB8  795568C2     LDR R2, [R0, #12]
2FBA  1CA97955     LDRB R5, [R2, #5]
153:               type = protocol->ucFRAMEData[addrOffset + 1];
154:           
155:               if (((uint16) size + 2) > protocol->ucMaxCommSize)
2FBC  7A431CA9     ADDS R1, R5, #2
2FBE  42997A43     LDRB R3, [R0, #9]
2FC0  DC594299     CMP R1, R3
2FC2  7893DC59     BGT.N 0x2F78
156:               {
157:                   errorID = ERRORSizeTooLarge;
3078  F7FE2115     MOVS R1, #21
158:               }
159:               else
160:               {
161:           #if defined(__ADDRESS_WIDTH_8BIT__)
162:               	addr = (void*) ((uint8) protocol->ucFRAMEData[1];
163:           #elif defined(__ADDRESS_WIDTH_16BIT__)
164:                   addr = (void*) ((uint16) protocol->ucFRAMEData[1] + \
165:                           ((uint16) protocol->ucFRAMEData[2] << 8));
166:           #elif defined(__ADDRESS_WIDTH_32BIT__)
167:                   addr = (void*) ((uint32) protocol->ucFRAMEData[1] + \
2FCE  185B7851     LDRB R1, [R2, #1]
168:                           ((uint32) protocol->ucFRAMEData[2] << 8) + \
2FC4  21B7893     LDRB R3, [R2, #2]
2FC6  78D1021B     LSLS R3, R3, #8
2FCC  7851185B     ADDS R3, R3, R1
2FD0  7911185B     ADDS R3, R3, R1
169:                           ((uint32) protocol->ucFRAMEData[3] << 16) + \
2FC8  40978D1     LDRB R1, [R2, #3]
2FCA  185B0409     LSLS R1, R1, #16
2FD6  7992185B     ADDS R3, R3, R1
170:                           ((uint32) protocol->ucFRAMEData[4] << 24));
2FD2  6097911     LDRB R1, [R2, #4]
2FD4  185B0609     LSLS R1, R1, #24
171:           #else
172:           #error ADDRESS WIDTH NOT DEFINED
173:           #endif
174:           
175:                   switch (type)
2FD8  2A027992     LDRB R2, [R2, #6]
2FDA  D0372A02     CMP R2, #2
2FDC  2A04D037     BEQ.N .LBE6, .LBB7
2FDE  D0162A04     CMP R2, #4
2FE0  2114D016     BEQ.N .LBB6
2FE4  D1482A01     CMP R2, #1
2FE6  B2AED148     BNE.N 0x2F7A
176:                   {
177:                       case DATATYPE_8BIT:
178:                       {
179:                           uint8* addr8 = (uint8*) addr;
180:                           for (i = 0; i < size; i++)
2FE8  2E00B2AE     UXTH R6, R5
2FEA  D0082E00     CMP R6, #0
2FEC  2200D008     BEQ.N .LBE5
2FEE  5CD42200     MOVS R2, #0
2FFA  42B1B291     UXTH R1, R2
2FFC  D3F742B1     CMP R1, R6
2FFE  3502D3F7     BCC.N 0x2FF0
181:                           {
182:                               protocol->ucFRAMEData[2 + i] = (uint8) *addr8++;
2FF0  68C15CD4     LDRB R4, [R2, R3]
2FF2  188968C1     LDR R1, [R0, #12]
2FF4  708C1889     ADDS R1, R1, R2
2FF6  3201708C     STRB R4, [R1, #2]
2FF8  B2913201     ADDS R2, #1
183:                           }
184:                           break;
185:                       }
186:                       case DATATYPE_16BIT:
187:                       {
188:                           uint16* addr16 = (uint16*) addr;
189:                           for (i = 0; i < size; i += 2)
304E  2200B2AF     UXTH R7, R5
3050  2F002200     MOVS R2, #0
3052  D0D42F00     CMP R7, #0
3054  411D0D4     BEQ.N .LBE5
3070  42B9B291     UXTH R1, R2
3072  D3EF42B9     CMP R1, R7
3074  E7C3D3EF     BCC.N 0x3056
3076  2115E7C3     B.N .LBE5
190:                           {
191:                               protocol->ucFRAMEData[2 + i] = (uint8) *addr16;
3056  C090411     LSLS R1, R2, #16
3058  68C40C09     LSRS R1, R1, #16
305A  186468C4     LDR R4, [R0, #12]
305C  5AD61864     ADDS R4, R4, R1
305E  70A65AD6     LDRH R6, [R2, R3]
3060  68C470A6     STRB R6, [R4, #2]
192:                               protocol->ucFRAMEData[2 + i + 1] = (uint8) ((*addr16++) >> 8);
3062  46A468C4     LDR R4, [R0, #12]
3064  446146A4     MOV R12, R4
3066  5AD44461     ADD R1, R12
3068  A245AD4     LDRH R4, [R2, R3]
306A  70CC0A24     LSRS R4, R4, #8
306C  320270CC     STRB R4, [R1, #3]
306E  B2913202     ADDS R2, #2
193:                           }
194:                           break;
195:                       }
196:                       case DATATYPE_32BIT:
197:                       {
198:                           uint32* addr32 = (uint32*) addr;
199:                           for (i = 0; i < size; i += 4)
3010  2200B2AF     UXTH R7, R5
3012  2F002200     MOVS R2, #0
3014  D0F32F00     CMP R7, #0
3016  411D0F3     BEQ.N .LBE5
3046  42B9B291     UXTH R1, R2
3048  D3E542B9     CMP R1, R7
304A  E7D8D3E5     BCC.N 0x3018
304C  B2AFE7D8     B.N .LBE5
200:                           {
201:                               protocol->ucFRAMEData[2 + i] = (uint8) *addr32;
3018  C090411     LSLS R1, R2, #16
301A  68C40C09     LSRS R1, R1, #16
301C  186468C4     LDR R4, [R0, #12]
301E  5CD61864     ADDS R4, R4, R1
3020  70A65CD6     LDRB R6, [R2, R3]
3022  68C470A6     STRB R6, [R4, #2]
202:                               protocol->ucFRAMEData[2 + i + 1] = (uint8) ((*addr32) >> 8);
3024  186468C4     LDR R4, [R0, #12]
3026  58D61864     ADDS R4, R4, R1
3028  A3658D6     LDR R6, [R2, R3]
302A  70E60A36     LSRS R6, R6, #8
302C  68C470E6     STRB R6, [R4, #3]
203:                               protocol->ucFRAMEData[2 + i + 2] = (uint8) ((*addr32) >> 16);
302E  186468C4     LDR R4, [R0, #12]
3030  58D61864     ADDS R4, R4, R1
3032  C3658D6     LDR R6, [R2, R3]
3034  71260C36     LSRS R6, R6, #16
3036  68C47126     STRB R6, [R4, #4]
204:                               protocol->ucFRAMEData[2 + i + 3] = (uint8) ((*addr32++) >> 24);
3038  46A468C4     LDR R4, [R0, #12]
303A  446146A4     MOV R12, R4
303C  58D44461     ADD R1, R12
303E  E2458D4     LDR R4, [R2, R3]
3040  714C0E24     LSRS R4, R4, #24
3042  3204714C     STRB R4, [R1, #5]
3044  B2913204     ADDS R2, #4
205:                           }
206:                           break;
207:                       }
208:                       default:
209:                           errorID = ERRORFormat;
2FE2  2A012114     MOVS R1, #20
210:                           break;
211:                   }
212:               }
213:           
214:               if (errorID == ERRORSuccess)
215:               {
216:                   protocol->ucFRAMESize = size + 2;
3000  72053502     ADDS R5, #2
3002  23007205     STRB R5, [R0, #8]
217:                   protocol->ucFRAMEData[1] = errorID;
3004  68C22300     MOVS R3, #0
3006  705368C2     LDR R2, [R0, #12]
3008  68437053     STRB R3, [R2, #1]
218:                   protocol->pSnd_Enable((struct tProtocol*) protocol);
300A  47986843     LDR R3, [R0, #4]
300C  E0364798     BLX R3
300E  B2AFE036     B.N .LVL49
219:               }
220:               else
221:               {
222:                   sendError(protocol, errorID);
307A  FEB4F7FE     BL sendError
307C  BDF8FEB4     MRC2 P13, #5, R11, CR4, CR8, {7}
223:               }
224:           }
307E  B5F8BDF8     POP {R3, R4, R5, R6, R7, PC}
225:           
226:           /**
227:            * @brief Downloads block data to target.
228:            *
229:            * This services downloads block data by using the blocks' global address.
230:            * The block save function is executed if the block was found within the function table.
231:            *
232:            * @note This service is not protected by payload length protection.
233:            *       It's not required because response frame length <= request frame.
234:            */
235:           void putBlockData(tProtocol* protocol)
236:           {
3080  5B5F8     PUSH {R3, R4, R5, R6, R7, LR}
3082  68C30005     MOVS R5, R0
237:               uint16 id, i;
238:               uint16* addr;
239:           
240:           #if defined(__ADDRESS_WIDTH_8BIT__)
241:               const uint16 addrOffset = (uint8)2;
242:               addr = (uint16*) ((uint8) protocol->ucFRAMEData[1];
243:           #elif defined(__ADDRESS_WIDTH_16BIT__)
244:               const uint16 addrOffset = (uint8)3;
245:               addr = (uint16*) ((uint16) protocol->ucFRAMEData[1] + \
246:               		((uint16) protocol->ucFRAMEData[2] << 8));
247:           #elif defined(__ADDRESS_WIDTH_32BIT__)
248:               const uint16 addrOffset = (uint8)5;
249:               addr = (uint16*) ((uint32) protocol->ucFRAMEData[1] + \
3084  469C68C3     LDR R3, [R0, #12]
3086  7898469C     MOV R12, R3
3092  785B4663     MOV R3, R12
3094  18C0785B     LDRB R3, [R3, #1]
250:               		((uint32) protocol->ucFRAMEData[2] << 8) + \
3088  2007898     LDRB R0, [R3, #2]
308A  78DB0200     LSLS R0, R0, #8
3090  466318C0     ADDS R0, R0, R3
3096  466318C0     ADDS R0, R0, R3
251:               		((uint32) protocol->ucFRAMEData[3] << 16) + \
308C  41B78DB     LDRB R3, [R3, #3]
308E  18C0041B     LSLS R3, R3, #16
309E  880118C0     ADDS R0, R0, R3
252:               		((uint32) protocol->ucFRAMEData[4] << 24));
3098  791B4663     MOV R3, R12
309A  61B791B     LDRB R3, [R3, #4]
309C  18C0061B     LSLS R3, R3, #24
253:           #else
254:           #error ADDRESS WIDTH NOT DEFINED
255:           #endif
256:               id = *addr;
30A0  4B1F8801     LDRH R1, [R0]
257:           
258:               i = 0;
259:               while ((id != TableStruct->TFncTable[i].iBlockID) && (TableStruct->TFncTable[i].iBlockID != 0))
30A2  681E4B1F     LDR R3, [PC, #124]
30A4  6873681E     LDR R6, [R3]
30A6  881B6873     LDR R3, [R6, #4]
30A8  428B881B     LDRH R3, [R3]
30AA  D02A428B     CMP R3, R1
30AC  6873D02A     BEQ.N 0x3104
30AE  881B6873     LDR R3, [R6, #4]
30B0  2B00881B     LDRH R3, [R3]
30B2  D0282B00     CMP R3, #0
30B4  2200D028     BEQ.N 0x3108
30B6  32012200     MOVS R2, #0
30BC  536874     LDR R4, [R6, #4]
30BE  189B0053     LSLS R3, R2, #1
30C0  DB189B     ADDS R3, R3, R2
30C2  1F00DB     LSLS R3, R3, #3
30C4  5AE4001F     MOVS R7, R3
30C6  428C5AE4     LDRH R4, [R4, R3]
30C8  D003428C     CMP R4, R1
30CA  6874D003     BEQ.N 0x30D4
30CC  5AE36874     LDR R4, [R6, #4]
30CE  2B005AE3     LDRH R3, [R4, R3]
30D0  D1F12B00     CMP R3, #0
30D2  6873D1F1     BNE.N 0x30B8
3104  E7E52700     MOVS R7, #0
3106  2700E7E5     B.N 0x30D4
3108  E7E32700     MOVS R7, #0
310A  2141E7E3     B.N 0x30D4
260:               {
261:                   i++;
30B8  B2923201     ADDS R2, #1
30BA  6874B292     UXTH R2, R2
262:               }
263:               if (TableStruct->TFncTable[i].iBlockID == 0)
30D4  5BDB6873     LDR R3, [R6, #4]
30D6  2B005BDB     LDRH R3, [R3, R7]
30D8  D0172B00     CMP R3, #0
30DA  6873D017     BEQ.N 0x310C
264:               {
265:                   /* if correct block id was not found -> return wrong block id error */
266:                   sendError(protocol, ERRORBlkID);
310C  282141     MOVS R1, #65
310E  F7FE0028     MOVS R0, R5
3110  FE69F7FE     BL sendError
3112  BDF8FE69     MCR2 P13, #3, R11, CR9, CR8, {7}
267:               } else {
268:                   if (TableStruct->TFncTable[i].pFSave(addr, protocol->ucFRAMEData + addrOffset,  \
30DC  7A2A6873     LDR R3, [R6, #4]
30DE  3A057A2A     LDRB R2, [R5, #8]
30E0  B2D23A05     SUBS R2, #5
30E2  4661B2D2     UXTB R2, R2
30E4  31054661     MOV R1, R12
30E6  19DF3105     ADDS R1, #5
30E8  693B19DF     ADDS R7, R3, R7
30EA  4798693B     LDR R3, [R7, #16]
30EC  28004798     BLX R3
30EE  D1112800     CMP R0, #0
30F0  2302D111     BNE.N 0x3116
269:                           protocol->ucFRAMESize - addrOffset))
270:                   {
271:                       /* wrong data format */
272:                       sendError(protocol, ERRORFormat);
3116  282114     MOVS R1, #20
3118  F7FE0028     MOVS R0, R5
311A  FE64F7FE     BL sendError
311C  E7F9FE64     MCR2 P7, #3, LR, CR4, CR9, {7}
311E  2904E7F9     B.N .LVL66
3120  20002904     CMP R1, #4
3122  B5F82000     MOVS R0, #0
273:                   }
274:                   else
275:                   {
276:                       protocol->ucFRAMESize = 2;
30F2  722B2302     MOVS R3, #2
30F4  2300722B     STRB R3, [R5, #8]
277:                       protocol->ucFRAMEData[1] = ERRORSuccess;
30F6  68EA2300     MOVS R3, #0
30F8  705368EA     LDR R2, [R5, #12]
30FA  686B7053     STRB R3, [R2, #1]
278:                       protocol->pSnd_Enable((struct tProtocol*) protocol);
30FC  28686B     LDR R3, [R5, #4]
30FE  47980028     MOVS R0, R5
3100  E0074798     BLX R3
279:                   }
280:               }
281:           }
3102  2700E007     B.N .LVL66
3114  2114BDF8     POP {R3, R4, R5, R6, R7, PC}
3116  282114     MOVS R1, #20
3118  F7FE0028     MOVS R0, R5
311A  FE64F7FE     BL sendError
311C  E7F9FE64     MCR2 P7, #3, LR, CR4, CR9, {7}
311E  2904E7F9     B.N .LVL66
3120  20002904     CMP R1, #4
3122  B5F82000     MOVS R0, #0
282:           
283:           /**
284:            * @brief Uploads block data from target.
285:            *
286:            * This services uploads block data by using the blocks' global address.
287:            * The block load function is executed if the block was found within the function table.
288:            *
289:            * @note This service is not protected by payload length protection.
290:            *       Implementation is currently not possible => see line with pFLoad instruction.
291:            */
292:           void getBlockData(tProtocol* protocol)
293:           {
3124  5B5F8     PUSH {R3, R4, R5, R6, R7, LR}
3126  68C10005     MOVS R5, R0
294:               uint16 id, i;
295:               uint16 *addr;
296:           
297:           #if defined(__ADDRESS_WIDTH_8BIT__)
298:               	addr = (uint16*) ((uint8) protocol->ucFRAMEData[1];
299:           #elif defined(__ADDRESS_WIDTH_16BIT__)
300:                   addr = (uint16*) ((uint16) protocol->ucFRAMEData[1] + \
301:                           ((uint16) protocol->ucFRAMEData[2] << 8));
302:           #elif defined(__ADDRESS_WIDTH_32BIT__)
303:                   addr = (uint16*) ((uint32) protocol->ucFRAMEData[1] + \
3128  788868C1     LDR R1, [R0, #12]
3134  18C0784B     LDRB R3, [R1, #1]
304:                           ((uint32) protocol->ucFRAMEData[2] << 8) + \
312A  2007888     LDRB R0, [R1, #2]
312C  78CB0200     LSLS R0, R0, #8
3132  784B18C0     ADDS R0, R0, R3
3136  790B18C0     ADDS R0, R0, R3
305:                           ((uint32) protocol->ucFRAMEData[3] << 16) + \
312E  41B78CB     LDRB R3, [R1, #3]
3130  18C0041B     LSLS R3, R3, #16
313C  449C4684     MOV R12, R0
313E  4663449C     ADD R12, R3
306:                           ((uint32) protocol->ucFRAMEData[4] << 24));
3138  61B790B     LDRB R3, [R1, #4]
313A  4684061B     LSLS R3, R3, #24
307:           #else
308:           #error ADDRESS WIDTH NOT DEFINED
309:           #endif
310:               id = *addr;
3140  881F4663     MOV R3, R12
3142  4B1A881F     LDRH R7, [R3]
311:           
312:               i = 0;
313:               while ((id != TableStruct->TFncTable[i].iBlockID) && (TableStruct->TFncTable[i].iBlockID != 0))
3144  681E4B1A     LDR R3, $d
3146  6873681E     LDR R6, [R3]
3148  881B6873     LDR R3, [R6, #4]
314A  42BB881B     LDRH R3, [R3]
314C  D02542BB     CMP R3, R7
314E  6873D025     BEQ.N 0x319C
3150  881B6873     LDR R3, [R6, #4]
3152  2B00881B     LDRH R3, [R3]
3154  D0232B00     CMP R3, #0
3156  2200D023     BEQ.N 0x31A0
3158  32012200     MOVS R2, #0
315E  536874     LDR R4, [R6, #4]
3160  189B0053     LSLS R3, R2, #1
3162  DB189B     ADDS R3, R3, R2
3164  1800DB     LSLS R3, R3, #3
3166  5AE40018     MOVS R0, R3
3168  42BC5AE4     LDRH R4, [R4, R3]
316A  D00342BC     CMP R4, R7
316C  6874D003     BEQ.N 0x3176
316E  5AE36874     LDR R4, [R6, #4]
3170  2B005AE3     LDRH R3, [R4, R3]
3172  D1F12B00     CMP R3, #0
3174  6873D1F1     BNE.N 0x315A
319C  E7EA2000     MOVS R0, #0
319E  2000E7EA     B.N 0x3176
31A0  E7E82000     MOVS R0, #0
31A2  2141E7E8     B.N 0x3176
314:               {
315:                   i++;
315A  B2923201     ADDS R2, #1
315C  6874B292     UXTH R2, R2
316:               }
317:               if (TableStruct->TFncTable[i].iBlockID == 0)
3176  5A1B6873     LDR R3, [R6, #4]
3178  2B005A1B     LDRH R3, [R3, R0]
317A  D0122B00     CMP R3, #0
317C  6873D012     BEQ.N 0x31A4
318:               {
319:                   /* if correct block id was not found -> return wrong block id error */
320:                   sendError(protocol, ERRORBlkID);
31A4  282141     MOVS R1, #65
31A6  F7FE0028     MOVS R0, R5
31A8  FE1DF7FE     BL sendError
31AA  E7F5FE1D     MRC2 P7, #0, LR, CR13, CR5, {7}
31AC  46C0E7F5     B.N .LVL79
31AE  290446C0     MOV R8, R8
31B0  20002904     CMP R1, #4
31B2  69032000     MOVS R0, #0
321:               }
322:               else
323:               {
324:                   protocol->ucFRAMESize = 2 + TableStruct->TFncTable[i].pFLoad(addr, protocol->ucFRAMEData + 2);
317E  31026873     LDR R3, [R6, #4]
3180  18183102     ADDS R1, #2
3182  68C31818     ADDS R0, R3, R0
3184  466068C3     LDR R3, [R0, #12]
3186  47984660     MOV R0, R12
3188  30024798     BLX R3
318A  72283002     ADDS R0, #2
318C  23007228     STRB R0, [R5, #8]
325:                   protocol->ucFRAMEData[1] = ERRORSuccess;
318E  68EA2300     MOVS R3, #0
3190  705368EA     LDR R2, [R5, #12]
3192  686B7053     STRB R3, [R2, #1]
326:                   protocol->pSnd_Enable((struct tProtocol*) protocol);
3194  28686B     LDR R3, [R5, #4]
3196  47980028     MOVS R0, R5
3198  BDF84798     BLX R3
327:               }
328:           }
319A  2000BDF8     POP {R3, R4, R5, R6, R7, PC}
319C  E7EA2000     MOVS R0, #0
319E  2000E7EA     B.N 0x3176
31A0  E7E82000     MOVS R0, #0
31A2  2141E7E8     B.N 0x3176
31A4  282141     MOVS R1, #65
31A6  F7FE0028     MOVS R0, R5
31A8  FE1DF7FE     BL sendError
31AA  E7F5FE1D     MRC2 P7, #0, LR, CR13, CR5, {7}
31AC  46C0E7F5     B.N .LVL79
31AE  290446C0     MOV R8, R8
31B0  20002904     CMP R1, #4
31B2  69032000     MOVS R0, #0
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/newlib/newlib/libc/stdlib/atexit.c
64D0  1B510     PUSH {R4, LR}
64D2  23000001     MOVS R1, R0
64D4  22002300     MOVS R3, #0
64D6  20002200     MOVS R2, #0
64D8  F7FE2000     MOVS R0, #0
64DA  FBC9F7FE     BL __register_exitproc
64DC  BD10FBC9     SMLAL R11, SP, R9, R0
64DE  4B01BD10     POP {R4, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/newlib/newlib/libc/stdlib/__call_atexit.c
643A  2B00B510     PUSH {R4, LR}
6438  B5104B03     LDR R3, $d
643C  D0022B00     CMP R3, #0
643E  4802D002     BEQ.N .LVL0, .LBE2
6440  F0004802     LDR R0, [PC, #8]
6442  F845F000     BL atexit
6444  BD10F845     STR.W R11, [R5, #-16]!
6446  BD10     POP {R4, PC}
6448  0000     MOVS R0, R0
644A  60390000     MOVS R0, R0
644C  6039     STR R1, [R7]
644E  4B030000     MOVS R0, R0
0000  20007FF8     LDRB R0, [R7, #31]
0014  0000     MOVS R0, R0
001E  0000     MOVS R0, R0
0026  0000     MOVS R0, R0
00C4  4770469E     MOV LR, R3
0038  54FB     STRB R3, [R7, R3]
0042  54FB0000     MOVS R0, R0
0054  54FB     STRB R3, [R7, R3]
00A0  54FB     STRB R3, [R7, R3]
0074  54FB     STRB R3, [R7, R3]
0048  54FB     STRB R3, [R7, R3]
0058  54FB     STRB R3, [R7, R3]
005E  54FB0000     MOVS R0, R0
005C  54FB     STRB R3, [R7, R3]
0060  54FB     STRB R3, [R7, R3]
00DA  58AD4770     BX LR
0066  54FB0000     MOVS R0, R0
006A  54FB0000     MOVS R0, R0
006E  54FB0000     MOVS R0, R0
0072  54FB0000     MOVS R0, R0
002E  0000     MOVS R0, R0
003A  54FB0000     MOVS R0, R0
0070  54FB     STRB R3, [R7, R3]
0078  54FB     STRB R3, [R7, R3]
00D6  469EBC08     POP {R3}
0034  0000     MOVS R0, R0
0040  54FB     STRB R3, [R7, R3]
007E  54FB0000     MOVS R0, R0
0086  54FB0000     MOVS R0, R0
00DE  B5F00000     MOVS R0, R0
0090  54FB     STRB R3, [R7, R3]
0096  54FB0000     MOVS R0, R0
00A4  60FD     STR R5, [R7, #12]
00AA  54FB0000     MOVS R0, R0
00B0  54FB     STRB R3, [R7, R3]
00B6  54FB0000     MOVS R0, R0
00BA  B5F80000     MOVS R0, R0
00B8  54FB     STRB R3, [R7, R3]
00BC  46C0B5F8     PUSH {R3, R4, R5, R6, R7, LR}
00C0  BC08BCF8     POP {R3, R4, R5, R6, R7}
00E8  5CC2234C     MOVS R3, #76
00C8  6439     STR R1, [R7, #64]
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/newlib/newlib/libc/stdlib/__atexit.c
4C70  46DEB5F8     PUSH {R3, R4, R5, R6, R7, LR}
4C72  469B46DE     MOV LR, R11
4C74  4B31469B     MOV R11, R3
4C78  681C4645     MOV R5, R8
4C7E  4657464E     MOV R6, R9
4C80  5B4657     MOV R7, R10
4C84  5B5E0     PUSH {R5, R6, R7, LR}
4C86  58E00005     MOVS R5, R0
4C8A  4690000E     MOVS R6, R1
4C8C  28004690     MOV R8, R2
4C76  46454B31     LDR R3, [PC, #196]
4C7A  23A4681C     LDR R4, [R3]
4C7C  464E23A4     MOVS R3, #164
4C82  B5E0005B     LSLS R3, R3, #1
4C88  E58E0     LDR R0, [R4, R3]
4C8E  D04B2800     CMP R0, #0
4C90  6843D04B     BEQ.N 0x4C2A
4D2A  304D0020     MOVS R0, R4
4D2C  30FF304D     ADDS R0, #77
4D2E  50E030FF     ADDS R0, #255
4D30  E7AE50E0     STR R0, [R4, R3]
4D32  2001E7AE     B.N 0x4C92
4C92  2B1F6843     LDR R3, [R0, #4]
4C94  DC0D2B1F     CMP R3, #31
4C96  1C5CDC0D     BGT.N .LVL7
4C98  2D001C5C     ADDS R4, R3, #1
4CB4  2B004B22     LDR R3, [PC, #136]
4CB6  D03C2B00     CMP R3, #0
4CB8  20C8D03C     BEQ.N .LVL19
4D34  42402001     MOVS R0, #1
4CBA  4020C8     MOVS R0, #200
4CBC  E0000040     LSLS R0, R0, #1
4CBE  BF00E000     B.N .LVL9
4CC0  2800BF00     NOP
4CC2  D0362800     CMP R0, #0
4CC4  22A4D036     BEQ.N .LVL19
4CC8  522300     MOVS R3, #0
4CCE  60016043     STR R3, [R0, #4]
4CC6  230022A4     MOVS R2, #164
4CCA  58A10052     LSLS R2, R2, #1
4CCC  604358A1     LDR R1, [R4, R2]
4CD0  50A06001     STR R1, [R0]
4CD2  324050A0     STR R0, [R4, R2]
4CD4  50833240     ADDS R2, #64
4CD6  32045083     STR R3, [R0, R2]
4CD8  50833204     ADDS R2, #4
4CDA  24015083     STR R3, [R0, R2]
4CDC  2D002401     MOVS R4, #1
4C9A  D1212D00     CMP R5, #0
4C9C  3302D121     BNE.N .LVL10
4CDE  D0DD2D00     CMP R5, #0
4CE0  9AD0DD     BEQ.N .LVL3
4CE2  4691009A     LSLS R2, R3, #2
4CE4  44814691     MOV R9, R2
4CE6  46424481     ADD R9, R0
4CE8  21884642     MOV R2, R8
4CEA  464F2188     MOVS R1, #136
4CEC  507A464F     MOV R7, R9
4CEE  22C4507A     STR R2, [R7, R1]
4CF0  5222C4     MOVS R2, #196
4CF2  46900052     LSLS R2, R2, #1
4CF4  44804690     MOV R8, R2
4CF6  46424480     ADD R8, R0
4CF8  39874642     MOV R2, R8
4CFA  40993987     SUBS R1, #135
4CFC  68124099     LSLS R1, R3
4CFE  468A6812     LDR R2, [R2]
4D00  430A468A     MOV R10, R1
4D02  4694430A     ORRS R2, R1
4D04  46424694     MOV R12, R2
4D06  46614642     MOV R2, R8
4D08  60114661     MOV R1, R12
4D0A  22846011     STR R1, [R2]
4D0C  46492284     MOVS R2, #132
4D0E  465F4649     MOV R1, R9
4D10  52465F     MOV R7, R11
4D12  508F0052     LSLS R2, R2, #1
4D14  2D02508F     STR R7, [R1, R2]
4D16  D1C12D02     CMP R5, #2
4D18  2D1C1     BNE.N .LVL3
4D1A  46550002     MOVS R2, R0
4D1C  328D4655     MOV R5, R10
4D1E  32FF328D     ADDS R2, #141
4D20  681132FF     ADDS R2, #255
4D22  430D6811     LDR R1, [R2]
4D24  6015430D     ORRS R5, R1
4D26  E7B96015     STR R5, [R2]
4D28  20E7B9     B.N .LVL3
4C9E  9B3302     ADDS R3, #2
4CA0  6044009B     LSLS R3, R3, #2
4CA2  501E6044     STR R4, [R0, #4]
4CA4  2000501E     STR R6, [R3, R0]
4CA6  BC3C2000     MOVS R0, #0
4CA8  4690BC3C     POP {R2, R3, R4, R5}
4CAA  46994690     MOV R8, R2
4CAC  46A24699     MOV R9, R3
4CAE  46AB46A2     MOV R10, R4
4CB0  BDF846AB     MOV R11, R5
4CB2  4B22BDF8     POP {R3, R4, R5, R6, R7, PC}
4CB4  2B004B22     LDR R3, [PC, #136]
4CB6  D03C2B00     CMP R3, #0
4CB8  20C8D03C     BEQ.N .LVL19
4CBA  4020C8     MOVS R0, #200
4CBC  E0000040     LSLS R0, R0, #1
4CBE  BF00E000     B.N .LVL9
4CC0  2800BF00     NOP
4CC2  D0362800     CMP R0, #0
4CC4  22A4D036     BEQ.N .LVL19
4CC6  230022A4     MOVS R2, #164
4CC8  522300     MOVS R3, #0
4CCA  58A10052     LSLS R2, R2, #1
4CCC  604358A1     LDR R1, [R4, R2]
4CCE  60016043     STR R3, [R0, #4]
4CD0  50A06001     STR R1, [R0]
4CD2  324050A0     STR R0, [R4, R2]
4CD4  50833240     ADDS R2, #64
4CD6  32045083     STR R3, [R0, R2]
4CD8  50833204     ADDS R2, #4
4CDA  24015083     STR R3, [R0, R2]
4CDC  2D002401     MOVS R4, #1
4CDE  D0DD2D00     CMP R5, #0
4CE0  9AD0DD     BEQ.N .LVL3
4CE2  4691009A     LSLS R2, R3, #2
4CE4  44814691     MOV R9, R2
4CE6  46424481     ADD R9, R0
4CE8  21884642     MOV R2, R8
4CEA  464F2188     MOVS R1, #136
4CEC  507A464F     MOV R7, R9
4CEE  22C4507A     STR R2, [R7, R1]
4CF0  5222C4     MOVS R2, #196
4CF2  46900052     LSLS R2, R2, #1
4CF4  44804690     MOV R8, R2
4CF6  46424480     ADD R8, R0
4CF8  39874642     MOV R2, R8
4CFA  40993987     SUBS R1, #135
4CFC  68124099     LSLS R1, R3
4CFE  468A6812     LDR R2, [R2]
4D00  430A468A     MOV R10, R1
4D02  4694430A     ORRS R2, R1
4D04  46424694     MOV R12, R2
4D06  46614642     MOV R2, R8
4D08  60114661     MOV R1, R12
4D0A  22846011     STR R1, [R2]
4D0C  46492284     MOVS R2, #132
4D0E  465F4649     MOV R1, R9
4D10  52465F     MOV R7, R11
4D12  508F0052     LSLS R2, R2, #1
4D14  2D02508F     STR R7, [R1, R2]
4D16  D1C12D02     CMP R5, #2
4D18  2D1C1     BNE.N .LVL3
4D1A  46550002     MOVS R2, R0
4D1C  328D4655     MOV R5, R10
4D1E  32FF328D     ADDS R2, #141
4D20  681132FF     ADDS R2, #255
4D22  430D6811     LDR R1, [R2]
4D24  6015430D     ORRS R5, R1
4D26  E7B96015     STR R5, [R2]
4D28  20E7B9     B.N .LVL3
4D2A  304D0020     MOVS R0, R4
4D2C  30FF304D     ADDS R0, #77
4D2E  50E030FF     ADDS R0, #255
4D30  E7AE50E0     STR R0, [R4, R3]
4D32  2001E7AE     B.N 0x4C92
4D34  42402001     MOVS R0, #1
4D36  E7B64240     RSBS R0, R0, #0
4D38  46C0E7B6     B.N .LVL4, .LVL5, .LVL6
4D3A  653846C0     MOV R8, R8
4D3C  6538     STR R0, [R7, #80]
4D3E  0000     MOVS R0, R0
4D40  0000     MOVS R0, R0
4D42  B5700000     MOVS R0, R0
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/newlib/newlib/libc/misc/init.c
5C84  4E0DB570     PUSH {R4, R5, R6, LR}
5C86  4D0D4E0D     LDR R6, [PC, #52]
5C88  24004D0D     LDR R5, [PC, #52]
5C8C  10AD1BAD     SUBS R5, R5, R6
5C8E  D00510AD     ASRS R5, R5, #2
5C8A  1BAD2400     MOVS R4, #0
5C90  A3D005     BEQ.N .LVL4
5C96  47983401     ADDS R4, #1
5C9A  D1F942A5     CMP R5, R4
5C9C  F7FAD1F9     BNE.N .LVL1
5C92  58F300A3     LSLS R3, R4, #2
5C94  340158F3     LDR R3, [R6, R3]
5C98  42A54798     BLX R3
5C9E  FA0DF7FA     BL 0xBC
5CA0  4E08FA0D     LSL.W LR, SP, R8
5CA2  4D084E08     LDR R6, [PC, #32]
5CA4  24004D08     LDR R5, [PC, #32]
5CA8  10AD1BAD     SUBS R5, R5, R6
5CAA  D00510AD     ASRS R5, R5, #2
5CA6  1BAD2400     MOVS R4, #0
5CAC  A3D005     BEQ.N .LVL11, .LVL12
5CB2  47983401     ADDS R4, #1
5CB6  D1F942A5     CMP R5, R4
5CB8  BD70D1F9     BNE.N .LVL8
5CAE  58F300A3     LSLS R3, R4, #2
5CB0  340158F3     LDR R3, [R6, R3]
5CB4  42A54798     BLX R3
5CBA  C8BD70     POP {R4, R5, R6, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/newlib/newlib/libc/misc/fini.c
6038  4B09B570     PUSH {R4, R5, R6, LR}
603A  4C094B09     LDR R3, [PC, #36]
603C  1AE44C09     LDR R4, [PC, #36]
603E  10A41AE4     SUBS R4, R4, R3
6040  D00910A4     ASRS R4, R4, #2
6042  4A08D009     BEQ.N 0x6058
6044  18A54A08     LDR R2, [PC, #32]
6046  AD18A5     ADDS R5, R4, R2
6048  18ED00AD     LSLS R5, R5, #2
604A  682B18ED     ADDS R5, R5, R3
6054  D1F92C00     CMP R4, #0
6056  F7FAD1F9     BNE.N .LVL1
604C  3C01682B     LDR R3, [R5]
604E  47983C01     SUBS R4, #1
6050  3D044798     BLX R3
6052  2C003D04     SUBS R5, #4
6058  F83AF7FA     BL __init_array_end
605A  BD70F83A     LDRH.W R11, [R10, #-112]!
605C  46C0BD70     POP {R4, R5, R6, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/subsf3.c
256C  464FB5F0     PUSH {R4, R5, R6, R7, LR}
256E  46D6464F     MOV R7, R9
2570  464646D6     MOV LR, R10
2572  444646     MOV R6, R8
2576  FC2B5C0     PUSH {R6, R7, LR}
2574  B5C00044     LSLS R4, R0, #1
2578  2470FC2     LSRS R2, R0, #31
257A  2480247     LSLS R7, R0, #9
2584  480A7B     LSRS R3, R7, #9
258A  E24469A     MOV R10, R3
258C  150E24     LSRS R4, R4, #24
258E  DB0015     MOVS R5, R2
2590  E0000DB     LSLS R3, R3, #3
257C  A400248     LSLS R0, R1, #9
257E  46840A40     LSRS R0, R0, #9
2580  46664684     MOV R12, R0
2582  A7B4666     MOV R6, R12
2586  FC90048     LSLS R0, R1, #1
2588  469A0FC9     LSRS R1, R1, #31
2592  46890E00     LSRS R0, R0, #24
2594  F64689     MOV R9, R1
2596  28FF00F6     LSLS R6, R6, #3
2766  D0004     MOVS R4, R0
2768  E72D000D     MOVS R5, R1
276A  2F00E72D     B.N .L26
278A  24FF0033     MOVS R3, R6
278C  D24FF     MOVS R4, #255
278E  E732000D     MOVS R5, R1
2790  29FFE732     B.N .L7, .L43
281E  E7400004     MOVS R4, R0
2820  2B00E740     B.N .L12
2832  40033     MOVS R3, R6
2834  D0004     MOVS R4, R0
2836  E6DE000D     MOVS R5, R1
2838  28FFE6DE     B.N .L7, .L43
287C  24FF0033     MOVS R3, R6
2886  40033     MOVS R3, R6
2888  E6B50004     MOVS R4, R0
288A  2700E6B5     B.N .L7, .L43
288C  22002700     MOVS R7, #0
288E  E71C2200     MOVS R2, #0
2890  33E71C     B.N 0x26CC
2892  E6B00033     MOVS R3, R6
2894  2301E6B0     B.N .L7, .L43
2598  D10028FF     CMP R0, #255
259A  E08FD100     BNE.N 0x259E
259C  2101E08F     B.N 0x26BE
259E  464F2101     MOVS R1, #1
25A0  404F464F     MOV R7, R9
25A2  39404F     EORS R7, R1
25A4  42910039     MOVS R1, R7
25A6  D0664291     CMP R1, R2
25A8  1A22D066     BEQ.N 0x2578
25AA  2A001A22     SUBS R2, R4, R0
25AC  DC002A00     CMP R2, #0
25AE  E09DDC00     BGT.N 0x25B2
25B0  2800E09D     B.N 0x26EE
25B2  D13D2800     CMP R0, #0
25B4  2E00D13D     BNE.N 0x2632
25B6  D1002E00     CMP R6, #0
25B8  E08BD100     BNE.N 0x25BC
25BA  1E51E08B     B.N 0x26D4
25BC  29001E51     SUBS R1, R2, #1
25BE  D0002900     CMP R1, #0
25C0  E0B5D000     BEQ.N 0x25C4
25C2  2401E0B5     B.N 0x2730
25C4  1B9B2401     MOVS R4, #1
25C6  15A1B9B     SUBS R3, R3, R6
25C8  D544015A     LSLS R2, R3, #5
25CA  19BD544     BPL.N 0x2556
25CC  99F019B     LSLS R3, R3, #6
25CE  38099F     LSRS R7, R3, #6
25D0  F0030038     MOVS R0, R7
25D2  FC1DF003     BL .LFE0, .Letext0
25D4  3805FC1D     
25D6  40873805     SUBS R0, #5
25D8  42844087     LSLS R7, R0
25DA  DD004284     CMP R4, R0
25DC  E096DD00     BLE.N 0x25E0
25DE  1B04E096     B.N 0x270E
25E0  3A1B04     SUBS R4, R0, R4
25E2  2020003A     MOVS R2, R7
25E4  34012020     MOVS R0, #32
25E6  40E23401     ADDS R4, #1
25E8  1B0440E2     LSRS R2, R4
25EA  40A71B04     SUBS R4, R0, R4
25EC  3B40A7     LSLS R7, R4
25EE  1E5F003B     MOVS R3, R7
25F0  41BB1E5F     SUBS R7, R3, #1
25F2  240041BB     SBCS R3, R7
25F4  43132400     MOVS R4, #0
25F6  75A4313     ORRS R3, R2
2632  D0E02CFF     CMP R4, #255
2634  2180D0E0     BEQ.N .L7, .L43
2636  4C92180     MOVS R1, #128
2638  430E04C9     LSLS R1, R1, #19
263A  2A1B430E     ORRS R6, R1
263C  DC7B2A1B     CMP R2, #27
263E  31DC7B     BGT.N 0x2638
2640  20200031     MOVS R1, R6
2642  40D12020     MOVS R0, #32
2644  1A8240D1     LSRS R1, R2
2646  40961A82     SUBS R2, R0, R2
2648  1E724096     LSLS R6, R2
264A  41961E72     SUBS R2, R6, #1
264C  430E4196     SBCS R6, R2
264E  1B9B430E     ORRS R6, R1
2650  15A1B9B     SUBS R3, R3, R6
2652  D4BA015A     LSLS R2, R3, #5
2654  75AD4BA     BMI.N 0x27CC
2678  29001A21     SUBS R1, R4, R0
267A  DD4C2900     CMP R1, #0
267C  2800DD4C     BLE.N 0x2618
267E  D02A2800     CMP R0, #0
2680  2CFFD02A     BEQ.N 0x26D8
2682  D0B82CFF     CMP R4, #255
2684  2080D0B8     BEQ.N 0x27F8
2686  4C02080     MOVS R0, #128
2688  430604C0     LSLS R0, R0, #19
268A  291B4306     ORRS R6, R0
268C  DD00291B     CMP R1, #27
268E  E0AFDD00     BLE.N 0x2692
2690  30E0AF     B.N 0x27F2
2692  27200030     MOVS R0, R6
2694  40C82720     MOVS R7, #32
2696  1A7940C8     LSRS R0, R1
2698  408E1A79     SUBS R1, R7, R1
269A  1E71408E     LSLS R6, R1
269C  418E1E71     SUBS R1, R6, #1
269E  4306418E     SBCS R6, R1
26A0  199B4306     ORRS R6, R0
26A2  159199B     ADDS R3, R3, R6
26A4  D5D60159     LSLS R1, R3, #5
26A6  3401D5D6     BPL.N 0x2656
26A8  2CFF3401     ADDS R4, #1
26AA  D1002CFF     CMP R4, #255
26AC  E085D100     BNE.N 0x26B0
26AE  2201E085     B.N 0x27BC
26B0  497A2201     MOVS R2, #1
26B2  401A497A     LDR R1, [PC, #488]
26B4  85B401A     ANDS R2, R3
26B6  400B085B     LSRS R3, R3, #1
26B8  4313400B     ANDS R3, R1
26BA  E79C4313     ORRS R3, R2
26BC  2E00E79C     B.N .L7, .L43
26BE  D0002E00     CMP R6, #0
26C0  E770D000     BEQ.N 0x26C4
26C2  E76BE770     B.N 0x25A6
26C4  1E3BE76B     B.N 0x259E
26C6  D1C51E3B     SUBS R3, R7, #0
26C8  2200D1C5     BNE.N 0x2656
26CA  27B2200     MOVS R2, #0
26CC  A5B027B     LSLS R3, R7, #9
26CE  B2E40A5B     LSRS R3, R3, #9
26D0  E7A3B2E4     UXTB R4, R4
26D2  14E7A3     B.N .LBB13
26D4  E78F0014     MOVS R4, R2
26D6  2E00E78F     B.N .L7, .L43
26D8  D04D2E00     CMP R6, #0
26DA  1E48D04D     BEQ.N 0x2678
26DC  28001E48     SUBS R0, R1, #1
26DE  D1572800     CMP R0, #0
26E0  199BD157     BNE.N 0x2692
26E2  2401199B     ADDS R3, R3, R6
26E4  15A2401     MOVS R4, #1
26E6  D5B5015A     LSLS R2, R3, #5
26E8  2402D5B5     BPL.N 0x2856
26EA  E7E02402     MOVS R4, #2
26EC  2A00E7E0     B.N 0x26B0
26EE  D1252A00     CMP R2, #0
26F0  1C62D125     BNE.N 0x273E
26F2  B2D21C62     ADDS R2, R4, #1
26F4  2A01B2D2     UXTB R2, R2
26F6  DD722A01     CMP R2, #1
26F8  1B9FDD72     BLE.N 0x26E0
26FA  17A1B9F     SUBS R7, R3, R6
26FC  D535017A     LSLS R2, R7, #5
26FE  1AF7D535     BPL.N 0x276C
2700  D1AF7     SUBS R7, R6, R3
2702  E764000D     MOVS R5, R1
2704  2201E764     B.N .L41
2706  23002201     MOVS R2, #1
270E  4A63003B     MOVS R3, R7
2710  1A244A63     LDR R2, [PC, #396]
2712  40131A24     SUBS R4, R4, R0
2714  E76F4013     ANDS R3, R2
2716  2900E76F     B.N .L7, .L43
2718  D16C2900     CMP R1, #0
271A  1C61D16C     BNE.N 0x26F6
271C  B2C81C61     ADDS R1, R4, #1
271E  2801B2C8     UXTB R0, R1
2720  DD4E2801     CMP R0, #1
2722  29FFDD4E     BLE.N 0x26C2
2724  D04929FF     CMP R1, #255
2726  199BD049     BEQ.N 0x26BC
2728  85B199B     ADDS R3, R3, R6
272A  C085B     LSRS R3, R3, #1
272C  E763000C     MOVS R4, R1
272E  2AFFE763     B.N .L7, .L43
2730  D0412AFF     CMP R2, #255
2732  AD041     BEQ.N 0x26B8
2734  E781000A     MOVS R2, R1
2736  2601E781     B.N 0x263C
2738  1B9B2601     MOVS R6, #1
273A  E7891B9B     SUBS R3, R3, R6
273C  2C00E789     B.N 0x2652
273E  D01C2C00     CMP R4, #0
2740  28FFD01C     BEQ.N 0x277C
2742  D02128FF     CMP R0, #255
2744  2480D021     BEQ.N 0x278A
2746  4E42480     MOVS R4, #128
2748  425204E4     LSLS R4, R4, #19
274A  43234252     RSBS R2, R2, #0
274C  2A1B4323     ORRS R3, R4
274E  DD002A1B     CMP R2, #27
2750  E096DD00     BLE.N 0x2754
2752  1CE096     B.N 0x2882
2754  2520001C     MOVS R4, R3
2756  40D42520     MOVS R5, #32
2758  1AAA40D4     LSRS R4, R2
275A  40931AAA     SUBS R2, R5, R2
275C  1E5A4093     LSLS R3, R2
275E  41931E5A     SUBS R2, R3, #1
2760  43234193     SBCS R3, R2
2762  1AF34323     ORRS R3, R4
2764  41AF3     SUBS R3, R6, R3
276C  D0002F00     CMP R7, #0
276E  E72ED000     BEQ.N 0x2772
2770  2200E72E     B.N .L41
2772  24002200     MOVS R2, #0
2774  E7A92400     MOVS R4, #0
2776  CE7A9     B.N 0x26CC
2778  E73D000C     MOVS R4, R1
277A  2B00E73D     B.N .L7, .L43
277C  D0582B00     CMP R3, #0
277E  43D2D058     BEQ.N 0x2732
2780  2A0043D2     MVNS R2, R2
2782  D0EE2A00     CMP R2, #0
2784  28FFD0EE     BEQ.N 0x2764
2786  D1E128FF     CMP R0, #255
2788  33D1E1     BNE.N 0x274E
2792  D01029FF     CMP R1, #255
2794  1D010     BEQ.N 0x27B8
2796  E7780001     MOVS R1, R0
2798  2B00E778     B.N 0x268C
279A  D06E2B00     CMP R3, #0
279C  24FFD06E     BEQ.N 0x277C
279E  2E0024FF     MOVS R4, #255
27A0  D1002E00     CMP R6, #0
27A2  E728D100     BNE.N 0x27A6
27A4  2280E728     B.N .L7, .L43
27A6  46512280     MOVS R2, #128
27A8  3D24651     MOV R1, R10
27AA  421103D2     LSLS R2, R2, #15
27AC  D0034211     TST R1, R2
27AE  4661D003     BEQ.N 0x27B8
27B0  42114661     MOV R1, R12
27B2  D1004211     TST R1, R2
27B4  33D100     BNE.N 0x27B8
27B6  24FF0033     MOVS R3, R6
27B8  E71D24FF     MOVS R4, #255
27BA  24FFE71D     B.N .L7, .L43
27C2  D1E92C00     CMP R4, #0
27C4  2B00D1E9     BNE.N 0x279A
27C6  D0632B00     CMP R3, #0
27C8  2E00D063     BEQ.N 0x2792
27CA  D1002E00     CMP R6, #0
27CC  E713D100     BNE.N 0x27D0
27CE  199BE713     B.N .L7, .L43
27D0  15A199B     ADDS R3, R3, R6
27D2  D400015A     LSLS R2, R3, #5
27D4  E73ED400     BMI.N 0x27D8
27D6  4A31E73E     B.N 0x2656
27D8  C4A31     LDR R2, [PC, #196]
27DA  4013000C     MOVS R4, R1
27DC  E70B4013     ANDS R3, R2
27DE  2C00E70B     B.N .L7, .L43
27E0  D11E2C00     CMP R4, #0
27E2  2B00D11E     BNE.N 0x2822
27E4  D12F2B00     CMP R3, #0
27E6  2E00D12F     BNE.N 0x2848
27E8  D04F2E00     CMP R6, #0
27EA  33D04F     BEQ.N 0x278C
27EC  D0033     MOVS R3, R6
27EE  E702000D     MOVS R5, R1
27F0  2601E702     B.N .L7, .L43
27F2  E7552601     MOVS R6, #1
27F4  2C00E755     B.N 0x26A2
27F6  D11F2C00     CMP R4, #0
27F8  2B00D11F     BNE.N 0x283A
27FA  D0432B00     CMP R3, #0
27FC  43C9D043     BEQ.N 0x2786
27FE  290043C9     MVNS R1, R1
2800  D00B2900     CMP R1, #0
2802  28FFD00B     BEQ.N 0x281C
2804  D03928FF     CMP R0, #255
2806  291BD039     BEQ.N 0x287C
2808  DC44291B     CMP R1, #27
280A  1CDC44     BGT.N 0x2796
280C  2720001C     MOVS R4, R3
280E  40CC2720     MOVS R7, #32
2810  1A7940CC     LSRS R4, R1
2812  408B1A79     SUBS R1, R7, R1
2814  1E59408B     LSLS R3, R1
2816  418B1E59     SUBS R1, R3, #1
2818  4323418B     SBCS R3, R1
281A  199B4323     ORRS R3, R4
281C  4199B     ADDS R3, R3, R6
2822  D11A2B00     CMP R3, #0
2824  2E00D11A     BNE.N 0x285C
2826  D1242E00     CMP R6, #0
2828  2780D124     BNE.N 0x2874
282A  22002780     MOVS R7, #128
282C  3FF2200     MOVS R2, #0
282E  E71B03FF     LSLS R7, R7, #15
2830  33E71B     B.N 0x266A
283A  D01E28FF     CMP R0, #255
283C  2480D01E     BEQ.N 0x287C
283E  4E42480     MOVS R4, #128
2840  424904E4     LSLS R4, R4, #19
2842  43234249     RSBS R1, R1, #0
2844  E7DF4323     ORRS R3, R4
2846  2E00E7DF     B.N 0x2808
2848  D1002E00     CMP R6, #0
284A  E6D4D100     BNE.N 0x284E
284C  1B9FE6D4     B.N .L7, .L43
284E  17A1B9F     SUBS R7, R3, R6
2850  D400017A     LSLS R2, R7, #5
2852  E737D400     BMI.N 0x2856
2854  1AF3E737     B.N 0x26C6
2856  D1AF3     SUBS R3, R6, R3
2858  E6CD000D     MOVS R5, R1
285A  24FFE6CD     B.N .L7, .L43
285C  2E0024FF     MOVS R4, #255
285E  D1002E00     CMP R6, #0
2860  E6C9D100     BNE.N 0x2864
2862  2280E6C9     B.N .L7, .L43
2864  46502280     MOVS R2, #128
2866  3D24650     MOV R0, R10
2868  421003D2     LSLS R2, R2, #15
286A  D0A44210     TST R0, R2
286C  4660D0A4     BEQ.N 0x29B8
286E  42104660     MOV R0, R12
2870  D1A14210     TST R0, R2
2872  33D1A1     BNE.N 0x29B8
2874  D0033     MOVS R3, R6
2876  24FF000D     MOVS R5, R1
2878  E6BD24FF     MOVS R4, #255
287A  33E6BD     B.N .L7, .L43
287E  E6BA24FF     MOVS R4, #255
2880  2301E6BA     B.N .L7, .L43
2882  E76E2301     MOVS R3, #1
2884  33E76E     B.N 0x2764
2896  E7C02301     MOVS R3, #1
25F8  D004075A     LSLS R2, R3, #29
25FA  220FD004     BEQ.N 0x2606
25FC  401A220F     MOVS R2, #15
25FE  2A04401A     ANDS R2, R3
2600  D0002A04     CMP R2, #4
2602  3304D000     BEQ.N 0x2606
2604  15A3304     ADDS R3, #4
2606  D527015A     LSLS R2, R3, #5
2608  3401D527     BPL.N 0x265A
260A  2CFF3401     ADDS R4, #1
260C  D1002CFF     CMP R4, #255
260E  E079D100     BNE.N 0x2612
2610  2201E079     B.N 0x2706
2612  19B2201     MOVS R2, #1
2614  A5B019B     LSLS R3, R3, #6
2616  B2E40A5B     LSRS R3, R3, #9
2618  402AB2E4     UXTB R4, R4
261A  25B402A     ANDS R2, R5
261C  5E4025B     LSLS R3, R3, #9
261E  A5805E4     LSLS R4, R4, #23
2620  7D20A58     LSRS R0, R3, #9
2622  432007D2     LSLS R2, R2, #31
2624  43104320     ORRS R0, R4
2626  BC1C4310     ORRS R0, R2
2656  D1D0075A     LSLS R2, R3, #29
2658  2201D1D0     BNE.N 0x25FC
265A  8DF2201     MOVS R2, #1
265C  402A08DF     LSRS R7, R3, #3
265E  2CFF402A     ANDS R2, R5
2660  D1332CFF     CMP R4, #255
2662  2F00D133     BNE.N 0x26CC
2664  D1002F00     CMP R7, #0
2666  E0A8D100     BNE.N 0x266A
2668  2380E0A8     B.N 0x27BC
266A  3DB2380     MOVS R3, #128
266C  433B03DB     LSLS R3, R3, #15
266E  25B433B     ORRS R3, R7
2670  A5B025B     LSLS R3, R3, #9
2672  24FF0A5B     LSRS R3, R3, #9
2674  E7D124FF     MOVS R4, #255
2676  1A21E7D1     B.N .LBB13
2708  402A2300     MOVS R3, #0
270A  E786402A     ANDS R2, R5
270C  3BE786     B.N .LBB13
27BC  230024FF     MOVS R4, #255
27BE  E72C2300     MOVS R3, #0
27C0  2C00E72C     B.N .LBB13
2628  4690BC1C     POP {R2, R3, R4}
262A  46994690     MOV R8, R2
262C  46A24699     MOV R9, R3
262E  BDF046A2     MOV R10, R4
2630  2CFFBDF0     POP {R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/mulsf3.c
3750  4657B5F8     PUSH {R3, R4, R5, R6, R7, LR}
3752  464E4657     MOV R7, R10
3754  4645464E     MOV R6, R9
3756  46DE4645     MOV R5, R8
3758  B5E046DE     MOV LR, R11
375A  247B5E0     PUSH {R5, R6, R7, LR}
3760  A7F4688     MOV R8, R1
375C  460247     LSLS R7, R0, #9
375E  46880046     LSLS R6, R0, #1
3762  E360A7F     LSRS R7, R7, #9
3764  FC40E36     LSRS R6, R6, #24
3766  2E000FC4     LSRS R4, R0, #31
3768  D0472E00     CMP R6, #0
376A  2EFFD047     BEQ.N 0x36FC
376C  D0242EFF     CMP R6, #255
376E  FBD024     BEQ.N 0x37BA
3770  278000FB     LSLS R3, R7, #3
3772  4FF2780     MOVS R7, #128
3774  431F04FF     LSLS R7, R7, #19
3776  2300431F     ORRS R7, R3
3778  46992300     MOVS R3, #0
377A  469A4699     MOV R9, R3
377C  3E7F469A     MOV R10, R3
377E  46433E7F     SUBS R6, #127
37BA  D1422F00     CMP R7, #0
37BC  2308D142     BNE.N $d
37BE  46992308     MOVS R3, #8
37C0  3B064699     MOV R9, R3
37C2  26FF3B06     SUBS R3, #6
37C4  469A26FF     MOVS R6, #255
37C6  E7DA469A     MOV R10, R3
37C8  4641E7DA     B.N .LBB4
37FC  D1152F00     CMP R7, #0
37FE  2304D115     BNE.N .LBB6
3800  46992304     MOVS R3, #4
3802  3B034699     MOV R9, R3
3804  26003B03     SUBS R3, #3
3806  469A2600     MOVS R6, #0
3808  E7B9469A     MOV R10, R3
380A  20FFE7B9     B.N .LBB4
382C  F0020038     MOVS R0, R7
382E  FAEFF002     BL .LFE0, .Letext0
3832  1F432676     MOVS R6, #118
3834  409F1F43     SUBS R3, R0, #5
3836  2300409F     LSLS R7, R3
3838  42762300     MOVS R3, #0
383A  1A364276     RSBS R6, R6, #0
383C  46991A36     SUBS R6, R6, R0
383E  469A4699     MOV R9, R3
3840  E79D469A     MOV R10, R3
3842  230CE79D     B.N .LBB4
3844  4699230C     MOVS R3, #12
3846  3B094699     MOV R9, R3
3848  26FF3B09     SUBS R3, #9
384A  469A26FF     MOVS R6, #255
384C  E797469A     MOV R10, R3
384E  28E797     B.N .LBB4
3780  25D4643     MOV R3, R8
3782  58025D     LSLS R5, R3, #9
3784  FDB0058     LSLS R0, R3, #1
3786  A6D0FDB     LSRS R3, R3, #31
3788  E000A6D     LSRS R5, R5, #9
378A  46980E00     LSRS R0, R0, #24
378C  D0434698     MOV R8, R3
378E  28FFD043     BEQ.N 0x3718
3790  D03B28FF     CMP R0, #255
3792  EBD03B     BEQ.N 0x380C
3794  258000EB     LSLS R3, R5, #3
3796  22002580     MOVS R5, #128
3798  4ED2200     MOVS R2, #0
379A  431D04ED     LSLS R5, R5, #19
379C  387F431D     ORRS R5, R3
379E  1836387F     SUBS R0, #127
380C  220220FF     MOVS R0, #255
380E  2D002202     MOVS R2, #2
3810  D0C52D00     CMP R5, #0
3812  2203D0C5     BEQ.N 0x37A0
3814  E7C32203     MOVS R2, #3
3816  2D00E7C3     B.N 0x37A0
3818  D1192D00     CMP R5, #0
381A  2000D119     BNE.N .LBB7
381C  22012000     MOVS R0, #0
381E  E7BE2201     MOVS R2, #1
3820  2401E7BE     B.N 0x37A0
3822  22FF2401     MOVS R4, #1
3850  F0020028     MOVS R0, R5
3852  FADDF002     BL .LFE0, .Letext0
3854  1F43FADD     USUB16 PC, SP, R3
3856  409D1F43     SUBS R3, R0, #5
3858  2376409D     LSLS R5, R3
385A  425B2376     MOVS R3, #118
385C  1A18425B     RSBS R3, R3, #0
385E  22001A18     SUBS R0, R3, R0
3860  E79D2200     MOVS R2, #0
3862  2080E79D     B.N 0x37A0
37A0  1C731836     ADDS R6, R6, R0
37A2  46411C73     ADDS R3, R6, #1
37A4  469B4641     MOV R1, R8
37A6  464B469B     MOV R11, R3
37A8  4061464B     MOV R3, R9
37AA  43134061     EORS R1, R4
37AC  2B0F4313     ORRS R3, R2
37AE  D8642B0F     CMP R3, #15
37B0  4875D864     BHI.N 0x377C
37B2  9B4875     LDR R0, [PC, #468]
37B4  58C3009B     LSLS R3, R3, #2
37B6  469F58C3     LDR R3, [R0, R3]
37B8  2F00469F     MOV PC, R3
37CA  2A024641     MOV R1, R8
3864  24002080     MOVS R0, #128
3866  3C02400     MOVS R4, #0
3868  22FF03C0     LSLS R0, R0, #15
386A  E7BA22FF     MOVS R2, #255
386C  3DE7BA     B.N .LBB5
386E  4652003D     MOVS R5, R7
3870  E7AB4652     MOV R2, R10
3872  3DE7AB     B.N 0x37CC
3874  21003D     MOVS R5, R7
3876  46520021     MOVS R1, R4
3878  E7A74652     MOV R2, R10
387A  C3BE7A7     B.N 0x37CC
387C  469C0C3B     LSRS R3, R7, #16
387E  42A469C     MOV R12, R3
3880  C12042A     LSLS R2, R5, #16
3882  C2B0C12     LSRS R2, R2, #16
3884  140C2B     LSRS R3, R5, #16
3886  46600014     MOVS R4, R2
3888  46654660     MOV R0, R12
388A  43F4665     MOV R5, R12
388C  C3F043F     LSLS R7, R7, #16
388E  437C0C3F     LSRS R7, R7, #16
3890  4342437C     MULS R4, R7
3892  435D4342     MULS R2, R0
3894  437B435D     MULS R5, R3
3896  C27437B     MULS R3, R7
3898  189B0C27     LSRS R7, R4, #16
389A  18FF189B     ADDS R3, R3, R2
389C  42BA18FF     ADDS R7, R7, R3
389E  D90342BA     CMP R2, R7
38A0  2380D903     BLS.N 0x38AA
38A2  25B2380     MOVS R3, #128
38A4  469C025B     LSLS R3, R3, #9
38A6  4465469C     MOV R12, R3
38A8  4244465     ADD R5, R12
38AA  43A0424     LSLS R4, R4, #16
38AC  C24043A     LSLS R2, R7, #16
38AE  19120C24     LSRS R4, R4, #16
38B0  1931912     ADDS R2, R2, R4
38B2  1E5C0193     LSLS R3, R2, #6
38B4  41A31E5C     SUBS R4, R3, #1
38B6  C3F41A3     SBCS R3, R4
38B8  E920C3F     LSRS R7, R7, #16
38BA  197D0E92     LSRS R2, R2, #26
38BC  431A197D     ADDS R5, R7, R5
38BE  1AD431A     ORRS R2, R3
38C0  431501AD     LSLS R5, R5, #6
38C2  12B4315     ORRS R5, R2
38C4  D504012B     LSLS R3, R5, #4
38C6  2301D504     BPL.N 0x38D2
38C8  465E2301     MOVS R3, #1
38CA  86A465E     MOV R6, R11
38CC  401D086A     LSRS R2, R5, #1
38CE  4315401D     ANDS R5, R3
38D0  324315     ORRS R5, R2
3904  3C02080     MOVS R0, #128
3906  420703C0     LSLS R0, R0, #15
3908  D0074207     TST R7, R0
390A  4205D007     BEQ.N 0x391C
390C  D1054205     TST R5, R0
390E  4328D105     BNE.N 0x391C
3910  2404328     ORRS R0, R5
3912  A400240     LSLS R0, R0, #9
3914  46440A40     LSRS R0, R0, #9
3916  22FF4644     MOV R4, R8
3918  E76322FF     MOVS R2, #255
391A  4338E763     B.N .LBB5
391C  2404338     ORRS R0, R7
391E  A400240     LSLS R0, R0, #9
3920  22FF0A40     LSRS R0, R0, #9
3922  E75E22FF     MOVS R2, #255
3924  2401E75E     B.N .LBB5
37CC  D0282A02     CMP R2, #2
37CE  2A03D028     BEQ.N 0x3822
37D0  D1002A03     CMP R2, #3
37D2  E0CED100     BNE.N 0x37D6
37D4  2A01E0CE     B.N 0x3974
37D6  D0002A01     CMP R2, #1
37D8  E0ACD000     BEQ.N 0x37DC
37DA  4011E0AC     B.N 0x3936
37DC  20004011     ANDS R1, R2
37DE  22002000     MOVS R0, #0
37E0  B2CC2200     MOVS R2, #0
37E2  240B2CC     UXTB R4, R1
37E4  5D20240     LSLS R0, R0, #9
37E6  A4005D2     LSLS R2, R2, #23
37E8  7E40A40     LSRS R0, R0, #9
37EA  431007E4     LSLS R4, R4, #31
37EC  43204310     ORRS R0, R2
37EE  BC3C4320     ORRS R0, R4
3824  400C22FF     MOVS R2, #255
3826  2000400C     ANDS R4, R1
3828  E7DB2000     MOVS R0, #0
382A  38E7DB     B.N .LBB5
38D2  327F0032     MOVS R2, R6
38D4  2A00327F     ADDS R2, #127
38D6  DD252A00     CMP R2, #0
38D8  76BDD25     BLE.N 0x3926
38DA  D004076B     LSLS R3, R5, #29
38DC  230FD004     BEQ.N 0x38E8
38DE  402B230F     MOVS R3, #15
38E0  2B04402B     ANDS R3, R5
38E2  D0002B04     CMP R3, #4
38E4  3504D000     BEQ.N 0x38E8
38E6  12B3504     ADDS R5, #4
38E8  D503012B     LSLS R3, R5, #4
38EA  32D503     BPL.N 0x38F4
38EC  4B270032     MOVS R2, R6
38EE  32804B27     LDR R3, [PC, #156]
38F0  401D3280     ADDS R2, #128
38F2  2AFE401D     ANDS R5, R3
38F4  DC942AFE     CMP R2, #254
38F6  2401DC94     BGT.N .LVL86
38F8  1A82401     MOVS R4, #1
38FA  A4001A8     LSLS R0, R5, #6
38FC  B2D20A40     LSRS R0, R0, #9
38FE  400CB2D2     UXTB R2, R2
3900  E76F400C     ANDS R4, R1
3902  2080E76F     B.N .LBB5
3926  1AA32401     MOVS R4, #1
3928  2B1B1AA3     SUBS R3, R4, R2
392A  DD052B1B     CMP R3, #27
392C  400CDD05     BLE.N 0x393A
392E  2200400C     ANDS R4, R1
3930  20002200     MOVS R2, #0
3932  E7562000     MOVS R0, #0
3934  465EE756     B.N .LBB5
3936  E7CB465E     MOV R6, R11
3938  2AE7CB     B.N 0x38D2
393A  2020002A     MOVS R2, R5
393C  40DA2020     MOVS R0, #32
393E  1AC340DA     LSRS R2, R3
3940  409D1AC3     SUBS R3, R0, R3
3942  2B409D     LSLS R5, R3
3944  1E5D002B     MOVS R3, R5
3946  41AB1E5D     SUBS R5, R3, #1
3948  431341AB     SBCS R3, R5
394A  75A4313     ORRS R3, R2
394C  D004075A     LSLS R2, R3, #29
394E  220FD004     BEQ.N 0x395A
3950  401A220F     MOVS R2, #15
3952  2A04401A     ANDS R2, R3
3954  D0002A04     CMP R2, #4
3956  3304D000     BEQ.N 0x395A
3958  15A3304     ADDS R3, #4
395A  D504015A     LSLS R2, R3, #5
395C  2401D504     BPL.N 0x3968
395E  22012401     MOVS R4, #1
3960  400C2201     MOVS R2, #1
3962  2000400C     ANDS R4, R1
3964  E73D2000     MOVS R0, #0
3966  2401E73D     B.N .LBB5
3968  19B2401     MOVS R4, #1
396A  A58019B     LSLS R3, R3, #6
396C  400C0A58     LSRS R0, R3, #9
396E  2200400C     ANDS R4, R1
3970  E7372200     MOVS R2, #0
37F0  4690BC3C     POP {R2, R3, R4, R5}
37F2  46994690     MOV R8, R2
37F4  46A24699     MOV R9, R3
37F6  46AB46A2     MOV R10, R4
37F8  BDF846AB     MOV R11, R5
37FA  2F00BDF8     POP {R3, R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/lesf2.c
53F4  42B5F0     PUSH {R4, R5, R6, R7, LR}
53F6  24D0042     LSLS R2, R0, #1
53FC  A760246     LSLS R6, R0, #9
53FE  E120A76     LSRS R6, R6, #9
5400  FC30E12     LSRS R2, R2, #24
5402  A6D0FC3     LSRS R3, R0, #31
53F8  4C024D     LSLS R5, R1, #9
53FA  246004C     LSLS R4, R1, #1
5404  E240A6D     LSRS R5, R5, #9
5406  FC90E24     LSRS R4, R4, #24
5408  2AFF0FC9     LSRS R1, R1, #31
540A  D0162AFF     CMP R2, #255
540C  2CFFD016     BEQ.N 0x543C
540E  D0182CFF     CMP R4, #255
5410  2A00D018     BEQ.N 0x5444
5412  D10A2A00     CMP R2, #0
5414  4270D10A     BNE.N 0x542C
5416  41704270     RSBS R6, R0, #0
5418  B2C04170     ADCS R0, R6
541A  2C00B2C0     UXTB R0, R0
541C  D0152C00     CMP R4, #0
541E  2800D015     BEQ.N 0x544C
5420  D0052800     CMP R0, #0
5422  2001D005     BEQ.N 0x5430
5424  39012001     MOVS R0, #1
5426  43083901     SUBS R1, #1
5428  BDF04308     ORRS R0, R1
542C  D0132C00     CMP R4, #0
542E  4299D013     BEQ.N 0x5458
5430  D0144299     CMP R1, R3
5432  2001D014     BEQ.N 0x545E
5434  425B2001     MOVS R0, #1
5436  4318425B     RSBS R3, R3, #0
5438  E7F64318     ORRS R0, R3
543A  2002E7F6     B.N 0x542A
543C  2E002002     MOVS R0, #2
543E  D1F32E00     CMP R6, #0
5440  E7E4D1F3     BNE.N 0x542A
5442  2002E7E4     B.N 0x540E
5444  2D002002     MOVS R0, #2
5446  D1EF2D00     CMP R5, #0
5448  E7E2D1EF     BNE.N 0x542A
544A  2D00E7E2     B.N 0x5412
544C  D1E72D00     CMP R5, #0
544E  2000D1E7     BNE.N 0x5420
5450  2E002000     MOVS R0, #0
5452  D0E92E00     CMP R6, #0
5454  E7EDD0E9     BEQ.N 0x542A
5456  2D00E7ED     B.N 0x5434
5458  D1E92D00     CMP R5, #0
545A  E7EAD1E9     BNE.N 0x5430
545C  42A2E7EA     B.N 0x5434
545E  DC0642A2     CMP R2, R4
5460  DBDFDC06     BGT.N 0x5470
5462  42AEDBDF     BLT.N 0x5424
5464  D80342AE     CMP R6, R5
5466  2000D803     BHI.N 0x5470
5468  42AE2000     MOVS R0, #0
546A  D3DA42AE     CMP R6, R5
546C  E7DCD3DA     BCC.N 0x5424
546E  2001E7DC     B.N 0x542A
5470  42492001     MOVS R0, #1
542A  2C00BDF0     POP {R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/ledf2.c
4FA8  464EB5F0     PUSH {R4, R5, R6, R7, LR}
4FAA  4645464E     MOV R6, R9
4FAC  46DE4645     MOV R5, R8
4FAE  465746DE     MOV LR, R11
4FB0  5C4657     MOV R7, R10
4FB4  31FB5E0     PUSH {R5, R6, R7, LR}
4FBE  4D030E     LSLS R6, R1, #12
4FC0  FC9004D     LSLS R5, R1, #1
4FC2  46840FC9     LSRS R1, R1, #31
4FC4  B364684     MOV R12, R0
4FC6  D6D0B36     LSRS R6, R6, #12
4FC8  468B0D6D     LSRS R5, R5, #21
4FCA  4690468B     MOV R11, R1
4FB2  B5E0005C     LSLS R4, R3, #1
4FB6  FDB031F     LSLS R7, R3, #12
4FB8  46990FDB     LSRS R3, R3, #31
4FBA  4B2A4699     MOV R9, R3
4FCC  B3F4690     MOV R8, R2
4FCE  D640B3F     LSRS R7, R7, #12
4FD0  429D0D64     LSRS R4, R4, #21
4FBC  30E4B2A     LDR R3, $d
4FD2  D020429D     CMP R5, R3
4FD4  4B24D020     BEQ.N 0x5018
4FD6  429C4B24     LDR R3, [PC, #144]
4FD8  D022429C     CMP R4, R3
4FDA  2D00D022     BEQ.N 0x5022
4FDC  D1122D00     CMP R5, #0
4FDE  4330D112     BNE.N 0x5006
4FE0  42434330     ORRS R0, R6
4FE2  41434243     RSBS R0, R3, #0
4FE4  B2DB4143     ADCS R3, R0
4FE6  2C00B2DB     UXTB R3, R3
4FE8  D01F2C00     CMP R4, #0
4FEA  2B00D01F     BEQ.N 0x502C
4FEC  D00C2B00     CMP R3, #0
4FEE  464BD00C     BEQ.N 0x500A
4FF0  2001464B     MOV R3, R9
4FF2  3B012001     MOVS R0, #1
4FF4  43033B01     SUBS R3, #1
4FF6  184303     ORRS R3, R0
5006  D0162C00     CMP R4, #0
5008  45CBD016     BEQ.N 0x5038
500A  D01745CB     CMP R11, R9
500C  465BD017     BEQ.N 0x503E
500E  4259465B     MOV R3, R11
5010  23014259     RSBS R3, R1, #0
5012  430B2301     MOVS R3, #1
5014  E7EF430B     ORRS R3, R1
5016  31E7EF     B.N 0x4FF8
5018  23020031     MOVS R1, R6
501A  43012302     MOVS R3, #2
501C  D1EB4301     ORRS R1, R0
501E  E7D9D1EB     BNE.N 0x4FF8
5020  39E7D9     B.N 0x4FD6
5022  23020039     MOVS R1, R7
5024  43112302     MOVS R3, #2
5026  D1E64311     ORRS R1, R2
5028  E7D7D1E6     BNE.N 0x4FF8
502A  433AE7D7     B.N 0x4FDC
502C  D1DD433A     ORRS R2, R7
502E  2300D1DD     BNE.N 0x4FEC
5030  28002300     MOVS R3, #0
5032  D0E02800     CMP R0, #0
5034  E7EAD0E0     BEQ.N 0x4FF8
5036  433AE7EA     B.N 0x500E
5038  D1E6433A     ORRS R2, R7
503A  E7E7D1E6     BNE.N 0x500A
503C  42A5E7E7     B.N 0x500E
503E  DCE542A5     CMP R5, R4
5040  DB05DCE5     BGT.N 0x500E
5042  42BEDB05     BLT.N 0x5050
5044  D8E242BE     CMP R6, R7
5046  D007D8E2     BHI.N 0x500E
5048  2300D007     BEQ.N 0x505A
504A  42BE2300     MOVS R3, #0
504C  D2D342BE     CMP R6, R7
504E  4659D2D3     BCS.N 0x4FF8
5050  23014659     MOV R1, R11
5052  39012301     MOVS R3, #1
5054  430B3901     SUBS R1, #1
5056  E7CE430B     ORRS R3, R1
5058  45C4E7CE     B.N 0x4FF8
505A  D8D745C4     CMP R12, R8
505C  2300D8D7     BHI.N 0x500E
505E  45C42300     MOVS R3, #0
4FF8  BC3C0018     MOVS R0, R3
4FFA  4690BC3C     POP {R2, R3, R4, R5}
4FFC  46994690     MOV R8, R2
4FFE  46A24699     MOV R9, R3
5000  46AB46A2     MOV R10, R4
5002  BDF046AB     MOV R11, R5
5004  2C00BDF0     POP {R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/gesf2.c
557C  42B5F0     PUSH {R4, R5, R6, R7, LR}
557E  2450042     LSLS R2, R0, #1
5580  24C0245     LSLS R5, R0, #9
5584  480FC3     LSRS R3, R0, #31
5588  E120A6D     LSRS R5, R5, #9
558A  A640E12     LSRS R2, R2, #24
5582  FC3024C     LSLS R4, R1, #9
5586  A6D0048     LSLS R0, R1, #1
558C  E000A64     LSRS R4, R4, #9
558E  FC90E00     LSRS R0, R0, #24
5590  2AFF0FC9     LSRS R1, R1, #31
5592  D01E2AFF     CMP R2, #255
5594  28FFD01E     BEQ.N 0x55D4
5596  D02128FF     CMP R0, #255
5598  2A00D021     BEQ.N 0x55DE
559A  D10A2A00     CMP R2, #0
559C  426ED10A     BNE.N 0x55B4
559E  416E426E     RSBS R5, R6, #0
55A0  B2F6416E     ADCS R6, R5
55A2  2800B2F6     UXTB R6, R6
55A4  D10F2800     CMP R0, #0
55A6  2C00D10F     BNE.N 0x55C8
55A8  D10D2C00     CMP R4, #0
55AA  2000D10D     BNE.N 0x55C8
55AC  2D002000     MOVS R0, #0
55AE  D0092D00     CMP R5, #0
55B0  E005D009     BEQ.N 0x55C6
55B2  2800E005     B.N 0x55C0
55B4  D1012800     CMP R0, #0
55B6  2C00D101     BNE.N 0x55BC
55B8  D0012C00     CMP R4, #0
55BA  428BD001     BEQ.N 0x55C0
55BC  D011428B     CMP R3, R1
55BE  2101D011     BEQ.N 0x55E4
55C0  42582101     MOVS R1, #1
55C2  43084258     RSBS R3, R0, #0
55C4  BDF04308     ORRS R0, R1
55C8  D0F72E00     CMP R6, #0
55CA  2001D0F7     BEQ.N 0x55BC
55CC  39012001     MOVS R0, #1
55CE  43083901     SUBS R1, #1
55D0  E7F84308     ORRS R0, R1
55D2  2D00E7F8     B.N 0x55C6
55D4  D0DE2D00     CMP R5, #0
55D6  2002D0DE     BEQ.N 0x5596
55D8  42402002     MOVS R0, #2
55DA  E7F34240     RSBS R0, R0, #0
55DC  2C00E7F3     B.N 0x55C6
55DE  D0DB2C00     CMP R4, #0
55E0  E7F9D0DB     BEQ.N 0x559A
55E2  4282E7F9     B.N 0x55D8
55E4  DCEB4282     CMP R2, R0
55E6  DB04DCEB     BGT.N 0x55C0
55E8  42A5DB04     BLT.N 0x55F4
55EA  D8E842A5     CMP R5, R4
55EC  2000D8E8     BHI.N 0x55C0
55EE  42A52000     MOVS R0, #0
55F0  D2E842A5     CMP R5, R4
55F2  2101D2E8     BCS.N 0x55C6
55F4  1E582101     MOVS R1, #1
55C6  2E00BDF0     POP {R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/gedf2.c
4EE0  4645B5F0     PUSH {R4, R5, R6, R7, LR}
4EE2  46DE4645     MOV R5, R8
4EE4  465746DE     MOV LR, R11
4EE6  464E4657     MOV R7, R10
4EE8  B5E0464E     MOV R6, R9
4EEA  31FB5E0     PUSH {R5, R6, R7, LR}
4EF2  4C030E     LSLS R6, R1, #12
4EF4  46AB004C     LSLS R4, R1, #1
4EFA  B364684     MOV R12, R0
4EFC  D640B36     LSRS R6, R6, #12
4EFE  FC90D64     LSRS R4, R4, #21
4F00  46900FC9     LSRS R1, R1, #31
4EEC  B3D031F     LSLS R7, R3, #12
4EEE  4F2C0B3D     LSRS R5, R7, #12
4EF6  5D46AB     MOV R11, R5
4EF8  4684005D     LSLS R5, R3, #1
4F02  D6D4690     MOV R8, R2
4F04  FDB0D6D     LSRS R5, R5, #21
4F06  42BC0FDB     LSRS R3, R3, #31
4EF0  30E4F2C     LDR R7, $d
4F08  D02A42BC     CMP R4, R7
4F0A  4F25D02A     BEQ.N 0x4F62
4F0C  42BD4F25     LDR R7, $d
4F0E  D02D42BD     CMP R5, R7
4F10  2C00D02D     BEQ.N 0x4F6E
4F12  D10F2C00     CMP R4, #0
4F14  4330D10F     BNE.N 0x4F36
4F16  74330     ORRS R0, R6
4F18  46810007     MOVS R7, R0
4F1A  42784681     MOV R9, R0
4F1C  41784278     RSBS R7, R0, #0
4F1E  B2C04178     ADCS R0, R7
4F20  2D00B2C0     UXTB R0, R0
4F22  D1172D00     CMP R5, #0
4F24  465FD117     BNE.N 0x4F56
4F26  433A465F     MOV R7, R11
4F28  D114433A     ORRS R2, R7
4F2A  464BD114     BNE.N 0x4F56
4F2C  2000464B     MOV R3, R9
4F2E  2B002000     MOVS R0, #0
4F30  D00A2B00     CMP R3, #0
4F32  E006D00A     BEQ.N 0x4F4A
4F34  2D00E006     B.N 0x4F44
4F36  D1022D00     CMP R5, #0
4F38  4658D102     BNE.N 0x4F40
4F3A  43024658     MOV R0, R11
4F3C  D0014302     ORRS R2, R0
4F3E  4299D001     BEQ.N 0x4F44
4F40  D0184299     CMP R1, R3
4F42  4248D018     BEQ.N 0x4F76
4F44  21014248     RSBS R1, R0, #0
4F46  43082101     MOVS R1, #1
4F48  BC3C4308     ORRS R0, R1
4F56  D0F22800     CMP R0, #0
4F58  2001D0F2     BEQ.N 0x4F40
4F5A  3B012001     MOVS R0, #1
4F5C  43183B01     SUBS R3, #1
4F5E  E7F34318     ORRS R0, R3
4F60  37E7F3     B.N 0x4F4A
4F62  43070037     MOVS R7, R6
4F64  D0D14307     ORRS R7, R0
4F66  2002D0D1     BEQ.N 0x4F0C
4F68  42402002     MOVS R0, #2
4F6A  E7ED4240     RSBS R0, R0, #0
4F6C  465FE7ED     B.N 0x4F4A
4F6E  4317465F     MOV R7, R11
4F70  D0CE4317     ORRS R7, R2
4F72  E7F8D0CE     BEQ.N 0x4F12
4F74  42ACE7F8     B.N 0x4F68
4F76  DCE442AC     CMP R4, R5
4F78  DA03DCE4     BGT.N 0x4F44
4F7A  1E48DA03     BGE.N 0x4F84
4F7C  21011E48     SUBS R0, R1, #1
4F7E  43082101     MOVS R1, #1
4F80  E7E24308     ORRS R0, R1
4F82  455EE7E2     B.N 0x4F4A
4F84  D8DD455E     CMP R6, R11
4F86  D006D8DD     BHI.N 0x4F44
4F88  2000D006     BEQ.N 0x4F98
4F8A  455E2000     MOVS R0, #0
4F8C  D2DC455E     CMP R6, R11
4F8E  2301D2DC     BCS.N 0x4F4A
4F90  1E482301     MOVS R3, #1
4F92  43181E48     SUBS R0, R1, #1
4F94  E7D84318     ORRS R0, R3
4F96  45C4E7D8     B.N 0x4F4A
4F98  D8D345C4     CMP R12, R8
4F9A  2000D8D3     BHI.N 0x4F44
4F9C  45C42000     MOVS R0, #0
4F4A  4690BC3C     POP {R2, R3, R4, R5}
4F4C  46994690     MOV R8, R2
4F4E  46A24699     MOV R9, R3
4F50  46AB46A2     MOV R10, R4
4F52  BDF046AB     MOV R11, R5
4F54  2800BDF0     POP {R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/fixsfsi.c
5DD0  430241     LSLS R1, R0, #9
5DD2  FC20043     LSLS R3, R0, #1
5DD4  A490FC2     LSRS R2, R0, #31
5DD6  E1B0A49     LSRS R1, R1, #9
5DD8  20000E1B     LSRS R3, R3, #24
5DDA  2B7E2000     MOVS R0, #0
5DDC  DD0D2B7E     CMP R3, #126
5DDE  2B9DDD0D     BLE.N 0x5DFC
5DE0  DC0C2B9D     CMP R3, #157
5DE2  2080DC0C     BGT.N 0x5DFE
5DE4  4002080     MOVS R0, #128
5DE6  43010400     LSLS R0, R0, #16
5DE8  2B954301     ORRS R1, R0
5DEA  DC0A2B95     CMP R3, #149
5DEC  2096DC0A     BGT.N 0x5E04
5DEE  1AC32096     MOVS R0, #150
5DF0  40D91AC3     SUBS R3, R0, R3
5DF2  424840D9     LSRS R1, R3
5DF4  2A004248     RSBS R1, R0, #0
5DF6  D1002A00     CMP R2, #0
5DF8  8D100     BNE.N 0x5DFC
5DFA  47700008     MOVS R0, R1
5DFE  18D04B03     LDR R3, [PC, #12]
5E00  E7FB18D0     ADDS R0, R2, R3
5E02  3B96E7FB     B.N 0x5DFC
5E04  40993B96     SUBS R3, #150
5DFC  4B034770     BX LR
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/eqsf2.c
5BA8  42B570     PUSH {R4, R5, R6, LR}
5BAA  2450042     LSLS R2, R0, #1
5BAC  24E0245     LSLS R5, R0, #9
5BB2  A6D0FC3     LSRS R3, R0, #31
5BB4  E120A6D     LSRS R5, R5, #9
5BB6  A760E12     LSRS R2, R2, #24
5BAE  4C024E     LSLS R6, R1, #9
5BB0  FC3004C     LSLS R4, R1, #1
5BB8  E240A76     LSRS R6, R6, #9
5BBA  FC90E24     LSRS R4, R4, #24
5BBC  20010FC9     LSRS R1, R1, #31
5BBE  2AFF2001     MOVS R0, #1
5BC0  D0062AFF     CMP R2, #255
5BC2  2CFFD006     BEQ.N 0x5BD2
5BC4  D0032CFF     CMP R4, #255
5BC6  42A2D003     BEQ.N 0x5BD0
5BC8  D10142A2     CMP R2, R4
5BCA  42B5D101     BNE.N 0x5BD0
5BCC  D00642B5     CMP R5, R6
5BCE  BD70D006     BEQ.N 0x5BDE
5BD2  D1FC2D00     CMP R5, #0
5BD4  2CFFD1FC     BNE.N 0x5BD0
5BD6  D1FA2CFF     CMP R4, #255
5BD8  2E00D1FA     BNE.N 0x5BD0
5BDA  D1F82E00     CMP R6, #0
5BDC  428BD1F8     BNE.N 0x5BD0
5BDE  D006428B     CMP R3, R1
5BE0  2001D006     BEQ.N 0x5BF0
5BE2  2A002001     MOVS R0, #1
5BE4  D1F32A00     CMP R2, #0
5BE6  28D1F3     BNE.N 0x5BD0
5BE8  1E450028     MOVS R0, R5
5BEA  41A81E45     SUBS R5, R0, #1
5BEC  E7EF41A8     SBCS R0, R5
5BEE  2000E7EF     B.N 0x5BD0
5BF0  E7ED2000     MOVS R0, #0
5BD0  2D00BD70     POP {R4, R5, R6, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/eqdf2.c
5760  464FB5F0     PUSH {R4, R5, R6, R7, LR}
576A  31FB5C0     PUSH {R6, R7, LR}
5778  46804684     MOV R12, R0
5774  4D030E     LSLS R6, R1, #12
5776  4684004D     LSLS R5, R1, #1
577A  B364680     MOV R8, R0
577C  D6D0B36     LSRS R6, R6, #12
577E  FC90D6D     LSRS R5, R5, #21
5780  46910FC9     LSRS R1, R1, #31
5768  B5C0005C     LSLS R4, R3, #1
576C  FDB031F     LSLS R7, R3, #12
576E  469A0FDB     LSRS R3, R3, #31
5770  4B17469A     MOV R10, R3
5782  B3F4691     MOV R9, R2
5784  D640B3F     LSRS R7, R7, #12
5786  20010D64     LSRS R4, R4, #21
5772  30E4B17     LDR R3, [PC, #92]
5788  429D2001     MOVS R0, #1
578A  D008429D     CMP R5, R3
578C  429CD008     BEQ.N 0x57A0
578E  D001429C     CMP R4, R3
5790  42A5D001     BEQ.N 0x5796
5792  D00B42A5     CMP R5, R4
5794  BC1CD00B     BEQ.N 0x57AE
57A0  43334663     MOV R3, R12
57A2  D1F74333     ORRS R3, R6
57A4  42ACD1F7     BNE.N 0x5796
57A6  D1F542AC     CMP R4, R5
57A8  433AD1F5     BNE.N 0x5796
57AA  D1F3433A     ORRS R2, R7
57AC  2001D1F3     BNE.N 0x5796
57AE  42BE2001     MOVS R0, #1
57B0  D1F042BE     CMP R6, R7
57B2  45C8D1F0     BNE.N 0x5796
57B4  D1EE45C8     CMP R8, R9
57B6  4551D1EE     BNE.N 0x5796
57B8  D0074551     CMP R1, R10
57BA  2D00D007     BEQ.N 0x57CC
57BC  D1EA2D00     CMP R5, #0
57BE  4663D1EA     BNE.N 0x5796
57C0  431E4663     MOV R3, R12
57C2  30431E     ORRS R6, R3
57C4  1E460030     MOVS R0, R6
57C6  41B01E46     SUBS R6, R0, #1
57C8  E7E441B0     SBCS R0, R6
57CA  2000E7E4     B.N 0x5796
57CC  E7E22000     MOVS R0, #0
5796  4690BC1C     POP {R2, R3, R4}
5798  46994690     MOV R8, R2
579A  46A24699     MOV R9, R3
579C  BDF046A2     MOV R10, R4
579E  4663BDF0     POP {R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/divsf3.c
34C0  4657B5F0     PUSH {R4, R5, R6, R7, LR}
34C2  464E4657     MOV R7, R10
34C4  46DE464E     MOV R6, R9
34C6  464546DE     MOV LR, R11
34C8  B5E04645     MOV R5, R8
34CA  244B5E0     PUSH {R5, R6, R7, LR}
34D2  1C0FB083     SUB SP, #12
34D4  A641C0F     ADDS R7, R1, #0
34CC  430244     LSLS R4, R0, #9
34CE  FC60043     LSLS R3, R0, #1
34D0  B0830FC6     LSRS R6, R0, #31
34D6  E1B0A64     LSRS R4, R4, #9
34D8  46B20E1B     LSRS R3, R3, #24
34DA  D05346B2     MOV R10, R6
34DC  2BFFD053     BEQ.N 0x3486
34DE  D0272BFF     CMP R3, #255
34E0  2280D027     BEQ.N 0x3532
34E2  E42280     MOVS R2, #128
34E4  4D200E4     LSLS R4, R4, #3
34E6  431404D2     LSLS R2, R2, #19
34E8  227F4314     ORRS R4, R2
34EA  4252227F     MOVS R2, #127
34EC  46904252     RSBS R2, R2, #0
34EE  44984690     MOV R8, R2
34F0  23004498     ADD R8, R3
34F2  46992300     MOVS R3, #0
34F4  469B4699     MOV R9, R3
34F6  27D469B     MOV R11, R3
3532  D14E2C00     CMP R4, #0
3534  2308D14E     BNE.N 0x34D4
3536  46992308     MOVS R3, #8
3538  33F74699     MOV R9, R3
353A  469833F7     ADDS R3, #247
353C  3BFD4698     MOV R8, R3
353E  469B3BFD     SUBS R3, #253
3540  27D469B     MOV R11, R3
3586  D1172C00     CMP R4, #0
3588  2304D117     BNE.N .LBB7
358A  46992304     MOVS R3, #4
358C  23004699     MOV R9, R3
358E  46982300     MOVS R3, #0
3590  33014698     MOV R8, R3
3592  469B3301     ADDS R3, #1
3594  E7AF469B     MOV R11, R3
3596  20FFE7AF     B.N 0x34F8
3598  2D0020FF     MOVS R0, #255
35BA  F0020020     MOVS R0, R4
35BC  FC28F002     BL .LFE0, .Letext0
35BE  1F43FC28     STC2 P15, CR1, [R8], #-268
35C0  409C1F43     SUBS R3, R0, #5
35C2  2376409C     LSLS R4, R3
35C4  425B2376     MOVS R3, #118
35C6  1A1B425B     RSBS R3, R3, #0
35C8  46981A1B     SUBS R3, R3, R0
35CA  23004698     MOV R8, R3
35CC  46992300     MOVS R3, #0
35CE  469B4699     MOV R9, R3
35D0  E791469B     MOV R11, R3
35D2  230CE791     B.N 0x34F8
35D4  4699230C     MOVS R3, #12
35D6  33F34699     MOV R9, R3
35D8  469833F3     ADDS R3, #243
35DA  3BFC4698     MOV R8, R3
35DC  469B3BFC     SUBS R3, #252
35DE  E78A469B     MOV R11, R3
35E0  2B03E78A     B.N 0x34F8
34F8  78027D     LSLS R5, R7, #9
34FA  FFB0078     LSLS R0, R7, #1
34FC  A6D0FFB     LSRS R3, R7, #31
34FE  E000A6D     LSRS R5, R5, #9
3500  93000E00     LSRS R0, R0, #24
3502  D0249300     STR R3, [SP, #0]
3504  28FFD024     BEQ.N 0x3550
3506  D04628FF     CMP R0, #255
3508  2380D046     BEQ.N 0x3498
350A  21002380     MOVS R3, #128
350C  ED2100     MOVS R1, #0
350E  4DB00ED     LSLS R5, R5, #3
3510  431D04DB     LSLS R3, R3, #19
3512  387F431D     ORRS R5, R3
3514  4647387F     SUBS R0, #127
3542  78027D     LSLS R5, R7, #9
3544  FFB0078     LSLS R0, R7, #1
3546  A6D0FFB     LSRS R3, R7, #31
3548  E000A6D     LSRS R5, R5, #9
354A  93000E00     LSRS R0, R0, #24
354C  D1DA9300     STR R3, [SP, #0]
354E  2D00D1DA     BNE.N 0x3506
3550  D1262D00     CMP R5, #0
3552  2000D126     BNE.N .LBB6
3554  21012000     MOVS R0, #0
3556  332101     MOVS R1, #1
3558  9A000033     MOVS R3, R6
355A  4F7A9A00     LDR R2, [SP, #0]
359A  D10B2D00     CMP R5, #0
359C  2102D10B     BNE.N .LBE6
359E  E7DA2102     MOVS R1, #2
35A0  28E7DA     B.N 0x3558
35A2  F0020028     MOVS R0, R5
35A4  FC34F002     BL .LFE0, .Letext0
35A6  1F43FC34     LDC2 P15, CR1, [R4], #-268
35A8  409D1F43     SUBS R3, R0, #5
35AA  2376409D     LSLS R5, R3
35AC  425B2376     MOVS R3, #118
35AE  1A18425B     RSBS R3, R3, #0
35B0  21001A18     SUBS R0, R3, R0
35B2  E7AF2100     MOVS R1, #0
35B4  2103E7AF     B.N 0x3516
35B6  E7AD2103     MOVS R1, #3
35B8  20E7AD     B.N 0x3516
3516  1A384647     MOV R7, R8
3518  464F1A38     SUBS R0, R7, R0
351A  430F464F     MOV R7, R9
351C  BF430F     ORRS R7, R1
351E  46B900BF     LSLS R7, R7, #2
3520  3346B9     MOV R9, R7
3522  9A000033     MOVS R3, R6
3524  4F879A00     LDR R2, [SP, #0]
3526  40534F87     LDR R7, [PC, #540]
3528  464A4053     EORS R3, R2
352A  58BA464A     MOV R2, R9
352C  930158BA     LDR R2, [R7, R2]
352E  46979301     STR R3, [SP, #4]
3530  2C004697     MOV PC, R2
355C  40534F7A     LDR R7, [PC, #488]
355E  46424053     EORS R3, R2
3560  1A104642     MOV R2, R8
3562  464A1A10     SUBS R0, R2, R0
3564  430A464A     MOV R2, R9
3566  92430A     ORRS R2, R1
3568  58BA0092     LSLS R2, R2, #2
356A  1D58BA     LDR R2, [R7, R2]
356C  4697001D     MOVS R5, R3
356E  9B004697     MOV PC, R2
3570  2C9B00     LDR R3, [SP, #0]
3572  469A002C     MOVS R4, R5
3574  468B469A     MOV R10, R3
3576  465B468B     MOV R11, R1
35F2  24002100     MOVS R1, #0
35F4  402B2400     MOVS R4, #0
35F6  264402B     ANDS R3, R5
3612  23002480     MOVS R4, #128
3614  3E42300     MOVS R3, #0
3616  21FF03E4     LSLS R4, R4, #15
3618  E7ED21FF     MOVS R1, #255
361A  21FFE7ED     B.N .LBB8
361C  240021FF     MOVS R1, #255
361E  E7EA2400     MOVS R4, #0
3620  2301E7EA     B.N .LBB8
3634  3DB2380     MOVS R3, #128
3636  421C03DB     LSLS R3, R3, #15
3638  D038421C     TST R4, R3
363A  421DD038     BEQ.N 0x36AE
363C  D051421D     TST R5, R3
363E  431CD051     BEQ.N 0x35E4
3640  264431C     ORRS R4, R3
3642  A640264     LSLS R4, R4, #9
3644  330A64     LSRS R4, R4, #9
3646  21FF0033     MOVS R3, R6
3648  E7D521FF     MOVS R1, #255
364A  163E7D5     B.N .LBB8
364C  16C0163     LSLS R3, R4, #5
364E  42A3016C     LSLS R4, R5, #5
3650  D23B42A3     CMP R3, R4
3652  261BD23B     BCS.N 0x36CC
3654  2100261B     MOVS R6, #27
3656  38012100     MOVS R1, #0
3658  25013801     SUBS R0, #1
365A  1F2501     MOVS R5, #1
365C  49001F     MOVS R7, R3
365E  5B0049     LSLS R1, R1, #1
3660  2F00005B     LSLS R3, R3, #1
3662  DB012F00     CMP R7, #0
3664  429CDB01     BLT.N 0x366A
3666  D801429C     CMP R4, R3
3668  1B1BD801     BHI.N .LBE11
366A  43291B1B     SUBS R3, R3, R4
366C  3E014329     ORRS R1, R5
366E  2E003E01     SUBS R6, #1
3670  D1F32E00     CMP R6, #0
3672  1CD1F3     BNE.N 0x365C
3674  1E63001C     MOVS R4, R3
3676  419C1E63     SUBS R3, R4, #1
3678  430C419C     SBCS R4, R3
367A  1430C     ORRS R4, R1
36CC  261A1B1B     SUBS R3, R3, R4
36CE  2101261A     MOVS R6, #26
36D0  E7C22101     MOVS R1, #1
36D2  9B00E7C2     B.N .LBB11
36D4  468B9B00     LDR R3, [SP, #0]
36D6  469A468B     MOV R11, R1
36D8  2400469A     MOV R10, R3
36DA  E74C2400     MOVS R4, #0
36DC  263E74C     B.N 0x3578
36DE  D5E50263     LSLS R3, R4, #9
36E0  2500D5E5     BPL.N 0x36AE
36E2  24802500     MOVS R5, #0
36E4  3E42480     MOVS R4, #128
36E6  432C03E4     LSLS R4, R4, #15
36E8  264432C     ORRS R4, R5
36EA  A640264     LSLS R4, R4, #9
36EC  9B000A64     LSRS R4, R4, #9
36EE  21FF9B00     LDR R3, [SP, #0]
36F0  E78121FF     MOVS R1, #255
36F2  9501E781     B.N .LBB8
3578  2B02465B     MOV R3, R11
357A  D1312B02     CMP R3, #2
357C  4653D131     BNE.N 0x35E2
357E  21FF4653     MOV R3, R10
3580  240021FF     MOVS R1, #255
3582  E0382400     MOVS R4, #0
3584  2C00E038     B.N .LBB8
35E2  D1002B03     CMP R3, #3
35E4  E0A5D100     BNE.N 0x35E8
35E6  4655E0A5     B.N 0x3734
35E8  2B014655     MOV R5, R10
35EA  D0002B01     CMP R3, #1
35EC  E081D000     BEQ.N 0x35F0
35EE  2301E081     B.N 0x36F4
35F0  21002301     MOVS R3, #1
35F8  5C90264     LSLS R4, R4, #9
35FA  A6005C9     LSLS R1, R1, #23
35FC  7DB0A60     LSRS R0, R4, #9
35FE  430807DB     LSLS R3, R3, #31
3600  43184308     ORRS R0, R1
3602  B0034318     ORRS R0, R3
3622  1A592301     MOVS R3, #1
3624  291B1A59     SUBS R1, R3, R1
3626  DD66291B     CMP R1, #27
3628  9A01DD66     BLE.N .LBB8
362A  40139A01     LDR R2, [SP, #4]
362C  21004013     ANDS R3, R2
362E  24002100     MOVS R1, #0
3630  E7E12400     MOVS R4, #0
3632  2380E7E1     B.N .LBB8
367C  317F0001     MOVS R1, R0
367E  2900317F     ADDS R1, #127
3680  DDCE2900     CMP R1, #0
3682  763DDCE     BLE.N 0x3622
3684  D0040763     LSLS R3, R4, #29
3686  230FD004     BEQ.N 0x3692
3688  4023230F     MOVS R3, #15
368A  2B044023     ANDS R3, R4
368C  D0002B04     CMP R3, #4
368E  3404D000     BEQ.N 0x3692
3690  1233404     ADDS R4, #4
3692  D5030123     LSLS R3, R4, #4
3694  1D503     BPL.N 0x369E
3696  4B2C0001     MOVS R1, R0
3698  31804B2C     LDR R3, [PC, #176]
369A  401C3180     ADDS R1, #128
369C  29FE401C     ANDS R4, R3
369E  DD0D29FE     CMP R1, #254
36A0  2301DD0D     BLE.N 0x36BE
36A2  9A012301     MOVS R3, #1
36A4  21FF9A01     LDR R2, [SP, #4]
36A6  401321FF     MOVS R1, #255
36A8  24004013     ANDS R3, R2
36AA  E7A42400     MOVS R4, #0
36AC  2380E7A4     B.N .LBB8
36AE  3DB2380     MOVS R3, #128
36B0  431C03DB     LSLS R3, R3, #15
36B2  264431C     ORRS R4, R3
36B4  A640264     LSLS R4, R4, #9
36B6  330A64     LSRS R4, R4, #9
36B8  21FF0033     MOVS R3, R6
36BA  E79C21FF     MOVS R1, #255
36BC  2301E79C     B.N .LBB8
36BE  9A012301     MOVS R3, #1
36C0  1A49A01     LDR R2, [SP, #4]
36C2  A6401A4     LSLS R4, R4, #6
36C4  B2C90A64     LSRS R4, R4, #9
36C6  4013B2C9     UXTB R1, R1
36C8  E7954013     ANDS R3, R2
36CA  1B1BE795     B.N .LBB8
36F4  E7C19501     STR R5, [SP, #4]
36F6  23E7C1     B.N 0x367C
36F8  20200023     MOVS R3, R4
36FA  40CB2020     MOVS R0, #32
36FC  1A4140CB     LSRS R3, R1
36FE  408C1A41     SUBS R1, R0, R1
3700  1E61408C     LSLS R4, R1
3702  418C1E61     SUBS R1, R4, #1
3704  431C418C     SBCS R4, R1
3706  763431C     ORRS R4, R3
3708  D0040763     LSLS R3, R4, #29
370A  230FD004     BEQ.N 0x3716
370C  4023230F     MOVS R3, #15
370E  2B044023     ANDS R3, R4
3710  D0002B04     CMP R3, #4
3712  3404D000     BEQ.N 0x3716
3714  1633404     ADDS R4, #4
3716  D5050163     LSLS R3, R4, #5
3718  2301D505     BPL.N 0x3726
371A  9A012301     MOVS R3, #1
371C  21019A01     LDR R2, [SP, #4]
371E  40132101     MOVS R1, #1
3720  24004013     ANDS R3, R2
3722  E7682400     MOVS R4, #0
3724  2301E768     B.N .LBB8
3726  9A012301     MOVS R3, #1
3728  1A49A01     LDR R2, [SP, #4]
372A  A6401A4     LSLS R4, R4, #6
372C  40130A64     LSRS R4, R4, #9
372E  21004013     ANDS R3, R2
3730  E7612100     MOVS R1, #0
3604  BC3CB003     ADD SP, #12
3606  4690BC3C     POP {R2, R3, R4, R5}
3608  46994690     MOV R8, R2
360A  46A24699     MOV R9, R3
360C  46AB46A2     MOV R10, R4
360E  BDF046AB     MOV R11, R5
3610  2480BDF0     POP {R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/soft-fp/addsf3.c
28A4  46C6B5F0     PUSH {R4, R5, R6, R7, LR}
28A6  24E46C6     MOV LR, R8
28BA  E24B500     PUSH {LR}
28AA  A760247     LSLS R7, R0, #9
28AE  440A7B     LSRS R3, R7, #9
28B0  FC50044     LSLS R4, R0, #1
28B2  F70FC5     LSRS R5, R0, #31
28B8  B5004698     MOV R8, R3
28BC  2A0E24     LSRS R4, R4, #24
28BE  DB002A     MOVS R2, R5
28C0  E0000DB     LSLS R3, R3, #3
28A8  247024E     LSLS R6, R1, #9
28AC  A7B0A76     LSRS R6, R6, #9
28B4  4800F7     LSLS R7, R6, #3
28B6  46980048     LSLS R0, R1, #1
28C2  FC90E00     LSRS R0, R0, #24
28C4  46BC0FC9     LSRS R1, R1, #31
28C6  428D46BC     MOV R12, R7
2A96  1AD30004     MOVS R4, R0
2ABC  24FF4663     MOV R3, R12
2ABE  D24FF     MOVS R4, #255
2AC0  E72A000D     MOVS R5, R1
2AC2  29FFE72A     B.N .L5, .L41
2B3C  E7470004     MOVS R4, R0
2B3E  2B00E747     B.N .L10
2B4E  4003B     MOVS R3, R7
2B50  D0004     MOVS R4, R0
2B52  E6E1000D     MOVS R5, R1
2B54  28FFE6E1     B.N .L5, .L41
2B94  24FF4663     MOV R3, R12
2B9E  4003B     MOVS R3, R7
2BA0  E6BA0004     MOVS R4, R0
2BA2  2680E6BA     B.N .L5, .L41
2BA4  22002680     MOVS R6, #128
2BA6  3F62200     MOVS R2, #0
2BA8  E6F003F6     LSLS R6, R6, #15
2BAA  3BE6F0     B.N 0x298E
2BAC  E6B4003B     MOVS R3, R7
2BAE  1E33E6B4     B.N .L5, .L41
2BB0  D0001E33     SUBS R3, R6, #0
28C8  D067428D     CMP R5, R1
28CA  1A22D067     BEQ.N $d
28CC  2A001A22     SUBS R2, R4, R0
28CE  DC002A00     CMP R2, #0
28D0  E0A5DC00     BGT.N 0x28D4
28D2  2800E0A5     B.N 0x2A20
28D4  D13A2800     CMP R0, #0
28D6  2F00D13A     BNE.N 0x294E
28D8  D1002F00     CMP R7, #0
28DA  E093D100     BNE.N 0x28DE
28DC  1E51E093     B.N 0x2A06
28DE  29001E51     SUBS R1, R2, #1
28E0  D0002900     CMP R1, #0
28E2  E0BCD000     BEQ.N 0x28E6
28E4  2401E0BC     B.N 0x2A60
28E6  1BDB2401     MOVS R4, #1
28E8  15A1BDB     SUBS R3, R3, R7
28EA  D546015A     LSLS R2, R3, #5
28EC  19BD546     BPL.N 0x287C
28EE  99E019B     LSLS R3, R3, #6
28F0  30099E     LSRS R6, R3, #6
28F2  F0030030     MOVS R0, R6
28F4  FA8CF003     BL .LFE0, .Letext0
28F6  3805FA8C     SADD8 R8, R12, R5
28F8  40863805     SUBS R0, #5
28FA  42844086     LSLS R6, R0
28FC  DD004284     CMP R4, R0
28FE  E09DDD00     BLE.N 0x2902
2900  1B04E09D     B.N 0x2A3E
2902  321B04     SUBS R4, R0, R4
2904  20200032     MOVS R2, R6
2906  34012020     MOVS R0, #32
2908  40E23401     ADDS R4, #1
290A  1B0440E2     LSRS R2, R4
290C  40A61B04     SUBS R4, R0, R4
290E  3340A6     LSLS R6, R4
2910  1E5E0033     MOVS R3, R6
2912  41B31E5E     SUBS R6, R3, #1
2914  240041B3     SBCS R3, R6
2916  43132400     MOVS R4, #0
2918  75A4313     ORRS R3, R2
294E  D0E32CFF     CMP R4, #255
2950  2180D0E3     BEQ.N .L5, .L41
2952  382180     MOVS R1, #128
2954  4C90038     MOVS R0, R7
2956  430804C9     LSLS R1, R1, #19
2958  46844308     ORRS R0, R1
295A  2A1B4684     MOV R12, R0
295C  DD002A1B     CMP R2, #27
295E  E082DD00     BLE.N 0x2962
2960  2020E082     B.N 0x2A68
2962  46612020     MOVS R0, #32
2964  40D14661     MOV R1, R12
2966  1A8240D1     LSRS R1, R2
2968  46601A82     SUBS R2, R0, R2
296A  40904660     MOV R0, R12
296C  24090     LSLS R0, R2
296E  1E500002     MOVS R2, R0
2970  41821E50     SUBS R0, R2, #1
2972  430A4182     SBCS R2, R0
2974  1A9B430A     ORRS R2, R1
2976  15A1A9B     SUBS R3, R3, R2
2978  D4B8015A     LSLS R2, R3, #5
297A  75AD4B8     BMI.N 0x2AEE
299C  29001A21     SUBS R1, R4, R0
299E  DD522900     CMP R1, #0
29A0  2800DD52     BLE.N .LBE14
29A2  D0312800     CMP R0, #0
29A4  2CFFD031     BEQ.N 0x2A0A
29A6  D0B72CFF     CMP R4, #255
29A8  2080D0B7     BEQ.N 0x2B1A
29AA  3E2080     MOVS R0, #128
29AC  4C0003E     MOVS R6, R7
29AE  430604C0     LSLS R0, R0, #19
29B0  46B44306     ORRS R6, R0
29B2  291B46B4     MOV R12, R6
29B4  DD00291B     CMP R1, #27
29B6  E0AADD00     BLE.N 0x29BA
29B8  2620E0AA     B.N 0x2B10
29BA  46602620     MOVS R6, #32
29BC  40C84660     MOV R0, R12
29BE  1A7140C8     LSRS R0, R1
29C0  46661A71     SUBS R1, R6, R1
29C2  408E4666     MOV R6, R12
29C4  31408E     LSLS R6, R1
29C6  1E4E0031     MOVS R1, R6
29C8  41B11E4E     SUBS R6, R1, #1
29CA  430141B1     SBCS R1, R6
29CC  185B4301     ORRS R1, R0
29CE  159185B     ADDS R3, R3, R1
29D0  D5D30159     LSLS R1, R3, #5
29D2  3401D5D3     BPL.N 0x297C
29D4  2CFF3401     ADDS R4, #1
29D6  D1002CFF     CMP R4, #255
29D8  E087D100     BNE.N 0x29DC
29DA  2201E087     B.N 0x2AEC
29DC  49782201     MOVS R2, #1
29DE  401A4978     LDR R1, [PC, #480]
29E0  85B401A     ANDS R2, R3
29E2  400B085B     LSRS R3, R3, #1
29E4  4313400B     ANDS R3, R1
29E6  E7974313     ORRS R3, R2
29E8  2C00E797     B.N .L5, .L41
29EA  D0002C00     CMP R4, #0
29EC  E0A7D000     BEQ.N 0x29F0
29EE  2B00E0A7     B.N 0x2B40
29F0  D0002B00     CMP R3, #0
29F2  E0B6D000     BEQ.N 0x29F6
29F4  1E3BE0B6     B.N 0x2B64
29F6  D1621E3B     SUBS R3, R7, #0
29F8  2600D162     BNE.N 0x29C0
29FA  22002600     MOVS R6, #0
29FC  2732200     MOVS R2, #0
29FE  A5B0273     LSLS R3, R6, #9
2A00  B2E40A5B     LSRS R3, R3, #9
2A02  E79AB2E4     UXTB R4, R4
2A04  14E79A     B.N .LBB14
2A06  E7870014     MOVS R4, R2
2A08  2F00E787     B.N .L5, .L41
2A0A  D04D2F00     CMP R7, #0
2A0C  1E48D04D     BEQ.N 0x29AA
2A0E  28001E48     SUBS R0, R1, #1
2A10  D1572800     CMP R0, #0
2A12  4463D157     BNE.N 0x29C4
2A14  24014463     ADD R3, R12
2A16  15A2401     MOVS R4, #1
2A18  D5AF015A     LSLS R2, R3, #5
2A1A  2402D5AF     BPL.N 0x2B7C
2A1C  E7DD2402     MOVS R4, #2
2A1E  2A00E7DD     B.N 0x29DC
2A20  D1242A00     CMP R2, #0
2A22  1C62D124     BNE.N 0x2A6E
2A24  B2D21C62     ADDS R2, R4, #1
2A26  2A01B2D2     UXTB R2, R2
2A28  DDDE2A01     CMP R2, #1
2A2A  1BDEDDDE     BLE.N 0x29EA
2A2C  1721BDE     SUBS R6, R3, R7
2A2E  D5350172     LSLS R2, R6, #5
2A30  1AFED535     BPL.N 0x2A9E
2A32  D1AFE     SUBS R6, R7, R3
2A34  E75C000D     MOVS R5, R1
2A36  2AE75C     B.N .L39
2A38  2300002A     MOVS R2, R5
2A3E  4A600033     MOVS R3, R6
2A40  1A244A60     LDR R2, [PC, #384]
2A42  40131A24     SUBS R4, R4, R0
2A44  E7684013     ANDS R3, R2
2A46  2900E768     B.N .L5, .L41
2A48  D1632900     CMP R1, #0
2A4A  1C61D163     BNE.N 0x2A14
2A4C  B2C81C61     ADDS R1, R4, #1
2A4E  2801B2C8     UXTB R0, R1
2A50  DD4E2801     CMP R0, #1
2A52  29FFDD4E     BLE.N 0x29F2
2A54  D04929FF     CMP R1, #255
2A56  4463D049     BEQ.N 0x29EC
2A58  85B4463     ADD R3, R12
2A5A  C085B     LSRS R3, R3, #1
2A5C  E75C000C     MOVS R4, R1
2A5E  2AFFE75C     B.N .L5, .L41
2A60  D0412AFF     CMP R2, #255
2A62  AD041     BEQ.N 0x29E8
2A64  E779000A     MOVS R2, R1
2A66  2201E779     B.N 0x295C
2A68  1A9B2201     MOVS R2, #1
2A6A  E7841A9B     SUBS R3, R3, R2
2A6C  2C00E784     B.N 0x2978
2A6E  D01D2C00     CMP R4, #0
2A70  28FFD01D     BEQ.N 0x2AAE
2A72  D02228FF     CMP R0, #255
2A74  2480D022     BEQ.N 0x2ABC
2A76  4E42480     MOVS R4, #128
2A78  425204E4     LSLS R4, R4, #19
2A7A  43234252     RSBS R2, R2, #0
2A7C  2A1B4323     ORRS R3, R4
2A7E  DD002A1B     CMP R2, #27
2A80  E08ADD00     BLE.N 0x2A84
2A82  1CE08A     B.N 0x2B9A
2A84  2520001C     MOVS R4, R3
2A86  40D42520     MOVS R5, #32
2A88  1AAA40D4     LSRS R4, R2
2A8A  40931AAA     SUBS R2, R5, R2
2A8C  1E5A4093     LSLS R3, R2
2A8E  41931E5A     SUBS R2, R3, #1
2A90  43234193     SBCS R3, R2
2A92  46624323     ORRS R3, R4
2A94  44662     MOV R2, R12
2A98  D1AD3     SUBS R3, R2, R3
2A9A  E725000D     MOVS R5, R1
2A9C  2E00E725     B.N .L24
2A9E  D0002E00     CMP R6, #0
2AA0  E726D000     BEQ.N 0x2AA4
2AA2  2200E726     B.N .L39
2AA4  24002200     MOVS R2, #0
2AA6  E7A92400     MOVS R4, #0
2AA8  CE7A9     B.N 0x29FE
2AAA  E735000C     MOVS R4, R1
2AAC  2B00E735     B.N .L5, .L41
2AAE  D04D2B00     CMP R3, #0
2AB0  43D2D04D     BEQ.N 0x2A4E
2AB2  2A0043D2     MVNS R2, R2
2AB4  D0ED2A00     CMP R2, #0
2AB6  28FFD0ED     BEQ.N 0x2A94
2AB8  D1E028FF     CMP R0, #255
2ABA  4663D1E0     BNE.N 0x2A7E
2AC4  D00F29FF     CMP R1, #255
2AC6  1D00F     BEQ.N 0x2AE8
2AC8  E7730001     MOVS R1, R0
2ACA  2B00E773     B.N 0x29B4
2ACC  D0612B00     CMP R3, #0
2ACE  24FFD061     BEQ.N 0x2A94
2AD0  2F0024FF     MOVS R4, #255
2AD2  D1002F00     CMP R7, #0
2AD4  E720D100     BNE.N 0x2AD8
2AD6  2280E720     B.N .L5, .L41
2AD8  46412280     MOVS R2, #128
2ADA  3D24641     MOV R1, R8
2ADC  421103D2     LSLS R2, R2, #15
2ADE  D0024211     TST R1, R2
2AE0  4216D002     BEQ.N 0x2AE8
2AE2  D1004216     TST R6, R2
2AE4  3BD100     BNE.N 0x2AE8
2AE6  24FF003B     MOVS R3, R7
2AE8  E71624FF     MOVS R4, #255
2AEA  24FFE716     B.N .L5, .L41
2AF2  D1EA2C00     CMP R4, #0
2AF4  2B00D1EA     BNE.N 0x2ACC
2AF6  D0582B00     CMP R3, #0
2AF8  2F00D058     BEQ.N 0x2AAC
2AFA  D1002F00     CMP R7, #0
2AFC  E70CD100     BNE.N 0x2B00
2AFE  4463E70C     B.N .L5, .L41
2B00  15A4463     ADD R3, R12
2B02  D400015A     LSLS R2, R3, #5
2B04  E739D400     BMI.N 0x2B08
2B06  4A2EE739     B.N 0x297C
2B08  C4A2E     LDR R2, [PC, #184]
2B0A  4013000C     MOVS R4, R1
2B0C  E7044013     ANDS R3, R2
2B0E  2101E704     B.N .L5, .L41
2B10  E75C2101     MOVS R1, #1
2B12  2C00E75C     B.N 0x29CE
2B14  D11E2C00     CMP R4, #0
2B16  2B00D11E     BNE.N 0x2B56
2B18  D0402B00     CMP R3, #0
2B1A  43C9D040     BEQ.N 0x2A9E
2B1C  290043C9     MVNS R1, R1
2B1E  D00B2900     CMP R1, #0
2B20  28FFD00B     BEQ.N 0x2B3A
2B22  D03628FF     CMP R0, #255
2B24  291BD036     BEQ.N 0x2B94
2B26  DC47291B     CMP R1, #27
2B28  1CDC47     BGT.N 0x2ABA
2B2A  2620001C     MOVS R4, R3
2B2C  40CC2620     MOVS R6, #32
2B2E  1A7140CC     LSRS R4, R1
2B30  408B1A71     SUBS R1, R6, R1
2B32  1E59408B     LSLS R3, R1
2B34  418B1E59     SUBS R1, R3, #1
2B36  4323418B     SBCS R3, R1
2B38  44634323     ORRS R3, R4
2B3A  44463     ADD R3, R12
2B40  D1182B00     CMP R3, #0
2B42  1E3BD118     BNE.N 0x2B76
2B44  D02D1E3B     SUBS R3, R7, #0
2B46  DD02D     BEQ.N 0x2BA4
2B48  24FF000D     MOVS R5, R1
2B4A  E6E524FF     MOVS R4, #255
2B4C  3BE6E5     B.N .L5, .L41
2B56  D01C28FF     CMP R0, #255
2B58  2480D01C     BEQ.N 0x2B94
2B5A  4E42480     MOVS R4, #128
2B5C  424904E4     LSLS R4, R4, #19
2B5E  43234249     RSBS R1, R1, #0
2B60  E7E04323     ORRS R3, R4
2B62  2F00E7E0     B.N 0x2B26
2B64  D1002F00     CMP R7, #0
2B66  E6D7D100     BNE.N 0x2B6A
2B68  1BDEE6D7     B.N .L5, .L41
2B6A  1721BDE     SUBS R6, R3, R7
2B6C  D51F0172     LSLS R2, R6, #5
2B6E  1AFBD51F     BPL.N 0x2BB0
2B70  D1AFB     SUBS R3, R7, R3
2B72  E6D1000D     MOVS R5, R1
2B74  24FFE6D1     B.N .L5, .L41
2B76  2F0024FF     MOVS R4, #255
2B78  D1002F00     CMP R7, #0
2B7A  E6CDD100     BNE.N 0x2B7E
2B7C  2280E6CD     B.N .L5, .L41
2B7E  46402280     MOVS R2, #128
2B80  3D24640     MOV R0, R8
2B82  421003D2     LSLS R2, R2, #15
2B84  D0AF4210     TST R0, R2
2B86  4216D0AF     BEQ.N 0x2CE8
2B88  D1AD4216     TST R6, R2
2B8A  3BD1AD     BNE.N 0x2CE8
2B8C  D003B     MOVS R3, R7
2B8E  24FF000D     MOVS R5, R1
2B90  E6C224FF     MOVS R4, #255
2B92  4663E6C2     B.N .L5, .L41
2B96  E6BF24FF     MOVS R4, #255
2B98  2301E6BF     B.N .L5, .L41
2B9A  E77A2301     MOVS R3, #1
2B9C  3BE77A     B.N 0x2A94
2BB2  E6E2D000     BEQ.N 0x2BB6
2BB4  2200E6E2     B.N 0x297C
2BB6  E7212200     MOVS R2, #0
2BB8  2301E721     B.N 0x29FE
2BBA  E7BD2301     MOVS R3, #1
291A  D004075A     LSLS R2, R3, #29
291C  220FD004     BEQ.N 0x2928
291E  401A220F     MOVS R2, #15
2920  2A04401A     ANDS R2, R3
2922  D0002A04     CMP R2, #4
2924  3304D000     BEQ.N 0x2928
2926  15A3304     ADDS R3, #4
2928  D529015A     LSLS R2, R3, #5
292A  3401D529     BPL.N 0x2980
292C  2CFF3401     ADDS R4, #1
292E  D1002CFF     CMP R4, #255
2930  E081D100     BNE.N 0x2934
2932  2AE081     B.N 0x2A38
2934  19B002A     MOVS R2, R5
2936  A5B019B     LSLS R3, R3, #6
2938  B2E40A5B     LSRS R3, R3, #9
293A  25BB2E4     UXTB R4, R4
293C  5E4025B     LSLS R3, R3, #9
293E  A5805E4     LSLS R4, R4, #23
2940  7D20A58     LSRS R0, R3, #9
2942  432007D2     LSLS R2, R2, #31
2944  43104320     ORRS R0, R4
2946  BC044310     ORRS R0, R2
297C  D1CE075A     LSLS R2, R3, #29
297E  8DED1CE     BNE.N 0x291E
2980  2A08DE     LSRS R6, R3, #3
2982  2CFF002A     MOVS R2, R5
2984  D13A2CFF     CMP R4, #255
2986  2E00D13A     BNE.N 0x29FE
2988  D1002E00     CMP R6, #0
298A  E0AED100     BNE.N 0x298E
298C  2380E0AE     B.N 0x2AEC
298E  3DB2380     MOVS R3, #128
2990  433303DB     LSLS R3, R3, #15
2992  25B4333     ORRS R3, R6
2994  A5B025B     LSLS R3, R3, #9
2996  24FF0A5B     LSRS R3, R3, #9
2998  E7CF24FF     MOVS R4, #255
299A  1A21E7CF     B.N .LBB14
2A3A  E77E2300     MOVS R3, #0
2A3C  33E77E     B.N .LBB14
2AEC  230024FF     MOVS R4, #255
2AEE  E7242300     MOVS R3, #0
2AF0  2C00E724     B.N .LBB14
2948  4690BC04     POP {R2}
294A  BDF04690     MOV R8, R2
294C  2CFFBDF0     POP {R4, R5, R6, R7, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/libgcc2.c
60CE  5C9B510     PUSH {R4, LR}
60D2  F7FF1C04     ADDS R4, R0, #0
60CC  B510219E     MOVS R1, #158
60D0  1C0405C9     LSLS R1, R1, #23
60D4  FB3AF7FF     BL 0x574C
60D6  2800FB3A     SMLAWB R8, R10, R0, R2
60D8  D1032800     CMP R0, #0
60DA  1C20D103     BNE.N 0x60E4
60E4  1C20219E     MOVS R1, #158
60DC  F7FF1C20     ADDS R0, R4, #0
60DE  FE77F7FF     BL __aeabi_f2iz
60E0  BD10FE77     MRC2 P13, #3, R11, CR7, CR0, {0}
60E2  219EBD10     POP {R4, PC}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/config/arm/lib1funcs.S
44D8  8432200     MOVS R2, #0
45D8  2000B501     PUSH {R0, LR}
45E4  D0F72900     CMP R1, #0
45E6  E776D0F7     BEQ.N 0x45D8
45E8  4770E776     B.N .LFE8, .Letext0, .udivsi3_skip_div0_test
45EA  4A3A4770     BX LR
41D0  430B4603     MOV R3, R0
41D2  D47F430B     ORRS R3, R1
41D4  2200D47F     BMI.N 0x41D6
41D6  8432200     MOVS R2, #0
42D6  D0000FCA     LSRS R2, R1, #31
4392  2000B501     PUSH {R0, LR}
439C  D0F82900     CMP R1, #0
439E  E716D0F8     BEQ.N 0x4392
43A0  4770E716     B.N .divsi3_skip_div0_test
43A2  B5104770     BX LR
6534  46C04770     BX LR
5E10  2301211C     MOVS R1, #28
5E12  41B2301     MOVS R3, #1
5E14  4298041B     LSLS R3, R3, #16
5E16  D3014298     CMP R0, R3
5E18  C00D301     BCC.N 0x5E1E
5E1A  39100C00     LSRS R0, R0, #16
5E1C  A1B3910     SUBS R1, #16
5E1E  42980A1B     LSRS R3, R3, #8
5E20  D3014298     CMP R0, R3
5E22  A00D301     BCC.N 0x5E28
5E24  39080A00     LSRS R0, R0, #8
5E26  91B3908     SUBS R1, #8
5E28  4298091B     LSRS R3, R3, #4
5E2A  D3014298     CMP R0, R3
5E2C  900D301     BCC.N 0x5E32
5E2E  39040900     LSRS R0, R0, #4
5E30  A2023904     SUBS R1, #4
5E32  5C10A202     ADR R2, [PC, #8]
5E34  18405C10     LDRB R0, [R2, R0]
5E36  47701840     ADDS R0, R0, R1
5E38  46C04770     BX LR
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32c-source/XC32-arm-gcc/gcc/libgcc/config/arm/bpabi-v6m.S
56EC  1C084684     MOV R12, R0
56EE  46611C08     ADDS R0, R1, #0
56F0  E7FF4661     MOV R1, R12
56F2  B51FE7FF     B.N 0x56F4
56F4  F7FFB51F     PUSH {R0, R1, R2, R3, R4, LR}
56F6  FE7DF7FF     BL __lesf2
56FA  D4012800     CMP R0, #0
56FC  2100D401     BMI.N 0x5702
56FE  42C82100     MOVS R1, #0
5700  BD1F42C8     CMN R0, R1
5702  B510BD1F     POP {R0, R1, R2, R3, R4, PC}
5704  F000B510     PUSH {R4, LR}
5706  FA4FF000     BL __eqsf2
570A  30014240     RSBS R0, R0, #0
570C  BD103001     ADDS R0, #1
570E  B510BD10     POP {R4, PC}
5710  F7FFB510     PUSH {R4, LR}
5724  F7FFB510     PUSH {R4, LR}
5738  F7FFB510     PUSH {R4, LR}
574C  F7FFB510     PUSH {R4, LR}
55FC  1C104684     MOV R12, R0
55FE  46621C10     ADDS R0, R2, #0
5600  468C4662     MOV R2, R12
5602  1C19468C     MOV R12, R1
5604  46631C19     ADDS R1, R3, #0
5606  E0004663     MOV R3, R12
5608  46C0E000     B.N 0x560C
560C  F7FFB51F     PUSH {R0, R1, R2, R3, R4, LR}
560E  FCCBF7FF     BL __ledf2
5612  D4012800     CMP R0, #0
5614  2100D401     BMI.N 0x561A
5616  42C82100     MOVS R1, #0
5618  BD1F42C8     CMN R0, R1
561A  B510BD1F     POP {R0, R1, R2, R3, R4, PC}
561C  F000B510     PUSH {R4, LR}
561E  F89FF000     BL __eqdf2
5622  30014240     RSBS R0, R0, #0
5624  BD103001     ADDS R0, #1
5626  B510BD10     POP {R4, PC}
5628  F7FFB510     PUSH {R4, LR}
563C  F7FFB510     PUSH {R4, LR}
5650  F7FFB510     PUSH {R4, LR}
5664  F7FFB510     PUSH {R4, LR}
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/build-pic32c-native-nolm/pic32c-libs/libpic32c/stubs/data_init.c
5260  2100B570     PUSH {R4, R5, R6, LR}
525C  4B214A20     LDR R2, $d
525E  B5704B21     LDR R3, [PC, #132]
5264  D2034293     CMP R3, R2
5266  7019D203     BCS.N 0x5270
526A  42933301     ADDS R3, #1
526C  D1FB4293     CMP R3, R2
526E  2500D1FB     BNE.N 0x5268
5262  42932100     MOVS R1, #0
5268  33017019     STRB R1, [R3]
5276  68416803     LDR R3, [R0]
527A  D1182B00     CMP R3, #0
527C  2900D118     BNE.N 0x52B0
527E  D02D2900     CMP R1, #0
5280  6883D02D     BEQ.N 0x52DE
52A8  68416803     LDR R3, [R0]
52AC  D0E62B00     CMP R3, #0
52AE  6882D0E6     BEQ.N 0x527E
5270  26032500     MOVS R5, #0
5274  6803481C     LDR R0, [PC, #112]
528A  22002300     MOVS R3, #0
528C  5C842200     MOVS R2, #0
5278  2B006841     LDR R1, [R0, #4]
52AA  2B006841     LDR R1, [R0, #4]
5282  300C6883     LDR R3, [R0, #8]
52B0  300C6882     LDR R2, [R0, #8]
5284  2B00300C     ADDS R0, #12
52B2  2A00300C     ADDS R0, #12
5286  D0182B00     CMP R3, #0
5288  2300D018     BEQ.N 0x52BC
52B4  D1072A00     CMP R2, #0
52B6  2900D107     BNE.N 0x52C8
5292  428A3201     ADDS R2, #1
5294  D3FA428A     CMP R2, R1
5296  33D3FA     BCC.N 0x528E
52C8  D1DF2900     CMP R1, #0
52CA  33D1DF     BNE.N 0x528C
528E  549C5C84     LDRB R4, [R0, R2]
5290  3201549C     STRB R4, [R3, R2]
5272  481C2603     MOVS R6, #3
5298  400B0033     MOVS R3, R6
529A  1E5A400B     ANDS R3, R1
529C  41931E5A     SUBS R2, R3, #1
529E  8894193     SBCS R3, R2
52A0  18590889     LSRS R1, R1, #2
52A2  891859     ADDS R1, R3, R1
52A4  18400089     LSLS R1, R1, #2
52A6  68031840     ADDS R0, R0, R1
52CC  400B0033     MOVS R3, R6
52CE  1E5A400B     ANDS R3, R1
52D0  41931E5A     SUBS R2, R3, #1
52D2  8894193     SBCS R3, R2
52D4  18590889     LSRS R1, R1, #2
52D6  891859     ADDS R1, R3, R1
52D8  18400089     LSLS R1, R1, #2
52DA  E7E41840     ADDS R0, R0, R1
52DC  BD70E7E4     B.N 0x52A8
52B8  D0DC2900     CMP R1, #0
52BA  1859D0DC     BEQ.N 0x5276
52BC  701D1859     ADDS R1, R3, R1
52C2  D1FB428B     CMP R3, R1
52C4  E7D6D1FB     BNE.N 0x52BE
52C6  2900E7D6     B.N 0x5276
52BE  3301701D     STRB R5, [R3]
52C0  428B3301     ADDS R3, #1
52DE  2248BD70     POP {R4, R5, R6, PC}
52E0  20002248     MOVS R2, #72
52E2  2000     MOVS R0, #0
52E4  20000000     MOVS R0, R0
52E6  CB82000     MOVS R0, #0
52E8  0CB8     LSRS R0, R7, #18
52EA  B5100000     MOVS R0, R0
